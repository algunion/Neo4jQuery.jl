<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Neo4jQuery.jl — LLM Reference · Neo4jQuery.jl</title><meta name="title" content="Neo4jQuery.jl — LLM Reference · Neo4jQuery.jl"/><meta property="og:title" content="Neo4jQuery.jl — LLM Reference · Neo4jQuery.jl"/><meta property="twitter:title" content="Neo4jQuery.jl — LLM Reference · Neo4jQuery.jl"/><meta name="description" content="Documentation for Neo4jQuery.jl."/><meta property="og:description" content="Documentation for Neo4jQuery.jl."/><meta property="twitter:description" content="Documentation for Neo4jQuery.jl."/><meta property="og:url" content="https://algunion.github.io/Neo4jQuery.jl/llm/"/><meta property="twitter:url" content="https://algunion.github.io/Neo4jQuery.jl/llm/"/><link rel="canonical" href="https://algunion.github.io/Neo4jQuery.jl/llm/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Neo4jQuery.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../guide/connections/">Connections</a></li><li><a class="tocitem" href="../guide/queries/">Queries</a></li><li><a class="tocitem" href="../guide/transactions/">Transactions</a></li><li><a class="tocitem" href="../guide/streaming/">Streaming</a></li><li><a class="tocitem" href="../guide/dsl/">DSL</a></li><li><a class="tocitem" href="../guide/biomedical_case_study/">Biomedical Case Study</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Neo4jQuery.jl — LLM Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Neo4jQuery.jl — LLM Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/algunion/Neo4jQuery.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/algunion/Neo4jQuery.jl/blob/main/docs/src/llm.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Neo4jQuery.jl-—-LLM-Reference"><a class="docs-heading-anchor" href="#Neo4jQuery.jl-—-LLM-Reference">Neo4jQuery.jl — LLM Reference</a><a id="Neo4jQuery.jl-—-LLM-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Neo4jQuery.jl-—-LLM-Reference" title="Permalink"></a></h1><p>Complete, high-signal reference for Neo4jQuery.jl — a Julia client for Neo4j using the Query API v2 over HTTP with Typed JSON.</p><hr/><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Pkg
Pkg.add(url=&quot;https://github.com/algunion/Neo4jQuery.jl&quot;)</code></pre><p>Requires Neo4j 5.x+ with Query API v2 enabled (default for Aura and Community/Enterprise 5.x+).</p><hr/><h2 id="Exports"><a class="docs-heading-anchor" href="#Exports">Exports</a><a id="Exports-1"></a><a class="docs-heading-anchor-permalink" href="#Exports" title="Permalink"></a></h2><pre><code class="nohighlight hljs"># Connection
Neo4jConnection, connect, connect_from_env, dotenv

# Auth
AbstractAuth, BasicAuth, BearerAuth

# Query
query, @cypher_str, CypherQuery

# Transactions
Transaction, begin_transaction, commit!, rollback!, transaction

# Streaming
stream, StreamingResult, summary

# Result types
QueryResult, QueryCounters, Notification

# Graph types
Node, Relationship, Path, CypherPoint, CypherDuration, CypherVector

# Errors
Neo4jError, AuthenticationError, Neo4jQueryError, TransactionExpiredError

# DSL — Schema
PropertyDef, NodeSchema, RelSchema, @node, @rel
get_node_schema, get_rel_schema
validate_node_properties, validate_rel_properties

# DSL — Macros
@cypher, @create, @merge, @relate</code></pre><hr/><h2 id="Connection"><a class="docs-heading-anchor" href="#Connection">Connection</a><a id="Connection-1"></a><a class="docs-heading-anchor-permalink" href="#Connection" title="Permalink"></a></h2><h3 id="connect"><a class="docs-heading-anchor" href="#connect"><code>connect</code></a><a id="connect-1"></a><a class="docs-heading-anchor-permalink" href="#connect" title="Permalink"></a></h3><pre><code class="language-julia hljs">conn = connect(&quot;localhost&quot;, &quot;neo4j&quot;; port=7474, auth=BasicAuth(&quot;neo4j&quot;, &quot;password&quot;), scheme=&quot;http&quot;)</code></pre><table><tr><th style="text-align: right">Param</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>host</code></td><td style="text-align: right"><code>String</code></td><td style="text-align: right">required</td><td style="text-align: right">Hostname or IP</td></tr><tr><td style="text-align: right"><code>database</code></td><td style="text-align: right"><code>String</code></td><td style="text-align: right">required</td><td style="text-align: right">Database name</td></tr><tr><td style="text-align: right"><code>port</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>7474</code></td><td style="text-align: right">HTTP port</td></tr><tr><td style="text-align: right"><code>auth</code></td><td style="text-align: right"><code>AbstractAuth</code></td><td style="text-align: right">required</td><td style="text-align: right">Auth strategy</td></tr><tr><td style="text-align: right"><code>scheme</code></td><td style="text-align: right"><code>String</code></td><td style="text-align: right"><code>&quot;http&quot;</code></td><td style="text-align: right"><code>&quot;http&quot;</code> or <code>&quot;https&quot;</code></td></tr></table><p>Hits <code>GET /</code> discovery endpoint on construction; throws on failure.</p><h3 id="connect_from_env"><a class="docs-heading-anchor" href="#connect_from_env"><code>connect_from_env</code></a><a id="connect_from_env-1"></a><a class="docs-heading-anchor-permalink" href="#connect_from_env" title="Permalink"></a></h3><pre><code class="language-julia hljs">conn = connect_from_env(; path=&quot;.env&quot;, prefix=&quot;NEO4J_&quot;)</code></pre><p>Reads from env vars (optionally from <code>.env</code> file first):</p><table><tr><th style="text-align: right">Variable</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>NEO4J_URI</code></td><td style="text-align: right"><code>neo4j+s://host</code>, <code>bolt://host</code>, etc</td></tr><tr><td style="text-align: right"><code>NEO4J_USERNAME</code></td><td style="text-align: right">Username</td></tr><tr><td style="text-align: right"><code>NEO4J_PASSWORD</code></td><td style="text-align: right">Password</td></tr><tr><td style="text-align: right"><code>NEO4J_DATABASE</code></td><td style="text-align: right">Database name (default: <code>&quot;neo4j&quot;</code>)</td></tr></table><p>URI scheme mapping:</p><ul><li><code>neo4j+s://</code>, <code>neo4j+ssc://</code>, <code>bolt+s://</code>, <code>bolt+ssc://</code>, <code>https://</code> → HTTPS, port 443</li><li><code>neo4j://</code>, <code>bolt://</code>, <code>http://</code> → HTTP, port 7474</li></ul><h3 id="dotenv"><a class="docs-heading-anchor" href="#dotenv"><code>dotenv</code></a><a id="dotenv-1"></a><a class="docs-heading-anchor-permalink" href="#dotenv" title="Permalink"></a></h3><pre><code class="language-julia hljs">vars = dotenv(&quot;.env&quot;; overwrite=false)</code></pre><p>Loads <code>.env</code> into <code>ENV</code>. Supports <code>#</code> comments, quoted values, <code>export</code> prefix. Existing keys preserved unless <code>overwrite=true</code>.</p><hr/><h2 id="Authentication"><a class="docs-heading-anchor" href="#Authentication">Authentication</a><a id="Authentication-1"></a><a class="docs-heading-anchor-permalink" href="#Authentication" title="Permalink"></a></h2><pre><code class="language-julia hljs">auth = BasicAuth(&quot;neo4j&quot;, &quot;password&quot;)   # HTTP Basic (RFC 7617)
auth = BearerAuth(&quot;eyJhbG...&quot;)          # Bearer token</code></pre><p>Custom auth: subtype <code>AbstractAuth</code>, implement <code>auth_header(::YourAuth) -&gt; Pair{String,String}</code>.</p><pre><code class="language-julia hljs">struct ApiKeyAuth &lt;: Neo4jQuery.AbstractAuth
    key::String
end
Neo4jQuery.auth_header(a::ApiKeyAuth) = &quot;ApiKey $(a.key)&quot;</code></pre><hr/><h2 id="Query"><a class="docs-heading-anchor" href="#Query">Query</a><a id="Query-1"></a><a class="docs-heading-anchor-permalink" href="#Query" title="Permalink"></a></h2><h3 id="Basic-query"><a class="docs-heading-anchor" href="#Basic-query">Basic query</a><a id="Basic-query-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-query" title="Permalink"></a></h3><pre><code class="language-julia hljs">result = query(conn, &quot;MATCH (p:Person) RETURN p.name AS name, p.age AS age&quot;)</code></pre><h3 id="With-parameters-(always-use-for-user-input)"><a class="docs-heading-anchor" href="#With-parameters-(always-use-for-user-input)">With parameters (always use for user input)</a><a id="With-parameters-(always-use-for-user-input)-1"></a><a class="docs-heading-anchor-permalink" href="#With-parameters-(always-use-for-user-input)" title="Permalink"></a></h3><pre><code class="language-julia hljs">result = query(conn,
    &quot;MATCH (p:Person {name: \$name}) RETURN p&quot;,
    parameters=Dict{String,Any}(&quot;name&quot; =&gt; &quot;Alice&quot;))</code></pre><h3 id="@cypher_str-macro-(preferred)"><a class="docs-heading-anchor" href="#@cypher_str-macro-(preferred)"><code>@cypher_str</code> macro (preferred)</a><a id="@cypher_str-macro-(preferred)-1"></a><a class="docs-heading-anchor-permalink" href="#@cypher_str-macro-(preferred)" title="Permalink"></a></h3><p>Captures <code>$var</code> references from local scope as safe parameters:</p><pre><code class="language-julia hljs">name = &quot;Alice&quot;
age = 30
q = cypher&quot;MATCH (p:Person {name: $name, age: $age}) RETURN p&quot;
# q.statement == &quot;MATCH (p:Person {name: $name, age: $age}) RETURN p&quot;
# q.parameters == Dict(&quot;name&quot; =&gt; &quot;Alice&quot;, &quot;age&quot; =&gt; 30)
result = query(conn, q)</code></pre><h3 id="Query-options"><a class="docs-heading-anchor" href="#Query-options">Query options</a><a id="Query-options-1"></a><a class="docs-heading-anchor-permalink" href="#Query-options" title="Permalink"></a></h3><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>parameters</code></td><td style="text-align: right"><code>Dict{String,Any}</code></td><td style="text-align: right"><code>Dict()</code></td><td style="text-align: right">Query parameters</td></tr><tr><td style="text-align: right"><code>access_mode</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:write</code></td><td style="text-align: right"><code>:read</code> or <code>:write</code></td></tr><tr><td style="text-align: right"><code>include_counters</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right"><code>false</code></td><td style="text-align: right">Include mutation statistics</td></tr><tr><td style="text-align: right"><code>bookmarks</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right"><code>String[]</code></td><td style="text-align: right">Causal consistency bookmarks</td></tr><tr><td style="text-align: right"><code>impersonated_user</code></td><td style="text-align: right"><code>Union{String,Nothing}</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Impersonate another user</td></tr></table><hr/><h2 id="QueryResult"><a class="docs-heading-anchor" href="#QueryResult">QueryResult</a><a id="QueryResult-1"></a><a class="docs-heading-anchor-permalink" href="#QueryResult" title="Permalink"></a></h2><p>Returned by <code>query()</code>. Each row is a <code>NamedTuple</code> with keys matching query field names.</p><pre><code class="language-julia hljs">result = query(conn, &quot;MATCH (p:Person) RETURN p.name AS name, p.age AS age&quot;)

result[1]           # first row NamedTuple: (name = &quot;Alice&quot;, age = 30)
result[1].name      # &quot;Alice&quot;
result.fields       # [&quot;name&quot;, &quot;age&quot;]
length(result)      # number of rows
isempty(result)     # Bool

for row in result
    println(row.name, &quot; — &quot;, row.age)
end

names = [row.name for row in result]</code></pre><h3 id="Counters"><a class="docs-heading-anchor" href="#Counters">Counters</a><a id="Counters-1"></a><a class="docs-heading-anchor-permalink" href="#Counters" title="Permalink"></a></h3><pre><code class="language-julia hljs">result = query(conn, &quot;CREATE (n:Test) RETURN n&quot;; include_counters=true)
c = result.counters
# Fields: nodes_created, nodes_deleted, relationships_created, relationships_deleted,
#         properties_set, labels_added, labels_removed, indexes_added, indexes_removed,
#         constraints_added, constraints_removed, contains_updates, contains_system_updates, system_updates</code></pre><h3 id="Bookmarks"><a class="docs-heading-anchor" href="#Bookmarks">Bookmarks</a><a id="Bookmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Bookmarks" title="Permalink"></a></h3><pre><code class="language-julia hljs">r1 = query(conn, &quot;CREATE (n:Test)&quot;)
r2 = query(conn, &quot;MATCH (n:Test) RETURN n&quot;; bookmarks=r1.bookmarks)</code></pre><h3 id="Notifications"><a class="docs-heading-anchor" href="#Notifications">Notifications</a><a id="Notifications-1"></a><a class="docs-heading-anchor-permalink" href="#Notifications" title="Permalink"></a></h3><pre><code class="language-julia hljs">result.notifications  # Vector{Notification} — performance warnings, deprecation hints
# Each has: code, title, description, severity, category, position</code></pre><hr/><h2 id="Graph-Types"><a class="docs-heading-anchor" href="#Graph-Types">Graph Types</a><a id="Graph-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Types" title="Permalink"></a></h2><h3 id="Node"><a class="docs-heading-anchor" href="#Node">Node</a><a id="Node-1"></a><a class="docs-heading-anchor-permalink" href="#Node" title="Permalink"></a></h3><pre><code class="language-julia hljs">node.element_id         # String
node.labels             # Vector{String}
node.properties         # JSON.Object{String,Any}
node[&quot;name&quot;]            # property access (indexing)
node.name               # property access (dot syntax)</code></pre><h3 id="Relationship"><a class="docs-heading-anchor" href="#Relationship">Relationship</a><a id="Relationship-1"></a><a class="docs-heading-anchor-permalink" href="#Relationship" title="Permalink"></a></h3><pre><code class="language-julia hljs">rel.element_id                # String
rel.start_node_element_id     # String
rel.end_node_element_id       # String
rel.type                      # String (e.g. &quot;KNOWS&quot;)
rel[&quot;since&quot;]                  # property access
rel.since                     # dot syntax</code></pre><h3 id="Path"><a class="docs-heading-anchor" href="#Path">Path</a><a id="Path-1"></a><a class="docs-heading-anchor-permalink" href="#Path" title="Permalink"></a></h3><pre><code class="language-julia hljs">path.elements   # Vector{Union{Node, Relationship}} — alternating node/rel sequence</code></pre><h3 id="CypherPoint"><a class="docs-heading-anchor" href="#CypherPoint">CypherPoint</a><a id="CypherPoint-1"></a><a class="docs-heading-anchor-permalink" href="#CypherPoint" title="Permalink"></a></h3><pre><code class="language-julia hljs">pt.srid          # Int (e.g. 4326 for WGS84)
pt.coordinates   # Vector{Float64}</code></pre><h3 id="CypherDuration"><a class="docs-heading-anchor" href="#CypherDuration">CypherDuration</a><a id="CypherDuration-1"></a><a class="docs-heading-anchor-permalink" href="#CypherDuration" title="Permalink"></a></h3><pre><code class="language-julia hljs">d.value   # String — ISO-8601 (e.g. &quot;P1Y2M3DT4H&quot;)</code></pre><h3 id="CypherVector"><a class="docs-heading-anchor" href="#CypherVector">CypherVector</a><a id="CypherVector-1"></a><a class="docs-heading-anchor-permalink" href="#CypherVector" title="Permalink"></a></h3><pre><code class="language-julia hljs">v.coordinates_type   # String
v.coordinates        # Vector{String}</code></pre><hr/><h2 id="Transactions"><a class="docs-heading-anchor" href="#Transactions">Transactions</a><a id="Transactions-1"></a><a class="docs-heading-anchor-permalink" href="#Transactions" title="Permalink"></a></h2><h3 id="Explicit"><a class="docs-heading-anchor" href="#Explicit">Explicit</a><a id="Explicit-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit" title="Permalink"></a></h3><pre><code class="language-julia hljs">tx = begin_transaction(conn)
query(tx, &quot;CREATE (n:Person {name: \$name})&quot;, parameters=Dict{String,Any}(&quot;name&quot; =&gt; &quot;Alice&quot;))
bookmarks = commit!(tx)</code></pre><pre><code class="language-julia hljs">tx = begin_transaction(conn)
query(tx, &quot;CREATE (n:Temp)&quot;)
rollback!(tx)   # discards all changes</code></pre><p>Optional initial/final statements:</p><pre><code class="language-julia hljs">tx = begin_transaction(conn; statement=&quot;CREATE (n:Init) RETURN n&quot;, parameters=Dict{String,Any}())
bookmarks = commit!(tx; statement=&quot;CREATE (n:Final) RETURN n&quot;, parameters=Dict{String,Any}())</code></pre><h3 id="Do-block-(recommended-—-auto-commit/rollback)"><a class="docs-heading-anchor" href="#Do-block-(recommended-—-auto-commit/rollback)">Do-block (recommended — auto-commit/rollback)</a><a id="Do-block-(recommended-—-auto-commit/rollback)-1"></a><a class="docs-heading-anchor-permalink" href="#Do-block-(recommended-—-auto-commit/rollback)" title="Permalink"></a></h3><pre><code class="language-julia hljs">transaction(conn) do tx
    query(tx, &quot;CREATE (a:Person {name: &#39;Alice&#39;})&quot;)
    query(tx, &quot;CREATE (b:Person {name: &#39;Bob&#39;})&quot;)
end  # auto-commits; auto-rolls-back on exception</code></pre><h3 id="Transaction-state"><a class="docs-heading-anchor" href="#Transaction-state">Transaction state</a><a id="Transaction-state-1"></a><a class="docs-heading-anchor-permalink" href="#Transaction-state" title="Permalink"></a></h3><pre><code class="language-julia hljs">tx.committed     # Bool
tx.rolled_back   # Bool
# Using committed/rolled-back tx throws an error</code></pre><hr/><h2 id="Streaming"><a class="docs-heading-anchor" href="#Streaming">Streaming</a><a id="Streaming-1"></a><a class="docs-heading-anchor-permalink" href="#Streaming" title="Permalink"></a></h2><p>Row-by-row iteration over JSONL responses; memory-efficient for large result sets.</p><pre><code class="language-julia hljs">sr = stream(conn, &quot;MATCH (p:Person) RETURN p.name AS name, p.age AS age&quot;)
for row in sr
    println(row.name)
end</code></pre><p>Same keyword arguments as <code>query</code>. Also works inside transactions:</p><pre><code class="language-julia hljs">tx = begin_transaction(conn)
sr = stream(tx, &quot;MATCH (p) RETURN p&quot;)
rows = collect(sr)
commit!(tx)</code></pre><h3 id="Summary-(after-consuming-stream)"><a class="docs-heading-anchor" href="#Summary-(after-consuming-stream)">Summary (after consuming stream)</a><a id="Summary-(after-consuming-stream)-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-(after-consuming-stream)" title="Permalink"></a></h3><pre><code class="language-julia hljs">import Neo4jQuery: summary   # required — Base.summary takes precedence
s = summary(sr)
# s.bookmarks, s.counters, s.notifications, s.transaction, s.query_plan, s.profiled_query_plan</code></pre><hr/><h2 id="Errors"><a class="docs-heading-anchor" href="#Errors">Errors</a><a id="Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Errors" title="Permalink"></a></h2><table><tr><th style="text-align: right">Type</th><th style="text-align: right">Trigger</th></tr><tr><td style="text-align: right"><code>AuthenticationError</code></td><td style="text-align: right">HTTP 401 (bad credentials)</td></tr><tr><td style="text-align: right"><code>Neo4jQueryError</code></td><td style="text-align: right">Cypher syntax errors, constraint violations, etc.</td></tr><tr><td style="text-align: right"><code>TransactionExpiredError</code></td><td style="text-align: right">Transaction expired or rolled back server-side</td></tr></table><p>All subtype <code>Neo4jError &lt;: Exception</code>. Fields: <code>code::String</code>, <code>message::String</code> (except <code>TransactionExpiredError</code> which has only <code>message</code>).</p><hr/><h2 id="DSL-—-Schema-System"><a class="docs-heading-anchor" href="#DSL-—-Schema-System">DSL — Schema System</a><a id="DSL-—-Schema-System-1"></a><a class="docs-heading-anchor-permalink" href="#DSL-—-Schema-System" title="Permalink"></a></h2><h3 id="@node"><a class="docs-heading-anchor" href="#@node"><code>@node</code></a><a id="@node-1"></a><a class="docs-heading-anchor-permalink" href="#@node" title="Permalink"></a></h3><pre><code class="language-julia hljs">@node Person begin
    name::String        # required
    age::Int            # required
    email::String = &quot;&quot;  # optional, default &quot;&quot;
end</code></pre><p>Creates a <code>NodeSchema</code> constant and registers it globally. Label-only: <code>@node Marker</code>.</p><h3 id="@rel"><a class="docs-heading-anchor" href="#@rel"><code>@rel</code></a><a id="@rel-1"></a><a class="docs-heading-anchor-permalink" href="#@rel" title="Permalink"></a></h3><pre><code class="language-julia hljs">@rel KNOWS begin
    since::Int
    weight::Float64 = 1.0
end</code></pre><p>Creates a <code>RelSchema</code> constant. Label-only: <code>@rel LINKS</code>.</p><h3 id="Lookup-and-validation"><a class="docs-heading-anchor" href="#Lookup-and-validation">Lookup and validation</a><a id="Lookup-and-validation-1"></a><a class="docs-heading-anchor-permalink" href="#Lookup-and-validation" title="Permalink"></a></h3><pre><code class="language-julia hljs">get_node_schema(:Person)   # NodeSchema or nothing
get_rel_schema(:KNOWS)     # RelSchema or nothing

validate_node_properties(schema, Dict{String,Any}(&quot;name&quot; =&gt; &quot;Alice&quot;, &quot;age&quot; =&gt; 30))
# Throws on missing required props; warns on unknown props. No type-checking.</code></pre><hr/><h2 id="DSL-—-Standalone-Mutation-Macros"><a class="docs-heading-anchor" href="#DSL-—-Standalone-Mutation-Macros">DSL — Standalone Mutation Macros</a><a id="DSL-—-Standalone-Mutation-Macros-1"></a><a class="docs-heading-anchor-permalink" href="#DSL-—-Standalone-Mutation-Macros" title="Permalink"></a></h2><h3 id="@create-—-create-a-node"><a class="docs-heading-anchor" href="#@create-—-create-a-node"><code>@create</code> — create a node</a><a id="@create-—-create-a-node-1"></a><a class="docs-heading-anchor-permalink" href="#@create-—-create-a-node" title="Permalink"></a></h3><pre><code class="language-julia hljs">node = @create conn Person(name=&quot;Alice&quot;, age=30)
# Returns: Node</code></pre><p>Validates against registered schema if present.</p><h3 id="@merge-—-upsert-a-node"><a class="docs-heading-anchor" href="#@merge-—-upsert-a-node"><code>@merge</code> — upsert a node</a><a id="@merge-—-upsert-a-node-1"></a><a class="docs-heading-anchor-permalink" href="#@merge-—-upsert-a-node" title="Permalink"></a></h3><pre><code class="language-julia hljs">node = @merge conn Person(name=&quot;Alice&quot;) on_create(age=30) on_match(last_seen=&quot;2025-02-15&quot;)
node = @merge conn Person(name=&quot;Alice&quot;, age=30)   # simple merge</code></pre><h3 id="@relate-—-create-a-relationship"><a class="docs-heading-anchor" href="#@relate-—-create-a-relationship"><code>@relate</code> — create a relationship</a><a id="@relate-—-create-a-relationship-1"></a><a class="docs-heading-anchor-permalink" href="#@relate-—-create-a-relationship" title="Permalink"></a></h3><pre><code class="language-julia hljs">alice = @create conn Person(name=&quot;Alice&quot;, age=30)
bob = @create conn Person(name=&quot;Bob&quot;, age=25)
rel = @relate conn alice =&gt; KNOWS(since=2024) =&gt; bob
# Returns: Relationship
# Matches nodes by elementId()</code></pre><hr/><h2 id="DSL-—-@cypher-Macro-(Unified-Query-Builder)"><a class="docs-heading-anchor" href="#DSL-—-@cypher-Macro-(Unified-Query-Builder)">DSL — <code>@cypher</code> Macro (Unified Query Builder)</a><a id="DSL-—-@cypher-Macro-(Unified-Query-Builder)-1"></a><a class="docs-heading-anchor-permalink" href="#DSL-—-@cypher-Macro-(Unified-Query-Builder)" title="Permalink"></a></h2><p>Compiles a Julia block into parameterised Cypher <strong>at macro expansion time</strong>. Only <code>$param</code> values are captured at runtime.</p><h3 id="Invocation-forms"><a class="docs-heading-anchor" href="#Invocation-forms">Invocation forms</a><a id="Invocation-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Invocation-forms" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Block form
result = @cypher conn begin
    p::Person &gt;&gt; r::KNOWS &gt;&gt; q::Person
    where(p.age &gt; $min_age)
    ret(p.name =&gt; :name, r.since)
    order(p.age, :desc)
    take(10)
end

# With keyword arguments
result = @cypher conn begin
    p::Person
    ret(p)
end include_counters=true access_mode=:write

# Comprehension form
result = @cypher conn [p.name for p in Person if p.age &gt; 25]
result = @cypher conn [(p.name, p.age) for p in Person]
result = @cypher conn [p.name =&gt; :n for p in Person]
result = @cypher conn [p for p in Person]</code></pre><h3 id="access_mode-auto-inference"><a class="docs-heading-anchor" href="#access_mode-auto-inference">access_mode auto-inference</a><a id="access_mode-auto-inference-1"></a><a class="docs-heading-anchor-permalink" href="#access_mode-auto-inference" title="Permalink"></a></h3><p><code>@cypher</code> automatically sets <code>access_mode=:read</code> for pure reads and <code>:write</code> when any mutation clause is present. Explicit kwarg overrides.</p><hr/><h3 id="Pattern-Syntax"><a class="docs-heading-anchor" href="#Pattern-Syntax">Pattern Syntax</a><a id="Pattern-Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Pattern-Syntax" title="Permalink"></a></h3><h4 id="chain-(recommended)"><a class="docs-heading-anchor" href="#chain-(recommended)"><code>&gt;&gt;</code> chain (recommended)</a><a id="chain-(recommended)-1"></a><a class="docs-heading-anchor-permalink" href="#chain-(recommended)" title="Permalink"></a></h4><pre><code class="language-julia hljs">p::Person                                   # (p:Person)
::Person                                    # (:Person)
p::Person &gt;&gt; r::KNOWS &gt;&gt; q::Person          # (p:Person)-[r:KNOWS]-&gt;(q:Person)
p::Person &gt;&gt; KNOWS &gt;&gt; q::Person             # (p:Person)-[:KNOWS]-&gt;(q:Person)
p::Person &lt;&lt; r::KNOWS &lt;&lt; q::Person          # (p:Person)&lt;-[r:KNOWS]-(q:Person)
a::A &gt;&gt; R1 &gt;&gt; b::B &gt;&gt; R2 &gt;&gt; c::C            # (a:A)-[:R1]-&gt;(b:B)-[:R2]-&gt;(c:C)</code></pre><h4 id="Arrow-syntax-(also-supported)"><a class="docs-heading-anchor" href="#Arrow-syntax-(also-supported)">Arrow syntax (also supported)</a><a id="Arrow-syntax-(also-supported)-1"></a><a class="docs-heading-anchor-permalink" href="#Arrow-syntax-(also-supported)" title="Permalink"></a></h4><pre><code class="language-julia hljs">(p:Person)-[r:KNOWS]-&gt;(q:Person)            # right arrow
(a:Person)&lt;-[r:KNOWS]-(b:Person)            # left arrow
(a:Person)-[r:KNOWS]-(b:Person)             # undirected
(a:Person)-[r:KNOWS, 1, 3]-&gt;(b:Person)      # variable-length *1..3
(a) --&gt; (b)                                 # simple right arrow
(a) &lt;-- (b)                                 # simple left arrow</code></pre><p>Bare patterns in a block are implicit MATCH clauses.</p><hr/><h3 id="Clause-Functions"><a class="docs-heading-anchor" href="#Clause-Functions">Clause Functions</a><a id="Clause-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Clause-Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">DSL</th><th style="text-align: right">Cypher</th></tr><tr><td style="text-align: right"><code>where(cond1, cond2)</code></td><td style="text-align: right"><code>WHERE cond1 AND cond2</code></td></tr><tr><td style="text-align: right"><code>ret(expr =&gt; :alias, ...)</code></td><td style="text-align: right"><code>RETURN expr AS alias, ...</code></td></tr><tr><td style="text-align: right"><code>returning(expr =&gt; :alias)</code></td><td style="text-align: right"><code>RETURN expr AS alias</code> (synonym)</td></tr><tr><td style="text-align: right"><code>ret(distinct, expr)</code></td><td style="text-align: right"><code>RETURN DISTINCT expr</code></td></tr><tr><td style="text-align: right"><code>order(expr, :desc)</code></td><td style="text-align: right"><code>ORDER BY expr DESC</code></td></tr><tr><td style="text-align: right"><code>take(n)</code> / <code>skip(n)</code></td><td style="text-align: right"><code>LIMIT n</code> / <code>SKIP n</code></td></tr><tr><td style="text-align: right"><code>match(p1, p2)</code></td><td style="text-align: right"><code>MATCH p1, p2</code></td></tr><tr><td style="text-align: right"><code>optional(pattern)</code></td><td style="text-align: right"><code>OPTIONAL MATCH pattern</code></td></tr><tr><td style="text-align: right"><code>create(pattern)</code></td><td style="text-align: right"><code>CREATE pattern</code></td></tr><tr><td style="text-align: right"><code>merge(pattern)</code></td><td style="text-align: right"><code>MERGE pattern</code></td></tr><tr><td style="text-align: right"><code>with(expr =&gt; :alias, ...)</code></td><td style="text-align: right"><code>WITH expr AS alias, ...</code></td></tr><tr><td style="text-align: right"><code>unwind($list =&gt; :var)</code></td><td style="text-align: right"><code>UNWIND $list AS var</code></td></tr><tr><td style="text-align: right"><code>delete(vars...)</code></td><td style="text-align: right"><code>DELETE vars</code></td></tr><tr><td style="text-align: right"><code>detach_delete(vars...)</code></td><td style="text-align: right"><code>DETACH DELETE vars</code></td></tr><tr><td style="text-align: right"><code>on_create(p.prop = val)</code></td><td style="text-align: right"><code>ON CREATE SET p.prop = val</code></td></tr><tr><td style="text-align: right"><code>on_match(p.prop = val)</code></td><td style="text-align: right"><code>ON MATCH SET p.prop = val</code></td></tr><tr><td style="text-align: right"><code>remove(p.prop)</code></td><td style="text-align: right"><code>REMOVE p.prop</code></td></tr><tr><td style="text-align: right"><code>p.prop = $val</code> (assignment)</td><td style="text-align: right"><code>SET p.prop = $val</code></td></tr><tr><td style="text-align: right"><code>union()</code></td><td style="text-align: right"><code>UNION</code></td></tr><tr><td style="text-align: right"><code>union_all()</code></td><td style="text-align: right"><code>UNION ALL</code></td></tr><tr><td style="text-align: right"><code>call(begin ... end)</code></td><td style="text-align: right"><code>CALL { ... }</code> subquery</td></tr><tr><td style="text-align: right"><code>load_csv(url =&gt; :row)</code></td><td style="text-align: right"><code>LOAD CSV FROM url AS row</code></td></tr><tr><td style="text-align: right"><code>load_csv_headers(url =&gt; :row)</code></td><td style="text-align: right"><code>LOAD CSV WITH HEADERS FROM url AS row</code></td></tr><tr><td style="text-align: right"><code>foreach(var, :in, expr, begin ... end)</code></td><td style="text-align: right"><code>FOREACH (var IN expr | ...)</code></td></tr><tr><td style="text-align: right"><code>create_index(:Label, :prop)</code></td><td style="text-align: right"><code>CREATE INDEX FOR (n:Label) ON (n.prop)</code></td></tr><tr><td style="text-align: right"><code>create_index(:Label, :prop, :name)</code></td><td style="text-align: right">named index</td></tr><tr><td style="text-align: right"><code>drop_index(:name)</code></td><td style="text-align: right"><code>DROP INDEX name IF EXISTS</code></td></tr><tr><td style="text-align: right"><code>create_constraint(:Label, :prop, :unique)</code></td><td style="text-align: right">uniqueness constraint</td></tr><tr><td style="text-align: right"><code>create_constraint(:Label, :prop, :not_null, :name)</code></td><td style="text-align: right">NOT NULL constraint (named)</td></tr><tr><td style="text-align: right"><code>drop_constraint(:name)</code></td><td style="text-align: right"><code>DROP CONSTRAINT name IF EXISTS</code></td></tr></table><hr/><h3 id="WHERE-Operator-Mapping"><a class="docs-heading-anchor" href="#WHERE-Operator-Mapping">WHERE Operator Mapping</a><a id="WHERE-Operator-Mapping-1"></a><a class="docs-heading-anchor-permalink" href="#WHERE-Operator-Mapping" title="Permalink"></a></h3><table><tr><th style="text-align: right">Julia</th><th style="text-align: right">Cypher</th></tr><tr><td style="text-align: right"><code>==</code></td><td style="text-align: right"><code>=</code></td></tr><tr><td style="text-align: right"><code>!=</code></td><td style="text-align: right"><code>&lt;&gt;</code></td></tr><tr><td style="text-align: right"><code>&amp;&amp;</code></td><td style="text-align: right"><code>AND</code></td></tr><tr><td style="text-align: right"><code>||</code></td><td style="text-align: right"><code>OR</code></td></tr><tr><td style="text-align: right"><code>!</code></td><td style="text-align: right"><code>NOT</code></td></tr><tr><td style="text-align: right"><code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code></td><td style="text-align: right">same</td></tr><tr><td style="text-align: right"><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code></td><td style="text-align: right">same (arithmetic)</td></tr><tr><td style="text-align: right"><code>startswith(p.name, &quot;A&quot;)</code></td><td style="text-align: right"><code>p.name STARTS WITH &#39;A&#39;</code></td></tr><tr><td style="text-align: right"><code>endswith(p.name, &quot;e&quot;)</code></td><td style="text-align: right"><code>p.name ENDS WITH &#39;e&#39;</code></td></tr><tr><td style="text-align: right"><code>contains(p.name, &quot;li&quot;)</code></td><td style="text-align: right"><code>p.name CONTAINS &#39;li&#39;</code></td></tr><tr><td style="text-align: right"><code>in(p.name, $list)</code></td><td style="text-align: right"><code>p.name IN $list</code></td></tr><tr><td style="text-align: right"><code>isnothing(p.email)</code></td><td style="text-align: right"><code>p.email IS NULL</code></td></tr><tr><td style="text-align: right"><code>matches(p.name, &quot;^A.*&quot;)</code></td><td style="text-align: right"><code>p.name =~ &#39;^A.*&#39;</code></td></tr><tr><td style="text-align: right"><code>exists((p)-[:R]-&gt;(q))</code></td><td style="text-align: right"><code>EXISTS { MATCH (p)-[:R]-&gt;(q) }</code></td></tr><tr><td style="text-align: right"><code>if/elseif/else/end</code></td><td style="text-align: right"><code>CASE WHEN ... THEN ... ELSE ... END</code></td></tr></table><p>Multi-condition <code>where()</code> auto-ANDs: <code>where(a, b, c)</code> → <code>WHERE a AND b AND c</code>.</p><hr/><h3 id="Parameter-Capture"><a class="docs-heading-anchor" href="#Parameter-Capture">Parameter Capture</a><a id="Parameter-Capture-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Capture" title="Permalink"></a></h3><p><code>$var</code> captures Julia variables as safe Cypher parameters. Works in <code>where()</code>, property assignments, <code>unwind()</code>, <code>skip()</code>, <code>take()</code>, and any expression.</p><pre><code class="language-julia hljs">min_age = 25
result = @cypher conn begin
    p::Person
    where(p.age &gt; $min_age)
    ret(p.name)
end</code></pre><hr/><h3 id="Auto-SET"><a class="docs-heading-anchor" href="#Auto-SET">Auto-SET</a><a id="Auto-SET-1"></a><a class="docs-heading-anchor-permalink" href="#Auto-SET" title="Permalink"></a></h3><p>Property assignments become SET clauses; multiple merge into one:</p><pre><code class="language-julia hljs">@cypher conn begin
    p::Person
    where(p.name == $name)
    p.age = $new_age
    p.email = $new_email
    ret(p)
end
# → MATCH (p:Person) WHERE p.name = $name SET p.age = $new_age, p.email = $new_email RETURN p</code></pre><hr/><h3 id="Complete-Examples"><a class="docs-heading-anchor" href="#Complete-Examples">Complete Examples</a><a id="Complete-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Examples" title="Permalink"></a></h3><h4 id="Aggregation-with-WITH"><a class="docs-heading-anchor" href="#Aggregation-with-WITH">Aggregation with WITH</a><a id="Aggregation-with-WITH-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregation-with-WITH" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person &gt;&gt; r::KNOWS &gt;&gt; q::Person
    with(p, count(r) =&gt; :degree)
    where(degree &gt; $min_connections)
    order(degree, :desc)
    ret(p.name =&gt; :person, degree)
end</code></pre><h4 id="OPTIONAL-MATCH"><a class="docs-heading-anchor" href="#OPTIONAL-MATCH">OPTIONAL MATCH</a><a id="OPTIONAL-MATCH-1"></a><a class="docs-heading-anchor-permalink" href="#OPTIONAL-MATCH" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    optional(p &gt;&gt; w::WORKS_AT &gt;&gt; c::Company)
    ret(p.name =&gt; :person, c.name =&gt; :company)
end</code></pre><h4 id="Batch-with-UNWIND"><a class="docs-heading-anchor" href="#Batch-with-UNWIND">Batch with UNWIND</a><a id="Batch-with-UNWIND-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-with-UNWIND" title="Permalink"></a></h4><pre><code class="language-julia hljs">people = [Dict(&quot;name&quot; =&gt; &quot;Dave&quot;, &quot;age&quot; =&gt; 28), Dict(&quot;name&quot; =&gt; &quot;Eve&quot;, &quot;age&quot; =&gt; 22)]
result = @cypher conn begin
    unwind($people =&gt; :person)
    create((p:Person))
    p.name = person.name
    p.age = person.age
    ret(p)
end</code></pre><h4 id="UNION"><a class="docs-heading-anchor" href="#UNION">UNION</a><a id="UNION-1"></a><a class="docs-heading-anchor-permalink" href="#UNION" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    where(p.age &gt; 30)
    ret(p.name =&gt; :name)
    union()
    p::Person
    where(startswith(p.name, &quot;A&quot;))
    ret(p.name =&gt; :name)
end</code></pre><h4 id="CALL-subquery"><a class="docs-heading-anchor" href="#CALL-subquery">CALL subquery</a><a id="CALL-subquery-1"></a><a class="docs-heading-anchor-permalink" href="#CALL-subquery" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    call(begin
        with(p)
        p &gt;&gt; r::KNOWS &gt;&gt; friend::Person
        ret(count(friend) =&gt; :friend_count)
    end)
    ret(p.name =&gt; :name, friend_count)
end</code></pre><h4 id="FOREACH"><a class="docs-heading-anchor" href="#FOREACH">FOREACH</a><a id="FOREACH-1"></a><a class="docs-heading-anchor-permalink" href="#FOREACH" title="Permalink"></a></h4><pre><code class="language-julia hljs">names = [&quot;Alice&quot;, &quot;Bob&quot;]
@cypher conn begin
    p::Person
    where(in(p.name, $names))
    with(collect(p) =&gt; :people)
    foreach(people =&gt; :n, begin
        n.verified = true
    end)
end</code></pre><h4 id="MERGE-with-conditional-SET"><a class="docs-heading-anchor" href="#MERGE-with-conditional-SET">MERGE with conditional SET</a><a id="MERGE-with-conditional-SET-1"></a><a class="docs-heading-anchor-permalink" href="#MERGE-with-conditional-SET" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    merge((p:Person))
    on_create(p.created_at = $now)
    on_match(p.last_seen = $now)
    ret(p)
end</code></pre><h4 id="Delete"><a class="docs-heading-anchor" href="#Delete">Delete</a><a id="Delete-1"></a><a class="docs-heading-anchor-permalink" href="#Delete" title="Permalink"></a></h4><pre><code class="language-julia hljs">@cypher conn begin
    (p:Person)
    where(p.name == $target)
    detach_delete(p)
end</code></pre><h4 id="Pagination"><a class="docs-heading-anchor" href="#Pagination">Pagination</a><a id="Pagination-1"></a><a class="docs-heading-anchor-permalink" href="#Pagination" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    ret(p.name =&gt; :name)
    order(p.name)
    skip($offset)
    take($page_size)
end</code></pre><h4 id="Variable-length-paths"><a class="docs-heading-anchor" href="#Variable-length-paths">Variable-length paths</a><a id="Variable-length-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-length-paths" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    (a:Person)-[r:KNOWS, 1, 3]-&gt;(b:Person)
    ret(a.name =&gt; :start, b.name =&gt; :reachable)
end</code></pre><h4 id="CASE/WHEN"><a class="docs-heading-anchor" href="#CASE/WHEN">CASE/WHEN</a><a id="CASE/WHEN-1"></a><a class="docs-heading-anchor-permalink" href="#CASE/WHEN" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    ret(p.name =&gt; :name, if p.age &gt; 65; &quot;senior&quot;; elseif p.age &gt; 30; &quot;adult&quot;; else; &quot;young&quot;; end =&gt; :category)
end</code></pre><h4 id="EXISTS-subquery"><a class="docs-heading-anchor" href="#EXISTS-subquery">EXISTS subquery</a><a id="EXISTS-subquery-1"></a><a class="docs-heading-anchor-permalink" href="#EXISTS-subquery" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    where(exists((p)-[:KNOWS]-&gt;(:Person)))
    ret(p.name)
end</code></pre><h4 id="Regex-matching"><a class="docs-heading-anchor" href="#Regex-matching">Regex matching</a><a id="Regex-matching-1"></a><a class="docs-heading-anchor-permalink" href="#Regex-matching" title="Permalink"></a></h4><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    where(matches(p.name, &quot;^A.*e\$&quot;))
    ret(p.name)
end</code></pre><hr/><h2 id="DSL-Known-Limitations"><a class="docs-heading-anchor" href="#DSL-Known-Limitations">DSL Known Limitations</a><a id="DSL-Known-Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#DSL-Known-Limitations" title="Permalink"></a></h2><p>These Cypher features are <strong>not supported</strong> by the DSL:</p><ul><li>Inline property patterns in MATCH (<code>{name: $v}</code>) — Julia&#39;s parser cannot parse <code>{…}</code>; use <code>where()</code> instead</li><li><code>shortestPath</code> / <code>allShortestPaths</code></li><li>Procedure calls via <code>CALL db.xxx()</code> (distinct from CALL subqueries)</li><li>Map projections and list comprehensions (Cypher sense)</li></ul><hr/><h2 id="Type-Mapping-(Typed-JSON)"><a class="docs-heading-anchor" href="#Type-Mapping-(Typed-JSON)">Type Mapping (Typed JSON)</a><a id="Type-Mapping-(Typed-JSON)-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Mapping-(Typed-JSON)" title="Permalink"></a></h2><p>Neo4j Query API uses Typed JSON envelopes: <code>{&quot;$type&quot;: &quot;Integer&quot;, &quot;_value&quot;: &quot;42&quot;}</code>.</p><table><tr><th style="text-align: right">Neo4j Type</th><th style="text-align: right">Julia Type</th></tr><tr><td style="text-align: right"><code>Null</code></td><td style="text-align: right"><code>nothing</code></td></tr><tr><td style="text-align: right"><code>Boolean</code></td><td style="text-align: right"><code>Bool</code></td></tr><tr><td style="text-align: right"><code>Integer</code></td><td style="text-align: right"><code>Int64</code></td></tr><tr><td style="text-align: right"><code>Float</code></td><td style="text-align: right"><code>Float64</code></td></tr><tr><td style="text-align: right"><code>String</code></td><td style="text-align: right"><code>String</code></td></tr><tr><td style="text-align: right"><code>Base64</code></td><td style="text-align: right"><code>Vector{UInt8}</code></td></tr><tr><td style="text-align: right"><code>List</code></td><td style="text-align: right"><code>Vector</code></td></tr><tr><td style="text-align: right"><code>Map</code></td><td style="text-align: right"><code>JSON.Object</code></td></tr><tr><td style="text-align: right"><code>Date</code></td><td style="text-align: right"><code>Dates.Date</code></td></tr><tr><td style="text-align: right"><code>Time</code></td><td style="text-align: right"><code>Dates.Time</code></td></tr><tr><td style="text-align: right"><code>LocalTime</code></td><td style="text-align: right"><code>Dates.Time</code></td></tr><tr><td style="text-align: right"><code>OffsetDateTime</code></td><td style="text-align: right"><code>ZonedDateTime</code></td></tr><tr><td style="text-align: right"><code>LocalDateTime</code></td><td style="text-align: right"><code>DateTime</code></td></tr><tr><td style="text-align: right"><code>Duration</code></td><td style="text-align: right"><code>CypherDuration</code></td></tr><tr><td style="text-align: right"><code>Point</code></td><td style="text-align: right"><code>CypherPoint</code></td></tr><tr><td style="text-align: right"><code>Node</code></td><td style="text-align: right"><code>Node</code></td></tr><tr><td style="text-align: right"><code>Relationship</code></td><td style="text-align: right"><code>Relationship</code></td></tr><tr><td style="text-align: right"><code>Path</code></td><td style="text-align: right"><code>Path</code></td></tr><tr><td style="text-align: right"><code>Vector</code></td><td style="text-align: right"><code>CypherVector</code></td></tr></table><p>Julia→Neo4j serialization (<code>to_typed_json</code>): Julia values are wrapped in typed envelopes when sent as parameters.</p><hr/><h2 id="HTTP-Protocol-Details"><a class="docs-heading-anchor" href="#HTTP-Protocol-Details">HTTP Protocol Details</a><a id="HTTP-Protocol-Details-1"></a><a class="docs-heading-anchor-permalink" href="#HTTP-Protocol-Details" title="Permalink"></a></h2><ul><li>Content-Type: <code>application/vnd.neo4j.query.v1.1</code> (Typed JSON)</li><li>Streaming Accept: <code>application/vnd.neo4j.query.v1.1+jsonl</code> (JSONL)</li><li>Implicit query endpoint: <code>{base_url}/db/{database}/query/v2</code></li><li>Transaction endpoint: <code>{base_url}/db/{database}/query/v2/tx</code></li><li>Transaction operations: <code>POST .../tx</code> (begin), <code>POST .../tx/{id}</code> (query), <code>POST .../tx/{id}/commit</code>, <code>DELETE .../tx/{id}</code> (rollback)</li><li>Cluster affinity via <code>neo4j-cluster-affinity</code> header (Aura)</li></ul><hr/><h2 id="Source-File-Map"><a class="docs-heading-anchor" href="#Source-File-Map">Source File Map</a><a id="Source-File-Map-1"></a><a class="docs-heading-anchor-permalink" href="#Source-File-Map" title="Permalink"></a></h2><table><tr><th style="text-align: right">File</th><th style="text-align: right">Purpose</th></tr><tr><td style="text-align: right"><code>src/Neo4jQuery.jl</code></td><td style="text-align: right">Module definition, includes, exports</td></tr><tr><td style="text-align: right"><code>src/auth.jl</code></td><td style="text-align: right"><code>BasicAuth</code>, <code>BearerAuth</code>, <code>auth_header</code></td></tr><tr><td style="text-align: right"><code>src/connection.jl</code></td><td style="text-align: right"><code>Neo4jConnection</code>, <code>connect</code>, discovery</td></tr><tr><td style="text-align: right"><code>src/cypher_macro.jl</code></td><td style="text-align: right"><code>CypherQuery</code>, <code>@cypher_str</code></td></tr><tr><td style="text-align: right"><code>src/env.jl</code></td><td style="text-align: right"><code>dotenv</code>, <code>connect_from_env</code>, URI parsing</td></tr><tr><td style="text-align: right"><code>src/errors.jl</code></td><td style="text-align: right">Error types hierarchy</td></tr><tr><td style="text-align: right"><code>src/query.jl</code></td><td style="text-align: right"><code>query()</code> for connections and CypherQuery</td></tr><tr><td style="text-align: right"><code>src/request.jl</code></td><td style="text-align: right">HTTP helpers, error handling</td></tr><tr><td style="text-align: right"><code>src/result.jl</code></td><td style="text-align: right"><code>QueryResult</code>, <code>QueryCounters</code>, <code>Notification</code></td></tr><tr><td style="text-align: right"><code>src/streaming.jl</code></td><td style="text-align: right"><code>stream()</code>, <code>StreamingResult</code>, <code>summary</code></td></tr><tr><td style="text-align: right"><code>src/transactions.jl</code></td><td style="text-align: right"><code>Transaction</code>, <code>begin_transaction</code>, <code>commit!</code>, etc.</td></tr><tr><td style="text-align: right"><code>src/typed_json.jl</code></td><td style="text-align: right">Typed JSON (de)serialization</td></tr><tr><td style="text-align: right"><code>src/types.jl</code></td><td style="text-align: right"><code>Node</code>, <code>Relationship</code>, <code>Path</code>, spatial/temporal</td></tr><tr><td style="text-align: right"><code>src/dsl/schema.jl</code></td><td style="text-align: right"><code>@node</code>, <code>@rel</code>, <code>PropertyDef</code>, validation</td></tr><tr><td style="text-align: right"><code>src/dsl/compile.jl</code></td><td style="text-align: right">AST→Cypher compilation (macro expansion time)</td></tr><tr><td style="text-align: right"><code>src/dsl/mutations.jl</code></td><td style="text-align: right"><code>@create</code>, <code>@merge</code>, <code>@relate</code></td></tr><tr><td style="text-align: right"><code>src/dsl/cypher.jl</code></td><td style="text-align: right"><code>@cypher</code> macro (unified DSL)</td></tr></table></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 16 February 2026 14:30">Monday 16 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
