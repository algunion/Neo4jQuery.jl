var documenterSearchIndex = {"docs":
[{"location":"guide/transactions/#transactions","page":"Transactions","title":"Transactions","text":"Neo4jQuery supports both implicit (auto-commit) and explicit transactions.","category":"section"},{"location":"guide/transactions/#Explicit-transactions","page":"Transactions","title":"Explicit transactions","text":"Open a transaction, run multiple queries, then commit or rollback:\n\ntx = begin_transaction(conn)\n\nname = \"Savings\"\nquery(tx, cypher\"CREATE (a:Account {name: $name})\")\nname = \"Checking\"\nquery(tx, cypher\"CREATE (a:Account {name: $name})\")\n\nbookmarks = commit!(tx)\nprintln(\"Committed with \", length(bookmarks), \" bookmark(s)\")","category":"section"},{"location":"guide/transactions/#Rollback","page":"Transactions","title":"Rollback","text":"tx = begin_transaction(conn)\nquery(tx, \"CREATE (n:Temp)\")\nrollback!(tx)\nprintln(\"Rolled back — Temp node never persists\")","category":"section"},{"location":"guide/transactions/#Initial-statement","page":"Transactions","title":"Initial statement","text":"begin_transaction accepts an optional initial statement — either a String or a CypherQuery:\n\ntx = begin_transaction(conn;\n    statement=cypher\"CREATE (n:Init) RETURN n\")\ncommit!(tx)\nprintln(\"Transaction with initial statement committed\")","category":"section"},{"location":"guide/transactions/#Final-statement-on-commit","page":"Transactions","title":"Final statement on commit","text":"commit! can run a final statement atomically with the commit:\n\ntx = begin_transaction(conn)\nbookmarks = commit!(tx;\n    statement=cypher\"CREATE (n:Final) RETURN n\")\nprintln(\"Committed with final statement, \", length(bookmarks), \" bookmark(s)\")","category":"section"},{"location":"guide/transactions/#Using-@cypher_str-in-transactions","page":"Transactions","title":"Using @cypher_str in transactions","text":"The cypher\"\" macro is the recommended way to pass parameterised queries everywhere:\n\ntx = begin_transaction(conn)\n\nname = \"Alice\"\nage = 30\nresult = query(tx, cypher\"CREATE (p:Person {name: $name, age: $age}) RETURN p\")\nprintln(\"Created: \", result[1].p)\n\nname = \"Bob\"\nage = 25\nquery(tx, cypher\"CREATE (p:Person {name: $name, age: $age}) RETURN p\")\n\n# Create a relationship between them\nquery(tx, \"\"\"\n    MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n    CREATE (a)-[:KNOWS {since: 2024}]->(b)\n\"\"\")\n\nbookmarks = commit!(tx)\nprintln(\"Transaction committed\")","category":"section"},{"location":"guide/transactions/#Do-block-(recommended)","page":"Transactions","title":"Do-block (recommended)","text":"The safest pattern — auto-commits on success, auto-rolls-back on exception:\n\ntransaction(conn) do tx\n    query(tx, \"CREATE (a:Person {name: 'Diana'})\")\n    query(tx, \"CREATE (b:Person {name: 'Edgar'})\")\n    query(tx, \"\"\"\n        MATCH (a:Person {name: 'Diana'}), (b:Person {name: 'Edgar'})\n        CREATE (a)-[:KNOWS]->(b)\n    \"\"\")\nend\nprintln(\"Do-block transaction committed\")\n\nIf any exception occurs inside the block, the transaction is automatically rolled back before the exception propagates:\n\ntry\n    transaction(conn) do tx\n        query(tx, \"CREATE (n:Temp)\")\n        error(\"something went wrong\")\n    end\ncatch e\n    println(\"Caught: \", e.msg)\n    println(\"Transaction was rolled back — no :Temp node was created\")\nend","category":"section"},{"location":"guide/transactions/#Complete-example-using-do-block","page":"Transactions","title":"Complete example using do-block","text":"# Build a small graph atomically\ntransaction(conn) do tx\n    # Create people\n    for (n, a) in [(\"Fay\", 30), (\"George\", 25), (\"Helen\", 35)]\n        name = n\n        age = a\n        query(tx, cypher\"CREATE (p:Person {name: $name, age: $age})\")\n    end\n\n    # Create relationships\n    query(tx, \"\"\"\n        MATCH (a:Person {name: 'Fay'}), (b:Person {name: 'George'})\n        CREATE (a)-[:KNOWS {since: 2020}]->(b)\n    \"\"\")\n    query(tx, \"\"\"\n        MATCH (a:Person {name: 'Fay'}), (c:Person {name: 'Helen'})\n        CREATE (a)-[:KNOWS {since: 2022}]->(c)\n    \"\"\")\nend\nprintln(\"All operations committed together\")","category":"section"},{"location":"guide/transactions/#Transaction-state","page":"Transactions","title":"Transaction state","text":"The Transaction struct tracks its lifecycle:\n\ntx = begin_transaction(conn)\nprintln(\"Committed: \", tx.committed, \", Rolled back: \", tx.rolled_back)\n\ncommit!(tx)\nprintln(\"Committed: \", tx.committed)\n\nAttempting to use a committed or rolled-back transaction raises an error:\n\ntx = begin_transaction(conn)\ncommit!(tx)\n\n# This will throw an error:\ntry\n    query(tx, \"RETURN 1\")\ncatch e\n    println(\"Error: \", e)\nend","category":"section"},{"location":"api/#api-reference","page":"API Reference","title":"API Reference","text":"Full reference for all public types and functions.","category":"section"},{"location":"api/#Connection","page":"API Reference","title":"Connection","text":"","category":"section"},{"location":"api/#Authentication","page":"API Reference","title":"Authentication","text":"","category":"section"},{"location":"api/#Environment","page":"API Reference","title":"Environment","text":"","category":"section"},{"location":"api/#Query","page":"API Reference","title":"Query","text":"","category":"section"},{"location":"api/#Transactions","page":"API Reference","title":"Transactions","text":"","category":"section"},{"location":"api/#Streaming","page":"API Reference","title":"Streaming","text":"","category":"section"},{"location":"api/#Result-Types","page":"API Reference","title":"Result Types","text":"","category":"section"},{"location":"api/#Graph-Types","page":"API Reference","title":"Graph Types","text":"","category":"section"},{"location":"api/#Errors","page":"API Reference","title":"Errors","text":"","category":"section"},{"location":"api/#DSL-—-Schema","page":"API Reference","title":"DSL — Schema","text":"","category":"section"},{"location":"api/#DSL-—-Macros","page":"API Reference","title":"DSL — Macros","text":"","category":"section"},{"location":"api/#Neo4jQuery.Neo4jConnection","page":"API Reference","title":"Neo4jQuery.Neo4jConnection","text":"Neo4jConnection\n\nRepresents a connection to a Neo4j database via the Query API v2.\n\nCreate one with connect rather than calling the constructor directly.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.connect","page":"API Reference","title":"Neo4jQuery.connect","text":"connect(host, database; port=7474, auth, scheme=\"http\") -> Neo4jConnection\n\nEstablish a connection to a Neo4j instance.  Validates connectivity by hitting the discovery endpoint (GET /).\n\nExample\n\nconn = connect(\"localhost\", \"neo4j\"; auth=BasicAuth(\"neo4j\", \"password\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.connect_from_env","page":"API Reference","title":"Neo4jQuery.connect_from_env","text":"connect_from_env(; path=\".env\", prefix=\"NEO4J_\") -> Neo4jConnection\n\nConvenience constructor that loads credentials from environment variables (optionally reading a .env file first) and returns a ready-to-use connection.\n\nExpected variables (with default NEO4J_ prefix):\n\nNEO4J_URI      — full URI, e.g. neo4j+s://xxx.databases.neo4j.io\nNEO4J_USERNAME — e.g. neo4j\nNEO4J_PASSWORD — the password\nNEO4J_DATABASE — e.g. neo4j  (defaults to \"neo4j\" if unset)\n\nThe URI scheme is mapped automatically:\n\nneo4j+s://, neo4j+ssc:// → HTTPS (port 443)\nneo4j://, bolt:// → HTTP (port 7474)\n\nExample\n\nconn = connect_from_env()                    # reads .env, connects\nconn = connect_from_env(path=\"prod.env\")     # different file\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.AbstractAuth","page":"API Reference","title":"Neo4jQuery.AbstractAuth","text":"AbstractAuth\n\nAbstract type for authentication strategies used to authorize Neo4j requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.BasicAuth","page":"API Reference","title":"Neo4jQuery.BasicAuth","text":"BasicAuth(username::String, password::String)\n\nHTTP Basic authentication (RFC 7617).  Generates an Authorization: Basic … header from the supplied credentials.\n\nExample\n\nauth = BasicAuth(\"neo4j\", \"verysecret\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.BearerAuth","page":"API Reference","title":"Neo4jQuery.BearerAuth","text":"BearerAuth(token::String)\n\nHTTP Bearer-token authentication.  Generates an Authorization: Bearer … header from the supplied token.\n\nExample\n\nauth = BearerAuth(\"xbhkjnlvianztghqwawxqfe\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.dotenv","page":"API Reference","title":"Neo4jQuery.dotenv","text":"dotenv(path=\".env\"; overwrite=false) -> Dict{String,String}\n\nParse a .env file and load its key-value pairs into ENV. Returns the parsed dictionary.\n\nLines starting with # are treated as comments and ignored. Empty lines are skipped.  Values may optionally be quoted with \" or '.\n\nIf overwrite is false (default), existing ENV entries are not overwritten—the file values serve as defaults.\n\nExample\n\ndotenv()                        # loads .env from current directory\ndotenv(\"config/.env.test\")      # loads a specific file\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.query","page":"API Reference","title":"Neo4jQuery.query","text":"query(conn, statement; parameters, access_mode, include_counters, bookmarks, impersonated_user) -> QueryResult\n\nExecute a Cypher statement against the database using an implicit transaction.\n\nArguments\n\nconn::Neo4jConnection — the connection to use.\nstatement::String — the Cypher query text.  Use {{param}} placeholders for parameters (converted to $param for Neo4j), or the traditional \\$param escape if you prefer.\n\nKeyword Arguments\n\nparameters::Dict{String,Any}=Dict{String,Any}() — query parameters.\naccess_mode::Symbol=:write — :read or :write for cluster routing.\ninclude_counters::Bool=false — whether to request query counters.\nbookmarks::Vector{String}=String[] — bookmarks for causal consistency.\nimpersonated_user::Union{String,Nothing}=nothing — run as another user.\n\nExample\n\n# Recommended: Mustache-style placeholders (no escaping needed)\nresult = query(conn,\n    \"MATCH (p:Person) WHERE p.age > {{min_age}} RETURN p.name AS name\",\n    parameters=Dict{String,Any}(\"min_age\" => 25))\n\n# Also works: escaped $ (traditional Cypher style)\nresult = query(conn,\n    \"MATCH (p:Person) WHERE p.age > \\$min_age RETURN p.name AS name\",\n    parameters=Dict{String,Any}(\"min_age\" => 25))\n\n# Best: use the cypher\"\" string macro for automatic parameter capture\nmin_age = 25\nq = cypher\"MATCH (p:Person) WHERE p.age > $min_age RETURN p.name AS name\"\nresult = query(conn, q)\n\n\n\n\n\nquery(conn, q::CypherQuery; kwargs...) -> QueryResult\n\nExecute a CypherQuery (typically from the @cypher_str macro). Parameters from the CypherQuery are merged with any extra parameters kwarg (the kwarg takes precedence on conflicts).\n\n\n\n\n\nquery(tx::Transaction, statement; parameters, include_counters) -> QueryResult\n\nExecute a Cypher statement inside an open transaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.CypherQuery","page":"API Reference","title":"Neo4jQuery.CypherQuery","text":"CypherQuery\n\nA Cypher query statement together with its parameter bindings.  Typically constructed via the @cypher_str string macro.\n\nFields\n\nstatement::String — the Cypher text (with $param placeholders)\nparameters::Dict{String,Any} — parameter name → Julia value\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.@cypher_str","page":"API Reference","title":"Neo4jQuery.@cypher_str","text":"@cypher_str -> CypherQuery\n\nCreate a CypherQuery from a Cypher string literal, automatically capturing local variables referenced with $ as query parameters.\n\nJulia does not interpolate $ inside non-standard string literals, so the $ is passed through verbatim and the macro can detect it as a Cypher parameter reference.\n\nExample\n\nname = \"Alice\"\nage  = 42\nq = cypher\"MATCH (n:Person {name: $name, age: $age}) RETURN n\"\n# CypherQuery(\"MATCH (n:Person {name: $name, age: $age}) RETURN n\", 2 parameters)\n# q.parameters == Dict(\"name\" => \"Alice\", \"age\" => 42)\n\nThe resulting query uses parameterised Cypher, which is both safer (no injection) and faster (query plan caching).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.Transaction","page":"API Reference","title":"Neo4jQuery.Transaction","text":"Transaction\n\nAn explicit Neo4j transaction.  Obtain one via begin_transaction or the transaction do-block helper.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.begin_transaction","page":"API Reference","title":"Neo4jQuery.begin_transaction","text":"begin_transaction(conn; statement=nothing, parameters=Dict{String,Any}()) -> Transaction\n\nOpen a new explicit transaction, optionally executing an initial statement.\n\nThe statement keyword accepts a plain String, a CypherQuery (from cypher\"...\"), or nothing.\n\nExamples\n\ntx = begin_transaction(conn)\nresult = query(tx, cypher\"CREATE (n:Person {name: $name}) RETURN n\")\ncommit!(tx)\n\n# With an initial statement\nname = \"Alice\"\ntx = begin_transaction(conn; statement=cypher\"CREATE (n:Person {name: $name}) RETURN n\")\ncommit!(tx)\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.commit!","page":"API Reference","title":"Neo4jQuery.commit!","text":"commit!(tx; statement=nothing, parameters=Dict{String,Any}()) -> Vector{String}\n\nCommit an open transaction, optionally executing a final statement. Returns the bookmarks from the committed transaction.\n\nThe statement keyword accepts a plain String, a CypherQuery (from cypher\"...\"), or nothing.\n\nExample\n\ntx = begin_transaction(conn)\nbookmarks = commit!(tx; statement=cypher\"CREATE (n:Final) RETURN n\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.rollback!","page":"API Reference","title":"Neo4jQuery.rollback!","text":"rollback!(tx::Transaction) -> Nothing\n\nRoll back an open transaction, discarding all changes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.transaction","page":"API Reference","title":"Neo4jQuery.transaction","text":"transaction(f, conn; kwargs...) -> result\n\nExecute f(tx) inside an explicit transaction.  The transaction is committed if f returns normally, or rolled back if an exception is thrown.\n\nExample\n\ntransaction(conn) do tx\n    query(tx, \"CREATE (a:Person {name: 'Alice'})\")\n    query(tx, \"CREATE (b:Person {name: 'Bob'})\")\nend  # auto-commit\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.stream","page":"API Reference","title":"Neo4jQuery.stream","text":"stream(conn, statement; parameters, access_mode, bookmarks, impersonated_user) -> StreamingResult\n\nExecute a Cypher query with streaming enabled.  Returns a StreamingResult that yields NamedTuple rows via iteration.\n\nExample\n\nfor row in stream(conn, \"MATCH (n:Person) RETURN n.name AS name\")\n    println(row.name)\nend\n\n\n\n\n\nstream(tx::Transaction, statement; parameters) -> StreamingResult\n\nExecute a streaming query inside an existing explicit transaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.StreamingResult","page":"API Reference","title":"Neo4jQuery.StreamingResult","text":"StreamingResult\n\nAn in-progress streaming query result.  Implements Julia's iteration protocol so records can be consumed with a for loop:\n\nfor row in stream(conn, \"MATCH (n) RETURN n.name AS name\")\n    println(row.name)\nend\n\nAfter iteration completes (or is interrupted), call summary to retrieve bookmarks, counters, and notifications.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.summary","page":"API Reference","title":"Neo4jQuery.summary","text":"summary(sr::StreamingResult) -> NamedTuple\n\nAccess bookmarks, counters, notifications, and query plans after the stream has been consumed.  Returns a NamedTuple with keys:\n\nbookmarks::Vector{String}\ncounters::Union{QueryCounters, Nothing}\nnotifications::Vector{Notification}\ntransaction::Union{JSON.Object, Nothing}\nquery_plan::Union{JSON.Object, Nothing}\nprofiled_query_plan::Union{JSON.Object, Nothing}\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.QueryResult","page":"API Reference","title":"Neo4jQuery.QueryResult","text":"QueryResult\n\nThe result of a Cypher query.  Supports iteration and indexing—each row is a NamedTuple whose keys match the query's field names.\n\nIteration\n\nfor row in result\n    println(row.name, \" is \", row.age, \" years old\")\nend\n\nIndexing\n\nresult[1]          # first row as NamedTuple\nresult[end]        # last row\nlength(result)     # number of rows\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.QueryCounters","page":"API Reference","title":"Neo4jQuery.QueryCounters","text":"QueryCounters\n\nStatistics about database changes performed by a query.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Notification","page":"API Reference","title":"Neo4jQuery.Notification","text":"Notification\n\nA server notification (performance warning, deprecation hint, etc.) attached to a query response.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Node","page":"API Reference","title":"Neo4jQuery.Node","text":"Node\n\nA Neo4j graph node with an element ID, labels, and a property map.\n\nProperty access is supported via both indexing and dot syntax:\n\nnode[\"name\"]   # indexing\nnode.name      # dot syntax\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Relationship","page":"API Reference","title":"Neo4jQuery.Relationship","text":"Relationship\n\nA Neo4j graph relationship with an element ID, start/end node element IDs, a type string, and a property map.\n\nrel[\"since\"]   # indexing\nrel.since      # dot syntax\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Path","page":"API Reference","title":"Neo4jQuery.Path","text":"Path\n\nA Neo4j graph path—an alternating sequence of Node and Relationship objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherPoint","page":"API Reference","title":"Neo4jQuery.CypherPoint","text":"CypherPoint\n\nA Cypher spatial point value.  Stored as an SRID integer and a coordinate vector. Serialised on the wire as a WKT string, e.g. \"SRID=7203;POINT (1.2 3.4)\".\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherDuration","page":"API Reference","title":"Neo4jQuery.CypherDuration","text":"CypherDuration\n\nA Cypher duration value.  Stored as the original ISO-8601 string (e.g. \"P14DT16H12M\").\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherVector","page":"API Reference","title":"Neo4jQuery.CypherVector","text":"CypherVector\n\nA Neo4j vector value (Enterprise Edition).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Neo4jError","page":"API Reference","title":"Neo4jQuery.Neo4jError","text":"Neo4jError <: Exception\n\nAbstract base type for all Neo4j-related errors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.AuthenticationError","page":"API Reference","title":"Neo4jQuery.AuthenticationError","text":"AuthenticationError <: Neo4jError\n\nRaised when the server returns HTTP 401 (missing, incorrect, or invalid credentials).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Neo4jQueryError","page":"API Reference","title":"Neo4jQuery.Neo4jQueryError","text":"Neo4jQueryError <: Neo4jError\n\nRaised when the server response contains an errors array (query syntax errors, constraint violations, etc.).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.TransactionExpiredError","page":"API Reference","title":"Neo4jQuery.TransactionExpiredError","text":"TransactionExpiredError <: Neo4jError\n\nRaised when a request targets a transaction that has already expired or been rolled back on the server side.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.PropertyDef","page":"API Reference","title":"Neo4jQuery.PropertyDef","text":"PropertyDef\n\nA single property definition within a node or relationship schema.\n\nFields\n\nname::Symbol — property name\ntype::Symbol — Julia type name (e.g. :String, :Int)\nrequired::Bool — whether the property must be supplied on creation\ndefault — default value for optional properties, or nothing for required\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.NodeSchema","page":"API Reference","title":"Neo4jQuery.NodeSchema","text":"NodeSchema\n\nSchema descriptor for a Neo4j node label, created by the @node macro.\n\nFields\n\nlabel::Symbol — the Neo4j label (e.g. :Person)\nproperties::Vector{PropertyDef} — typed property definitions\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.RelSchema","page":"API Reference","title":"Neo4jQuery.RelSchema","text":"RelSchema\n\nSchema descriptor for a Neo4j relationship type, created by the @rel macro.\n\nFields\n\nreltype::Symbol — the relationship type (e.g. :KNOWS)\nproperties::Vector{PropertyDef} — typed property definitions\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.@node","page":"API Reference","title":"Neo4jQuery.@node","text":"@node Name begin\n    field::Type\n    optional_field::Type = default_value\nend\n\nDeclare a node schema with label Name and typed properties.\n\nCreates a constant Name::NodeSchema and registers it for runtime validation in @create and @merge operations.\n\nExample\n\n@node Person begin\n    name::String\n    age::Int\n    email::String = \"\"\nend\n\n# Person is now a NodeSchema constant\nPerson.label       # :Person\nPerson.properties  # [PropertyDef(:name, :String, true, nothing), ...]\n\n\n\n\n\n@node Name\n\nDeclare a node schema with no properties (label-only).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@rel","page":"API Reference","title":"Neo4jQuery.@rel","text":"@rel TYPE begin\n    field::Type\n    optional_field::Type = default_value\nend\n\nDeclare a relationship schema with type TYPE and typed properties.\n\nCreates a constant TYPE::RelSchema and registers it for runtime validation.\n\nExample\n\n@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\n\n\n\n\n@rel TYPE\n\nDeclare a relationship schema with no properties (type-only).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.get_node_schema","page":"API Reference","title":"Neo4jQuery.get_node_schema","text":"Look up a registered node schema by label, or return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.get_rel_schema","page":"API Reference","title":"Neo4jQuery.get_rel_schema","text":"Look up a registered relationship schema by type, or return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.validate_node_properties","page":"API Reference","title":"Neo4jQuery.validate_node_properties","text":"validate_node_properties(schema::NodeSchema, props::Dict{String,<:Any})\n\nValidate that props satisfies the schema's required properties. Warns on unknown properties not declared in the schema. Throws on missing required properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.validate_rel_properties","page":"API Reference","title":"Neo4jQuery.validate_rel_properties","text":"validate_rel_properties(schema::RelSchema, props::Dict{String,<:Any})\n\nValidate that props satisfies the schema's required properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.@cypher","page":"API Reference","title":"Neo4jQuery.@cypher","text":"@cypher conn begin ... end\n@cypher conn [comprehension]\n\nUnified graph query DSL that compiles Julia expressions to parameterized Cypher.\n\nCombines Julia-native ergonomics with full Cypher coverage.\n\nPattern Syntax\n\nThe >> chain is the primary pattern language. Arrow syntax also works.\n\nJulia Cypher\np::Person (p:Person)\n::Person (:Person)\np::Person >> r::KNOWS >> q::Person (p:Person)-[r:KNOWS]->(q:Person)\np::Person >> KNOWS >> q::Person (p:Person)-[:KNOWS]->(q:Person)\np::Person << r::KNOWS << q::Person (p:Person)<-[r:KNOWS]-(q:Person)\na::A >> R1 >> b::B >> R2 >> c::C (a:A)-[:R1]->(b:B)-[:R2]->(c:C)\n(p:Person)-[r:KNOWS]->(q:Person) (p:Person)-[r:KNOWS]->(q:Person)\n\nClause Functions\n\nClause Cypher\nwhere(cond1, cond2) WHERE cond1 AND cond2\nret(expr => :alias, ...) RETURN expr AS alias, ...\nret(distinct, expr) RETURN DISTINCT expr\nreturning(expr) RETURN expr (alias for ret)\norder(expr, :desc) ORDER BY expr DESC\ntake(n) / skip(n) LIMIT n / SKIP n\ncreate(pattern) / merge(pattern) CREATE / MERGE\noptional(pattern) OPTIONAL MATCH pattern\nmatch(p1, p2) MATCH p1, p2 (explicit multi)\nwith(expr => :alias, ...) WITH expr AS alias, ...\nunwind($list => :var) UNWIND $list AS var\ndelete(vars) / detach_delete(vars) DELETE / DETACH DELETE\non_create(p.prop = val) ON CREATE SET p.prop = val\non_match(p.prop = val) ON MATCH SET p.prop = val\np.prop = $val (assignment) SET p.prop = $val (auto-SET)\nremove(items) REMOVE items\nunion() / union_all() UNION / UNION ALL\ncall(begin ... end) CALL { ... } subquery\nload_csv(url => :row) LOAD CSV FROM url AS row\nload_csv_headers(url => :row) LOAD CSV WITH HEADERS ...\nforeach(expr => :var, begin...end) FOREACH (var IN expr | ...)\ncreate_index(:Label, :prop) CREATE INDEX ...\ndrop_index(:name) DROP INDEX name IF EXISTS\ncreate_constraint(:L, :p, :type) CREATE CONSTRAINT ...\ndrop_constraint(:name) DROP CONSTRAINT name IF EXISTS\n\nExamples\n\n# Simple traversal\nresult = @cypher conn begin\n    p::Person >> r::KNOWS >> q::Person\n    where(p.age > $min_age, q.name == $target)\n    ret(p.name => :name, r.since, q.name => :friend)\n    order(p.age, :desc)\n    take(10)\nend\n\n# Mutations with auto-SET\n@cypher conn begin\n    p::Person\n    where(p.name == $name)\n    p.age = $new_age\n    p.active = true\n    ret(p)\nend\n\n# Create relationships with >> in create()\n@cypher conn begin\n    match(a::Person, b::Person)\n    where(a.name == $n1, b.name == $n2)\n    create(a >> r::KNOWS >> b)\n    r.since = $year\n    ret(r)\nend\n\n# UNION\n@cypher conn begin\n    p::Person\n    where(p.age > 30)\n    ret(p.name => :name)\n    union()\n    p::Person\n    where(startswith(p.name, \"A\"))\n    ret(p.name => :name)\nend\n\n# CALL subquery\n@cypher conn begin\n    p::Person\n    call(begin\n        with(p)\n        p >> r::KNOWS >> friend::Person\n        ret(count(friend) => :friend_count)\n    end)\n    ret(p.name => :name, friend_count)\nend\n\n# FOREACH\n@cypher conn begin\n    p::Person\n    where(p.active == true)\n    foreach(collect(p) => :n, begin\n        n.verified = true\n    end)\nend\n\n# Comprehension form\nresult = @cypher conn [p.name for p in Person if p.age > 25]\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@create","page":"API Reference","title":"Neo4jQuery.@create","text":"@create conn Label(prop1=val1, prop2=val2, ...)\n\nCreate a single node with the given label and properties. Returns the created Node.\n\nIf a schema is registered for Label (via @node), properties are validated at runtime — missing required properties raise an error.\n\nExample\n\n@node Person begin\n    name::String\n    age::Int\nend\n\nalice = @create conn Person(name=\"Alice\", age=30)\n# alice is a Node with labels=[\"Person\"], properties={name: \"Alice\", age: 30}\n\n# Variables work too:\nname = \"Bob\"\nage = 25\nbob = @create conn Person(name=name, age=age)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@merge","page":"API Reference","title":"Neo4jQuery.@merge","text":"@merge conn Label(match_prop=val) on_create(prop=val, ...) on_match(prop=val, ...)\n\nMERGE a node by matching properties, with optional ON CREATE SET and ON MATCH SET.\n\nReturns the merged Node.\n\nExample\n\n# Merge by name, set age only on creation, update last_seen on every match\nnode = @merge conn Person(name=\"Alice\") on_create(age=30) on_match(last_seen=\"2025-02-15\")\n\n# Simple merge (no on_create/on_match):\nnode = @merge conn Person(name=\"Alice\", age=30)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@relate","page":"API Reference","title":"Neo4jQuery.@relate","text":"@relate conn start_node => REL_TYPE(props...) => end_node\n\nCreate a relationship between two existing Node objects. Returns the created Relationship.\n\nUses elementId() to match the start and end nodes.\n\nExample\n\nalice = @create conn Person(name=\"Alice\", age=30)\nbob   = @create conn Person(name=\"Bob\", age=25)\n\nrel = @relate conn alice => KNOWS(since=2024) => bob\n# rel is a Relationship with type=\"KNOWS\", properties={since: 2024}\n\n\n\n\n\n","category":"macro"},{"location":"guide/biomedical_case_study/#biomedical-case-study","page":"Biomedical Case Study","title":"Biomedical Knowledge Graph — Case Study","text":"This case study demonstrates building a realistic biomedical knowledge graph using the Neo4jQuery DSL. It covers schema declarations, node/relationship creation, and complex analytical queries — with side-by-side comparisons of raw Cypher vs the @cypher DSL.\n\nNeo4jQuery provides the @cypher macro — a unified query interface that uses:\n\nFunction-call clause syntax: where(), ret(), order(), take(), with(), create(), merge(), optional(), unwind(), …\n>> chain patterns (recommended): p::Person >> r::KNOWS >> q::Person\nArrow patterns (also supported): (p:Person)-[r:KNOWS]->(q:Person)\nAuto-SET from property assignments: p.age = $val\nComprehension form: @cypher conn [p.name for p in Person if p.age > 25]\n\nThe macro compiles to Cypher at macro expansion time — zero runtime overhead for query construction. Only parameter values are captured at runtime.\n\nnote: Unified pattern syntax in `@cypher`\nThe @cypher macro uses >> chains as its single, canonical pattern language — for queries, mutations, merges, everything. The same >> syntax works in create(), merge(), optional(), match(), and bare implicit MATCH. Arrow syntax (-[]->), while backward-compatible, is not needed.\n\nThe full runnable scripts are:\n\ntest/biomedical_graph_test.jl — @create / @relate standalone macro examples\ntest/biomedical_graph_dsl_test.jl — @cypher DSL examples\n\n","category":"section"},{"location":"guide/biomedical_case_study/#Domain-model","page":"Biomedical Case Study","title":"Domain model","text":"The graph models a clinical/biomedical knowledge base with 12 node types and 17 relationship types:\n\nNode Labels Relationship Types\nDisease ASSOCIATED_WITH\nGene TARGETS\nProtein INHIBITS\nDrug ENCODES\nClinicalTrial PARTICIPATES_IN\nPatient DIAGNOSED_WITH\nHospital ENROLLED_IN\nPhysician TREATS\nPathway PRESCRIBED_BY\nSymptom LOCATED_AT\nBiomarker PRESENTS_WITH\nPublication INDICATES, PUBLISHED_IN\n EXPRESSES, HAS_SIDE_EFFECT\n INTERACTS_WITH\n\n","category":"section"},{"location":"guide/biomedical_case_study/#1.-Schema-declarations","page":"Biomedical Case Study","title":"1. Schema declarations","text":"","category":"section"},{"location":"guide/biomedical_case_study/#Raw-Cypher","page":"Biomedical Case Study","title":"Raw Cypher","text":"Cypher has no built-in schema declarations. You rely on conventions and documentation:\n\n// No schema — just hope everyone remembers the properties\nCREATE (d:Disease {name: \"Breast Cancer\", icd10_code: \"C50\", category: \"Oncology\", chronic: true})\n// Oops, someone writes: CREATE (d:Disease {naam: \"Lung Cancer\"})  — no error","category":"section"},{"location":"guide/biomedical_case_study/#@cypher-DSL-—-schema-declarations","page":"Biomedical Case Study","title":"@cypher DSL — schema declarations","text":"@node Disease begin\n    name::String\n    icd10_code::String\n    category::String\n    chronic::Bool\nend\n\n@node Gene begin\n    symbol::String\n    full_name::String\n    chromosome::String\n    locus::String = \"\"       # optional, with default\nend\n\n@node Protein begin\n    uniprot_id::String\n    name::String\n    molecular_weight::Float64\n    function_desc::String = \"\"\nend\n\n@node Drug begin\n    name::String\n    trade_name::String\n    mechanism::String\n    approved_year::Int\n    phase::String = \"approved\"\nend\n\n@node Patient begin\n    patient_id::String\n    age::Int\n    sex::String\n    ethnicity::String = \"\"\nend\n\nAdditional node schemas:\n\n@node ClinicalTrial begin\n    trial_id::String\n    title::String\n    phase::String\n    status::String\n    start_year::Int\n    enrollment::Int\nend\n\n@node Hospital begin\n    name::String\n    city::String\n    country::String\n    beds::Int\nend\n\n@node Physician begin\n    name::String\n    specialty::String\n    license_no::String\nend\n\n@node Pathway begin\n    name::String\n    kegg_id::String\n    category::String\nend\n\n@node Symptom begin\n    name::String\n    severity_scale::String\n    body_system::String\nend\n\n@node Biomarker begin\n    name::String\n    biomarker_type::String\n    unit::String\nend\n\n@node Publication begin\n    doi::String\n    title::String\n    journal::String\n    year::Int\nend\nnothing # hide\n\nRelationship schemas:\n\n@rel ASSOCIATED_WITH begin\n    score::Float64\n    source::String\nend\n\n@rel TARGETS begin\n    action::String\n    binding_affinity::Float64 = 0.0\nend\n\n@rel TREATS begin\n    efficacy::Float64\n    evidence_level::String\nend\n\n@rel DIAGNOSED_WITH begin\n    diagnosis_date::String\n    stage::String = \"\"\nend\n\n@rel ENCODES begin\n    transcript_id::String\nend\n\n@rel PARTICIPATES_IN begin\n    role::String\nend\n\n@rel ENROLLED_IN begin\n    enrollment_date::String\n    arm::String\nend\n\n@rel LOCATED_AT begin\n    department::String\nend\n\n@rel INDICATES begin\n    threshold::Float64\n    direction::String\nend\n\n@rel PUBLISHED_IN begin\n    contribution::String\nend\n\n@rel HAS_SIDE_EFFECT begin\n    frequency::String\n    severity::String\nend\n\n@rel EXPRESSES begin\n    tissue::String\n    expression_level::Float64\nend\n\n@rel INHIBITS begin\n    ic50::Float64\n    mechanism::String = \"\"\nend\n\n@rel PRESCRIBED_BY begin\n    prescription_date::String\nend\n\n@rel PRESENTS_WITH begin\n    onset::String\n    frequency::String = \"\"\nend\n\n@rel INTERACTS_WITH begin\n    interaction_type::String\n    confidence::Float64\nend\nnothing # hide\n\nSchemas enable runtime validation — misspelled properties, missing required fields, and type mismatches are caught immediately. The @cypher macro uses the same schema registry.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#2.-Creating-nodes","page":"Biomedical Case Study","title":"2. Creating nodes","text":"","category":"section"},{"location":"guide/biomedical_case_study/#Raw-Cypher-2","page":"Biomedical Case Study","title":"Raw Cypher","text":"CREATE (d:Disease {name: 'Breast Cancer', icd10_code: 'C50', category: 'Oncology', chronic: true})\nRETURN d\n\nCREATE (g:Gene {symbol: 'BRCA1', full_name: 'BRCA1 DNA Repair Associated',\n                chromosome: '17q21.31', locus: '17q21'})\nRETURN g\n\nCREATE (drug:Drug {name: 'Trastuzumab', trade_name: 'Herceptin',\n                   mechanism: 'HER2 monoclonal antibody', approved_year: 1998})\nRETURN drug","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-—-@create-macro","page":"Biomedical Case Study","title":"Julia DSL — @create macro","text":"breast_cancer = @create conn Disease(\n    name=\"Breast Cancer\",\n    icd10_code=\"C50\",\n    category=\"Oncology\",\n    chronic=true\n)\n\nbrca1 = @create conn Gene(\n    symbol=\"BRCA1\", full_name=\"BRCA1 DNA Repair Associated\",\n    chromosome=\"17q21.31\", locus=\"17q21\"\n)\n\ntrastuzumab = @create conn Drug(\n    name=\"Trastuzumab\", trade_name=\"Herceptin\",\n    mechanism=\"HER2 monoclonal antibody\", approved_year=1998\n)\n\nEach call returns a Node object you can use directly to create relationships.","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-—-@cypher-macro","page":"Biomedical Case Study","title":"Julia DSL — @cypher macro","text":"breast_cancer = let\n    r = @cypher conn begin\n        create(d::Disease)\n        d.name = \"Breast Cancer\"\n        d.icd10_code = \"C50\"\n        d.category = \"Oncology\"\n        d.chronic = true\n        ret(d)\n    end\n    r[1].d\nend\n\nbrca1 = let\n    r = @cypher conn begin\n        create(g::Gene)\n        g.symbol = \"BRCA1\"\n        g.full_name = \"BRCA1 DNA Repair Associated\"\n        g.chromosome = \"17q21.31\"\n        g.locus = \"17q21\"\n        ret(g)\n    end\n    r[1].g\nend\n\ntrastuzumab = let\n    r = @cypher conn begin\n        create(d::Drug)\n        d.name = \"Trastuzumab\"\n        d.trade_name = \"Herceptin\"\n        d.mechanism = \"HER2 monoclonal antibody\"\n        d.approved_year = 1998\n        ret(d)\n    end\n    r[1].d\nend\n\nThe @cypher approach uses create() + property assignments (d.name = \"...\") which compile to CREATE (d:Disease) SET d.name = '...'. Properties are set via auto-SET detection.\n\nFor creating nodes, create(d::Disease) is a single-node pattern. For creating relationships, create() takes a >> chain (see next section).\n\n","category":"section"},{"location":"guide/biomedical_case_study/#3.-Creating-relationships","page":"Biomedical Case Study","title":"3. Creating relationships","text":"","category":"section"},{"location":"guide/biomedical_case_study/#Raw-Cypher-3","page":"Biomedical Case Study","title":"Raw Cypher","text":"// Need to match nodes by some property first\nMATCH (g:Gene {symbol: 'BRCA1'}), (d:Disease {name: 'Breast Cancer'})\nCREATE (g)-[r:ASSOCIATED_WITH {score: 0.95, source: 'ClinVar'}]->(d)\nRETURN r\n\nMATCH (drug:Drug {name: 'Trastuzumab'}), (d:Disease {name: 'Breast Cancer'})\nCREATE (drug)-[r:TREATS {efficacy: 0.85, evidence_level: '1A'}]->(d)\nRETURN r","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-—-@relate-macro","page":"Biomedical Case Study","title":"Julia DSL — @relate macro","text":"@relate conn brca1 => ASSOCIATED_WITH(score=0.95, source=\"ClinVar\") => breast_cancer\n\n@relate conn trastuzumab => TREATS(efficacy=0.85, evidence_level=\"1A\") => breast_cancer\n\nNo need to re-match nodes by property. The DSL uses elementId() from the returned Node objects — zero ambiguity, zero duplication.","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-—-@cypher-macro-2","page":"Biomedical Case Study","title":"Julia DSL — @cypher macro","text":"# Match nodes by property, then create the relationship with >> chain\n@cypher conn begin\n    match(g::Gene, d::Disease)\n    where(g.symbol == \"BRCA1\", d.name == \"Breast Cancer\")\n    create(g >> r::ASSOCIATED_WITH >> d)\n    r.score = 0.95\n    r.source = \"ClinVar\"\n    ret(r)\nend\n\n@cypher conn begin\n    match(drug::Drug, d::Disease)\n    where(drug.name == \"Trastuzumab\", d.name == \"Breast Cancer\")\n    create(drug >> r::TREATS >> d)\n    r.efficacy = 0.85\n    r.evidence_level = \"1A\"\n    ret(r)\nend\n\nThe same >> pattern syntax used in queries also works in create(), merge(), and optional(). Relationship properties are set via auto-SET.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.-Complex-queries-—-side-by-side","page":"Biomedical Case Study","title":"4. Complex queries — side by side","text":"","category":"section"},{"location":"guide/biomedical_case_study/#4.1-Multi-hop:-Gene-Protein-Pathway-for-a-disease","page":"Biomedical Case Study","title":"4.1 Multi-hop: Gene → Protein → Pathway for a disease","text":"Raw Cypher:\n\nMATCH (g:Gene)-[:ASSOCIATED_WITH]->(d:Disease {name: 'Breast Cancer'})\nMATCH (g)-[:ENCODES]->(p:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\nRETURN g.symbol AS gene, p.name AS protein, pw.name AS pathway\nORDER BY g.symbol\n\n@cypher DSL:\n\ndisease_name = \"Breast Cancer\"\nresult = @cypher conn begin\n    g::Gene >> ::ASSOCIATED_WITH >> d::Disease\n    g >> ::ENCODES >> p::Protein >> ::PARTICIPATES_IN >> pw::Pathway\n    where(d.name == $disease_name)\n    ret(g.symbol => :gene, p.name => :protein, pw.name => :pathway)\n    order(g.symbol)\nend\n\nThe >> chains are the canonical pattern syntax in @cypher — they work uniformly for queries, mutations, and everything in between. Bare patterns become implicit MATCH clauses.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.2-Drug-repurposing-—-shared-pathway-targets","page":"Biomedical Case Study","title":"4.2 Drug repurposing — shared pathway targets","text":"Raw Cypher:\n\nMATCH (drug:Drug)-[:TARGETS]->(prot:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\nMATCH (prot2:Protein)-[:PARTICIPATES_IN]->(pw)\nMATCH (g:Gene)-[:ENCODES]->(prot2)\nMATCH (g)-[:ASSOCIATED_WITH]->(d:Disease {name: 'Breast Cancer'})\nRETURN drug.name AS drug, pw.name AS pathway, g.symbol AS gene\nORDER BY drug.name\n\n@cypher DSL:\n\ntarget_disease = \"Breast Cancer\"\nresult = @cypher conn begin\n    drug::Drug >> ::TARGETS >> prot::Protein >> ::PARTICIPATES_IN >> pw::Pathway\n    prot2::Protein >> ::PARTICIPATES_IN >> pw\n    g::Gene >> ::ENCODES >> prot2\n    g >> ::ASSOCIATED_WITH >> d::Disease\n    where(d.name == $target_disease)\n    ret(drug.name => :drug, pw.name => :pathway, g.symbol => :gene)\n    order(drug.name)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.3-Patient-cohort-analysis-with-optional-trial-enrollment","page":"Biomedical Case Study","title":"4.3 Patient cohort analysis with optional trial enrollment","text":"Raw Cypher:\n\nMATCH (pt:Patient)-[dx:DIAGNOSED_WITH]->(d:Disease)\nOPTIONAL MATCH (pt)-[e:ENROLLED_IN]->(ct:ClinicalTrial)\nRETURN pt.patient_id AS patient, d.name AS disease,\n       dx.stage AS stage, ct.trial_id AS trial\nORDER BY d.name, pt.patient_id\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    pt::Patient >> dx::DIAGNOSED_WITH >> d::Disease\n    optional(pt >> e::ENROLLED_IN >> ct::ClinicalTrial)\n    ret(pt.patient_id => :patient, d.name => :disease,\n        dx.stage => :stage, ct.trial_id => :trial)\n    order(d.name, pt.patient_id)\nend\n\noptional() maps to OPTIONAL MATCH and accepts the same >> chain patterns.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.4-Aggregation:-drug-count-and-average-efficacy-per-disease","page":"Biomedical Case Study","title":"4.4 Aggregation: drug count and average efficacy per disease","text":"Raw Cypher:\n\nMATCH (drug:Drug)-[t:TREATS]->(d:Disease)\nWITH d.name AS disease, count(drug) AS drug_count, avg(t.efficacy) AS mean_efficacy\nWHERE drug_count > 1\nRETURN disease, drug_count, mean_efficacy\nORDER BY drug_count DESC\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    drug::Drug >> t::TREATS >> d::Disease\n    with(d.name => :disease, count(drug) => :drug_count, avg(t.efficacy) => :mean_efficacy)\n    where(drug_count > 1)\n    ret(disease, drug_count, mean_efficacy)\n    order(drug_count, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.5-Side-effect-overlap-between-drugs","page":"Biomedical Case Study","title":"4.5 Side effect overlap between drugs","text":"Raw Cypher:\n\nMATCH (d1:Drug)-[:HAS_SIDE_EFFECT]->(s:Symptom)\nMATCH (d2:Drug)-[:HAS_SIDE_EFFECT]->(s)\nWHERE d1.name < d2.name\nRETURN d1.name AS drug1, d2.name AS drug2, collect(s.name) AS shared_effects\nORDER BY d1.name\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    d1::Drug >> ::HAS_SIDE_EFFECT >> s::Symptom\n    d2::Drug >> ::HAS_SIDE_EFFECT >> s\n    where(d1.name < d2.name)\n    ret(d1.name => :drug1, d2.name => :drug2, collect(s.name) => :shared_effects)\n    order(d1.name)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.6-Full-patient-journey-—-diagnosis-to-treatment","page":"Biomedical Case Study","title":"4.6 Full patient journey — diagnosis to treatment","text":"Raw Cypher:\n\nMATCH (pt:Patient {patient_id: $pid})-[dx:DIAGNOSED_WITH]->(d:Disease)\nMATCH (drug:Drug)-[t:TREATS]->(d)\nOPTIONAL MATCH (pt)-[e:ENROLLED_IN]->(ct:ClinicalTrial)\nOPTIONAL MATCH (drug)-[:HAS_SIDE_EFFECT]->(se:Symptom)\nRETURN d.name AS disease, drug.name AS drug_option,\n       t.efficacy AS efficacy, ct.title AS trial,\n       collect(se.name) AS side_effects\nORDER BY t.efficacy DESC\n\n@cypher DSL:\n\npid = \"PT-2024-001\"\nresult = @cypher conn begin\n    pt::Patient >> dx::DIAGNOSED_WITH >> d::Disease\n    drug::Drug >> t::TREATS >> d\n    where(pt.patient_id == $pid)\n    optional(pt >> e::ENROLLED_IN >> ct::ClinicalTrial)\n    optional(drug >> ::HAS_SIDE_EFFECT >> se::Symptom)\n    ret(d.name => :disease, drug.name => :drug_option,\n        t.efficacy => :efficacy, ct.title => :trial,\n        collect(se.name) => :side_effects)\n    order(t.efficacy, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.7-Genes-with-multiple-disease-associations","page":"Biomedical Case Study","title":"4.7 Genes with multiple disease associations","text":"Raw Cypher:\n\nMATCH (g:Gene)-[a:ASSOCIATED_WITH]->(d:Disease)\nWITH g.symbol AS gene, count(d) AS disease_count, collect(d.name) AS diseases\nWHERE disease_count >= $min_diseases\nRETURN gene, disease_count, diseases\nORDER BY disease_count DESC\n\n@cypher DSL:\n\nmin_diseases = 2\nresult = @cypher conn begin\n    g::Gene >> a::ASSOCIATED_WITH >> d::Disease\n    with(g.symbol => :gene, count(d) => :disease_count, collect(d.name) => :diseases)\n    where(disease_count >= $min_diseases)\n    ret(gene, disease_count, diseases)\n    order(disease_count, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.8-Hospital-physician-coverage","page":"Biomedical Case Study","title":"4.8 Hospital physician coverage","text":"Raw Cypher:\n\nMATCH (ph:Physician)-[:LOCATED_AT]->(h:Hospital)\nRETURN h.name AS hospital, collect(ph.specialty) AS specialties,\n       count(ph) AS physician_count\nORDER BY physician_count DESC\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    ph::Physician >> ::LOCATED_AT >> h::Hospital\n    ret(h.name => :hospital, collect(ph.specialty) => :specialties,\n        count(ph) => :physician_count)\n    order(physician_count, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.9-Biomarker-guided-treatment-selection","page":"Biomedical Case Study","title":"4.9 Biomarker-guided treatment selection","text":"Raw Cypher:\n\nMATCH (bm:Biomarker)-[:INDICATES]->(d:Disease)\nMATCH (drug:Drug)-[:TREATS]->(d)\nRETURN bm.name AS biomarker, d.name AS disease,\n       drug.name AS drug, drug.mechanism AS mechanism\nORDER BY bm.name, drug.name\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    bm::Biomarker >> ::INDICATES >> d::Disease\n    drug::Drug >> ::TREATS >> d\n    ret(bm.name => :biomarker, d.name => :disease,\n        drug.name => :drug, drug.mechanism => :mechanism)\n    order(bm.name, drug.name)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.10-Full-knowledge-chain:-Biomarker-Disease-Gene-Protein-Pathway","page":"Biomedical Case Study","title":"4.10 Full knowledge chain: Biomarker → Disease → Gene → Protein → Pathway","text":"Raw Cypher:\n\nMATCH (bm:Biomarker)-[:INDICATES]->(d:Disease)\nMATCH (g:Gene)-[:ASSOCIATED_WITH]->(d)\nMATCH (g)-[:ENCODES]->(p:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\nRETURN bm.name AS biomarker, d.name AS disease,\n       g.symbol AS gene, p.name AS protein, pw.name AS pathway\nORDER BY d.name, g.symbol\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    bm::Biomarker >> ::INDICATES >> d::Disease\n    g::Gene >> ::ASSOCIATED_WITH >> d\n    g >> ::ENCODES >> p::Protein >> ::PARTICIPATES_IN >> pw::Pathway\n    ret(bm.name => :biomarker, d.name => :disease,\n        g.symbol => :gene, p.name => :protein, pw.name => :pathway)\n    order(d.name, g.symbol)\nend\n\nA five-hop traversal across the entire knowledge base — expressed as readable Julia. The >> chains make the directionality explicit and composable.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.11-Mixed-direction-chains:-Drug-Disease-Gene","page":"Biomedical Case Study","title":"4.11 Mixed-direction chains: Drug → Disease ← Gene","text":"In real knowledge graphs, not every hop goes in the same direction. The @cypher DSL handles this naturally — mix >> (forward) and << (backward) in a single chain to express convergent patterns where different entity types meet at a shared node.\n\nRaw Cypher:\n\nMATCH (dr:Drug)-[:TREATS]->(d:Disease)<-[:ASSOCIATED_WITH]-(g:Gene)\nRETURN dr.name AS drug, d.name AS disease, g.symbol AS gene\nORDER BY d.name, dr.name, g.symbol\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    dr::Drug >> ::TREATS >> d::Disease << ::ASSOCIATED_WITH << g::Gene\n    ret(dr.name => :drug, d.name => :disease, g.symbol => :gene)\n    order(d.name, dr.name, g.symbol)\nend\n\nThe >> and << operators can be freely combined in a single path — each relationship is bracketed by the same operator (>> rel >> for forward, << rel << for backward), and you can have any number of direction changes:\n\n# Four-segment chain: Drug → Disease ← Gene → Protein → Pathway\nresult = @cypher conn begin\n    dr::Drug >> ::TREATS >> d::Disease << ::ASSOCIATED_WITH << g::Gene >> ::ENCODES >> p::Protein >> ::PARTICIPATES_IN >> pw::Pathway\n    ret(dr.name => :drug, d.name => :disease,\n        g.symbol => :gene, p.name => :protein, pw.name => :pathway)\n    order(d.name, g.symbol)\nend\n\ntip: Reading mixed chains\nRead >> as \"points to\" and << as \"is pointed to by\". The chain Drug >> TREATS >> Disease << ASSOCIATED_WITH << Gene reads as: \"Drug treats Disease, which Gene is associated with.\"\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.12-Batch-insert-with-UNWIND","page":"Biomedical Case Study","title":"4.12 Batch insert with UNWIND","text":"Raw Cypher:\n\nUNWIND $adverse_events AS ae\nMATCH (drug:Drug)\nWHERE drug.name = ae.drug_name\nCREATE (drug)-[:REPORTED_AE]->(event:AdverseEvent)\nSET event.name = ae.event, event.grade = ae.grade\nRETURN drug.name AS drug, event.name AS event, event.grade AS grade\n\n@cypher DSL:\n\nadverse_events = [\n    Dict(\"drug_name\" => \"Trastuzumab\", \"event\" => \"Cardiotoxicity\", \"grade\" => 2),\n    Dict(\"drug_name\" => \"Erlotinib\", \"event\" => \"Rash\", \"grade\" => 1),\n    Dict(\"drug_name\" => \"Pembrolizumab\", \"event\" => \"Pneumonitis\", \"grade\" => 3),\n    Dict(\"drug_name\" => \"Olaparib\", \"event\" => \"Anemia\", \"grade\" => 2),\n]\n\nresult = @cypher conn begin\n    unwind($adverse_events => :ae)\n    drug::Drug\n    where(drug.name == ae.drug_name)\n    create(drug >> ::REPORTED_AE >> event::AdverseEvent)\n    event.name = ae.event\n    event.grade = ae.grade\n    ret(drug.name => :drug, event.name => :event, event.grade => :grade)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.13-Complex-WHERE-with-string-functions","page":"Biomedical Case Study","title":"4.13 Complex WHERE with string functions","text":"Raw Cypher:\n\nMATCH (g:Gene)-[:ASSOCIATED_WITH]->(d:Disease)\nWHERE g.chromosome STARTS WITH '17' AND d.category = 'Oncology'\nRETURN g.symbol AS gene, g.chromosome AS chr, d.name AS disease\nORDER BY g.symbol\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    g::Gene >> ::ASSOCIATED_WITH >> d::Disease\n    where(startswith(g.chromosome, \"17\"), d.category == \"Oncology\")\n    ret(g.symbol => :gene, g.chromosome => :chr, d.name => :disease)\n    order(g.symbol)\nend\n\nMulti-condition where() auto-ANDs conditions — no need for &&.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.14-WITH-pipeline-—-treatment-landscape","page":"Biomedical Case Study","title":"4.14 WITH pipeline — treatment landscape","text":"Raw Cypher:\n\nMATCH (drug:Drug)-[t:TREATS]->(d:Disease)\nWITH d, count(drug) AS n_drugs, avg(t.efficacy) AS avg_eff\nMATCH (g:Gene)-[:ASSOCIATED_WITH]->(d)\nRETURN d.name AS disease, n_drugs, avg_eff, count(g) AS n_genes\nORDER BY n_drugs DESC\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    drug::Drug >> t::TREATS >> d::Disease\n    with(d, count(drug) => :n_drugs, avg(t.efficacy) => :avg_eff)\n    g::Gene >> ::ASSOCIATED_WITH >> d\n    ret(d.name => :disease, n_drugs, avg_eff, count(g) => :n_genes)\n    order(n_drugs, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.15-Publication-Disease-knowledge-network","page":"Biomedical Case Study","title":"4.15 Publication → Disease knowledge network","text":"Raw Cypher:\n\nMATCH (pub:Publication)-[:PUBLISHED_IN]->(d:Disease)\nMATCH (drug:Drug)-[:TREATS]->(d)\nWITH pub, d, collect(drug.name) AS drugs\nRETURN pub.title AS publication, pub.journal AS journal,\n       d.name AS disease, drugs\nORDER BY pub.year DESC\n\n@cypher DSL:\n\nresult = @cypher conn begin\n    pub::Publication >> ::PUBLISHED_IN >> d::Disease\n    drug::Drug >> ::TREATS >> d\n    with(pub, d, collect(drug.name) => :drugs)\n    ret(pub.title => :publication, pub.journal => :journal,\n        d.name => :disease, drugs)\n    order(pub.year, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#Key-takeaways","page":"Biomedical Case Study","title":"Key takeaways","text":"Aspect Raw Cypher @cypher DSL\nInjection safety Manual parameterisation Automatic — $var captures safely\nSchema validation None built-in @node/@rel with runtime checks\nNode references Re-match by property match() + where() + create(), or @relate\nPatterns (p:Person)-[r:KNOWS]->(q:Person) p::Person >> r::KNOWS >> q::Person (everywhere)\nClauses Cypher keywords where(), ret(), order(), take()\nOperator mapping <>, AND, STARTS WITH !=, &&, startswith (Julia-native)\nReturn aliases expr AS alias expr => :alias\nMutations CREATE, SET create() + auto-SET assignments\nOPTIONAL MATCH OPTIONAL MATCH optional()\nCompile-time String at runtime Cypher assembled at macro expansion\n\nThe @cypher macro compiles to identical Cypher at macro expansion time — there is zero runtime overhead for query construction. Only parameter values are captured at runtime. The >> syntax works uniformly across queries (MATCH), mutations (CREATE, MERGE), and OPTIONAL MATCH — one pattern language for everything.","category":"section"},{"location":"getting_started/#getting-started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Neo4jQuery.jl is currently installed from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/algunion/Neo4jQuery.jl\")","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"You need a running Neo4j instance (5.x or later) with the Query API v2 enabled. This is the default for:\n\nNeo4j Aura (cloud)\nNeo4j Community / Enterprise 5.x+ (self-hosted)","category":"section"},{"location":"getting_started/#Connecting","page":"Getting Started","title":"Connecting","text":"The simplest way to connect:\n\nusing Neo4jQuery\n\nconn = connect(\"localhost\", \"neo4j\";\n    port=7474,\n    auth=BasicAuth(\"neo4j\", \"password\"),\n    scheme=\"http\")\n\nOr load credentials from environment variables / a .env file:\n\nconn = connect_from_env()\nprintln(conn)\n\nSee Connections for full details.","category":"section"},{"location":"getting_started/#Your-First-Query","page":"Getting Started","title":"Your First Query","text":"# Create a node using the cypher\"\" string macro (recommended)\nname = \"Alice\"\nage = 30\nresult = query(conn, cypher\"CREATE (p:Person {name: $name, age: $age}) RETURN p\";\n    include_counters=true)\n\nprintln(result[1].p)\nprintln(result.counters)\n\n# Read it back\nname = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p.name AS name, p.age AS age\"\nresult = query(conn, q; access_mode=:read)\nprintln(result[1].name)\n\nYou can also use {{param}} placeholders in raw query strings — no escaping required:\n\nresult = query(conn,\n    \"MATCH (p:Person {name: {{name}}}) RETURN p.name AS name, p.age AS age\",\n    parameters=Dict{String,Any}(\"name\" => \"Alice\"); access_mode=:read)\nprintln(result[1].name, \" is \", result[1].age)","category":"section"},{"location":"getting_started/#Quick-DSL-Example","page":"Getting Started","title":"Quick DSL Example","text":"The DSL lets you write graph queries in Julia syntax:\n\n@node Person begin\n    name::String\n    age::Int\nend\n\n@rel KNOWS begin\n    since::Int\nend\nnothing # hide\n\n# Create nodes\nalice = @create conn Person(name=\"Alice2\", age=30)\nbob   = @create conn Person(name=\"Bob2\", age=25)\n\n# Create a relationship between them\nrel = @relate conn alice => KNOWS(since=2024) => bob\n\n# Query the graph\nmin_age = 20\nresult = @cypher conn begin\n    p::Person >> r::KNOWS >> friend::Person\n    where(p.name == \"Alice2\", friend.age > $min_age)\n    ret(friend.name => :name, r.since => :since)\n    order(r.since, :desc)\nend\n\nfor row in result\n    println(row.name, \" — known since \", row.since)\nend\n\n# Or as a one-liner comprehension\nresult = @cypher conn [p.name for p in Person if p.age > 20]\n\n# Mutations with auto-SET\nresult = @cypher conn begin\n    p::Person\n    where(p.name == \"Alice2\")\n    p.age = 31\n    ret(p)\nend\n\nSee DSL for the full guide with advanced examples.","category":"section"},{"location":"getting_started/#What's-Next?","page":"Getting Started","title":"What's Next?","text":"Queries — parameterised queries, counters, bookmarks\nTransactions — explicit begin/commit/rollback and do-block API\nStreaming — memory-efficient row-by-row iteration\nDSL — @cypher, @create, @merge, @relate macros\nAPI Reference — full function and type documentation","category":"section"},{"location":"llm/#Neo4jQuery.jl-—-LLM-Reference","page":"Neo4jQuery.jl — LLM Reference","title":"Neo4jQuery.jl — LLM Reference","text":"Complete, high-signal reference for Neo4jQuery.jl — a Julia client for Neo4j using the Query API v2 over HTTP with Typed JSON.\n\n","category":"section"},{"location":"llm/#Installation","page":"Neo4jQuery.jl — LLM Reference","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/algunion/Neo4jQuery.jl\")\n\nRequires Neo4j 5.x+ with Query API v2 enabled (default for Aura and Community/Enterprise 5.x+).\n\n","category":"section"},{"location":"llm/#Exports","page":"Neo4jQuery.jl — LLM Reference","title":"Exports","text":"# Connection\nNeo4jConnection, connect, connect_from_env, dotenv\n\n# Auth\nAbstractAuth, BasicAuth, BearerAuth\n\n# Query\nquery, @cypher_str, CypherQuery\n\n# Transactions\nTransaction, begin_transaction, commit!, rollback!, transaction\n\n# Streaming\nstream, StreamingResult, summary\n\n# Result types\nQueryResult, QueryCounters, Notification\n\n# Graph types\nNode, Relationship, Path, CypherPoint, CypherDuration, CypherVector\n\n# Errors\nNeo4jError, AuthenticationError, Neo4jQueryError, TransactionExpiredError\n\n# DSL — Schema\nPropertyDef, NodeSchema, RelSchema, @node, @rel\nget_node_schema, get_rel_schema\nvalidate_node_properties, validate_rel_properties\n\n# DSL — Macros\n@cypher, @create, @merge, @relate\n\n","category":"section"},{"location":"llm/#Connection","page":"Neo4jQuery.jl — LLM Reference","title":"Connection","text":"","category":"section"},{"location":"llm/#connect","page":"Neo4jQuery.jl — LLM Reference","title":"connect","text":"conn = connect(\"localhost\", \"neo4j\"; port=7474, auth=BasicAuth(\"neo4j\", \"password\"), scheme=\"http\")\n\nParam Type Default Description\nhost String required Hostname or IP\ndatabase String required Database name\nport Int 7474 HTTP port\nauth AbstractAuth required Auth strategy\nscheme String \"http\" \"http\" or \"https\"\n\nHits GET / discovery endpoint on construction; throws on failure.","category":"section"},{"location":"llm/#connect_from_env","page":"Neo4jQuery.jl — LLM Reference","title":"connect_from_env","text":"conn = connect_from_env(; path=\".env\", prefix=\"NEO4J_\")\n\nReads from env vars (optionally from .env file first):\n\nVariable Description\nNEO4J_URI neo4j+s://host, bolt://host, etc\nNEO4J_USERNAME Username\nNEO4J_PASSWORD Password\nNEO4J_DATABASE Database name (default: \"neo4j\")\n\nURI scheme mapping:\n\nneo4j+s://, neo4j+ssc://, bolt+s://, bolt+ssc://, https:// → HTTPS, port 443\nneo4j://, bolt://, http:// → HTTP, port 7474","category":"section"},{"location":"llm/#dotenv","page":"Neo4jQuery.jl — LLM Reference","title":"dotenv","text":"vars = dotenv(\".env\"; overwrite=false)\n\nLoads .env into ENV. Supports # comments, quoted values, export prefix. Existing keys preserved unless overwrite=true.\n\n","category":"section"},{"location":"llm/#Authentication","page":"Neo4jQuery.jl — LLM Reference","title":"Authentication","text":"auth = BasicAuth(\"neo4j\", \"password\")   # HTTP Basic (RFC 7617)\nauth = BearerAuth(\"eyJhbG...\")          # Bearer token\n\nCustom auth: subtype AbstractAuth, implement auth_header(::YourAuth) -> Pair{String,String}.\n\nstruct ApiKeyAuth <: Neo4jQuery.AbstractAuth\n    key::String\nend\nNeo4jQuery.auth_header(a::ApiKeyAuth) = \"ApiKey $(a.key)\"\n\n","category":"section"},{"location":"llm/#Query","page":"Neo4jQuery.jl — LLM Reference","title":"Query","text":"","category":"section"},{"location":"llm/#Basic-query","page":"Neo4jQuery.jl — LLM Reference","title":"Basic query","text":"result = query(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")","category":"section"},{"location":"llm/#With-parameters-(always-use-for-user-input)","page":"Neo4jQuery.jl — LLM Reference","title":"With parameters (always use for user input)","text":"Use {{param}} Mustache-style placeholders to avoid \\$ escaping:\n\nresult = query(conn,\n    \"MATCH (p:Person {name: {{name}}}) RETURN p\",\n    parameters=Dict{String,Any}(\"name\" => \"Alice\"))\n\nThe legacy \\$param form still works but requires escaping in Julia strings:\n\nresult = query(conn,\n    \"MATCH (p:Person {name: \\$name}) RETURN p\",\n    parameters=Dict{String,Any}(\"name\" => \"Alice\"))","category":"section"},{"location":"llm/#@cypher_str-macro-(preferred)","page":"Neo4jQuery.jl — LLM Reference","title":"@cypher_str macro (preferred)","text":"Captures $var references from local scope as safe parameters:\n\nname = \"Alice\"\nage = 30\nq = cypher\"MATCH (p:Person {name: $name, age: $age}) RETURN p\"\n# q.statement == \"MATCH (p:Person {name: $name, age: $age}) RETURN p\"\n# q.parameters == Dict(\"name\" => \"Alice\", \"age\" => 30)\nresult = query(conn, q)","category":"section"},{"location":"llm/#Query-options","page":"Neo4jQuery.jl — LLM Reference","title":"Query options","text":"Keyword Type Default Description\nparameters Dict{String,Any} Dict() Query parameters\naccess_mode Symbol :write :read or :write\ninclude_counters Bool false Include mutation statistics\nbookmarks Vector{String} String[] Causal consistency bookmarks\nimpersonated_user Union{String,Nothing} nothing Impersonate another user\n\n","category":"section"},{"location":"llm/#QueryResult","page":"Neo4jQuery.jl — LLM Reference","title":"QueryResult","text":"Returned by query(). Each row is a NamedTuple with keys matching query field names.\n\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\n\nresult[1]           # first row NamedTuple: (name = \"Alice\", age = 30)\nresult[1].name      # \"Alice\"\nresult.fields       # [\"name\", \"age\"]\nlength(result)      # number of rows\nisempty(result)     # Bool\n\nfor row in result\n    println(row.name, \" — \", row.age)\nend\n\nnames = [row.name for row in result]","category":"section"},{"location":"llm/#Counters","page":"Neo4jQuery.jl — LLM Reference","title":"Counters","text":"result = query(conn, \"CREATE (n:Test) RETURN n\"; include_counters=true)\nc = result.counters\n# Fields: nodes_created, nodes_deleted, relationships_created, relationships_deleted,\n#         properties_set, labels_added, labels_removed, indexes_added, indexes_removed,\n#         constraints_added, constraints_removed, contains_updates, contains_system_updates, system_updates","category":"section"},{"location":"llm/#Bookmarks","page":"Neo4jQuery.jl — LLM Reference","title":"Bookmarks","text":"r1 = query(conn, \"CREATE (n:Test)\")\nr2 = query(conn, \"MATCH (n:Test) RETURN n\"; bookmarks=r1.bookmarks)","category":"section"},{"location":"llm/#Notifications","page":"Neo4jQuery.jl — LLM Reference","title":"Notifications","text":"result.notifications  # Vector{Notification} — performance warnings, deprecation hints\n# Each has: code, title, description, severity, category, position\n\n","category":"section"},{"location":"llm/#Graph-Types","page":"Neo4jQuery.jl — LLM Reference","title":"Graph Types","text":"","category":"section"},{"location":"llm/#Node","page":"Neo4jQuery.jl — LLM Reference","title":"Node","text":"node.element_id         # String\nnode.labels             # Vector{String}\nnode.properties         # JSON.Object{String,Any}\nnode[\"name\"]            # property access (indexing)\nnode.name               # property access (dot syntax)","category":"section"},{"location":"llm/#Relationship","page":"Neo4jQuery.jl — LLM Reference","title":"Relationship","text":"rel.element_id                # String\nrel.start_node_element_id     # String\nrel.end_node_element_id       # String\nrel.type                      # String (e.g. \"KNOWS\")\nrel[\"since\"]                  # property access\nrel.since                     # dot syntax","category":"section"},{"location":"llm/#Path","page":"Neo4jQuery.jl — LLM Reference","title":"Path","text":"path.elements   # Vector{Union{Node, Relationship}} — alternating node/rel sequence","category":"section"},{"location":"llm/#CypherPoint","page":"Neo4jQuery.jl — LLM Reference","title":"CypherPoint","text":"pt.srid          # Int (e.g. 4326 for WGS84)\npt.coordinates   # Vector{Float64}","category":"section"},{"location":"llm/#CypherDuration","page":"Neo4jQuery.jl — LLM Reference","title":"CypherDuration","text":"d.value   # String — ISO-8601 (e.g. \"P1Y2M3DT4H\")","category":"section"},{"location":"llm/#CypherVector","page":"Neo4jQuery.jl — LLM Reference","title":"CypherVector","text":"v.coordinates_type   # String\nv.coordinates        # Vector{String}\n\n","category":"section"},{"location":"llm/#Transactions","page":"Neo4jQuery.jl — LLM Reference","title":"Transactions","text":"","category":"section"},{"location":"llm/#Explicit","page":"Neo4jQuery.jl — LLM Reference","title":"Explicit","text":"tx = begin_transaction(conn)\nquery(tx, \"CREATE (n:Person {name: \\$name})\", parameters=Dict{String,Any}(\"name\" => \"Alice\"))\nbookmarks = commit!(tx)\n\ntx = begin_transaction(conn)\nquery(tx, \"CREATE (n:Temp)\")\nrollback!(tx)   # discards all changes\n\nOptional initial/final statements:\n\ntx = begin_transaction(conn; statement=\"CREATE (n:Init) RETURN n\", parameters=Dict{String,Any}())\nbookmarks = commit!(tx; statement=\"CREATE (n:Final) RETURN n\", parameters=Dict{String,Any}())","category":"section"},{"location":"llm/#Do-block-(recommended-—-auto-commit/rollback)","page":"Neo4jQuery.jl — LLM Reference","title":"Do-block (recommended — auto-commit/rollback)","text":"transaction(conn) do tx\n    query(tx, \"CREATE (a:Person {name: 'Alice'})\")\n    query(tx, \"CREATE (b:Person {name: 'Bob'})\")\nend  # auto-commits; auto-rolls-back on exception","category":"section"},{"location":"llm/#Transaction-state","page":"Neo4jQuery.jl — LLM Reference","title":"Transaction state","text":"tx.committed     # Bool\ntx.rolled_back   # Bool\n# Using committed/rolled-back tx throws an error\n\n","category":"section"},{"location":"llm/#Streaming","page":"Neo4jQuery.jl — LLM Reference","title":"Streaming","text":"Row-by-row iteration over JSONL responses; memory-efficient for large result sets.\n\nsr = stream(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\nfor row in sr\n    println(row.name)\nend\n\nSame keyword arguments as query. Also works inside transactions:\n\ntx = begin_transaction(conn)\nsr = stream(tx, \"MATCH (p) RETURN p\")\nrows = collect(sr)\ncommit!(tx)","category":"section"},{"location":"llm/#Summary-(after-consuming-stream)","page":"Neo4jQuery.jl — LLM Reference","title":"Summary (after consuming stream)","text":"import Neo4jQuery: summary   # required — Base.summary takes precedence\ns = summary(sr)\n# s.bookmarks, s.counters, s.notifications, s.transaction, s.query_plan, s.profiled_query_plan\n\n","category":"section"},{"location":"llm/#Errors","page":"Neo4jQuery.jl — LLM Reference","title":"Errors","text":"Type Trigger\nAuthenticationError HTTP 401 (bad credentials)\nNeo4jQueryError Cypher syntax errors, constraint violations, etc.\nTransactionExpiredError Transaction expired or rolled back server-side\n\nAll subtype Neo4jError <: Exception. Fields: code::String, message::String (except TransactionExpiredError which has only message).\n\n","category":"section"},{"location":"llm/#DSL-—-Schema-System","page":"Neo4jQuery.jl — LLM Reference","title":"DSL — Schema System","text":"","category":"section"},{"location":"llm/#@node","page":"Neo4jQuery.jl — LLM Reference","title":"@node","text":"@node Person begin\n    name::String        # required\n    age::Int            # required\n    email::String = \"\"  # optional, default \"\"\nend\n\nCreates a NodeSchema constant and registers it globally. Label-only: @node Marker.","category":"section"},{"location":"llm/#@rel","page":"Neo4jQuery.jl — LLM Reference","title":"@rel","text":"@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\nCreates a RelSchema constant. Label-only: @rel LINKS.","category":"section"},{"location":"llm/#Lookup-and-validation","page":"Neo4jQuery.jl — LLM Reference","title":"Lookup and validation","text":"get_node_schema(:Person)   # NodeSchema or nothing\nget_rel_schema(:KNOWS)     # RelSchema or nothing\n\nvalidate_node_properties(schema, Dict{String,Any}(\"name\" => \"Alice\", \"age\" => 30))\n# Throws on missing required props; warns on unknown props. No type-checking.\n\n","category":"section"},{"location":"llm/#DSL-—-Standalone-Mutation-Macros","page":"Neo4jQuery.jl — LLM Reference","title":"DSL — Standalone Mutation Macros","text":"","category":"section"},{"location":"llm/#@create-—-create-a-node","page":"Neo4jQuery.jl — LLM Reference","title":"@create — create a node","text":"node = @create conn Person(name=\"Alice\", age=30)\n# Returns: Node\n\nValidates against registered schema if present.","category":"section"},{"location":"llm/#@merge-—-upsert-a-node","page":"Neo4jQuery.jl — LLM Reference","title":"@merge — upsert a node","text":"node = @merge conn Person(name=\"Alice\") on_create(age=30) on_match(last_seen=\"2025-02-15\")\nnode = @merge conn Person(name=\"Alice\", age=30)   # simple merge","category":"section"},{"location":"llm/#@relate-—-create-a-relationship","page":"Neo4jQuery.jl — LLM Reference","title":"@relate — create a relationship","text":"alice = @create conn Person(name=\"Alice\", age=30)\nbob = @create conn Person(name=\"Bob\", age=25)\nrel = @relate conn alice => KNOWS(since=2024) => bob\n# Returns: Relationship\n# Matches nodes by elementId()\n\n","category":"section"},{"location":"llm/#DSL-—-@cypher-Macro-(Unified-Query-Builder)","page":"Neo4jQuery.jl — LLM Reference","title":"DSL — @cypher Macro (Unified Query Builder)","text":"Compiles a Julia block into parameterised Cypher at macro expansion time. Only $param values are captured at runtime.","category":"section"},{"location":"llm/#Invocation-forms","page":"Neo4jQuery.jl — LLM Reference","title":"Invocation forms","text":"# Block form\nresult = @cypher conn begin\n    p::Person >> r::KNOWS >> q::Person\n    where(p.age > $min_age)\n    ret(p.name => :name, r.since)\n    order(p.age, :desc)\n    take(10)\nend\n\n# With keyword arguments\nresult = @cypher conn begin\n    p::Person\n    ret(p)\nend include_counters=true access_mode=:write\n\n# Comprehension form\nresult = @cypher conn [p.name for p in Person if p.age > 25]\nresult = @cypher conn [(p.name, p.age) for p in Person]\nresult = @cypher conn [p.name => :n for p in Person]\nresult = @cypher conn [p for p in Person]","category":"section"},{"location":"llm/#access_mode-auto-inference","page":"Neo4jQuery.jl — LLM Reference","title":"access_mode auto-inference","text":"@cypher automatically sets access_mode=:read for pure reads and :write when any mutation clause is present. Explicit kwarg overrides.\n\n","category":"section"},{"location":"llm/#Pattern-Syntax","page":"Neo4jQuery.jl — LLM Reference","title":"Pattern Syntax","text":"","category":"section"},{"location":"llm/#chain-(recommended)","page":"Neo4jQuery.jl — LLM Reference","title":">> chain (recommended)","text":"p::Person                                   # (p:Person)\n::Person                                    # (:Person)\np::Person >> r::KNOWS >> q::Person          # (p:Person)-[r:KNOWS]->(q:Person)\np::Person >> KNOWS >> q::Person             # (p:Person)-[:KNOWS]->(q:Person)\np::Person << r::KNOWS << q::Person          # (p:Person)<-[r:KNOWS]-(q:Person)\na::A >> R1 >> b::B >> R2 >> c::C            # (a:A)-[:R1]->(b:B)-[:R2]->(c:C)","category":"section"},{"location":"llm/#Arrow-syntax-(also-supported)","page":"Neo4jQuery.jl — LLM Reference","title":"Arrow syntax (also supported)","text":"(p:Person)-[r:KNOWS]->(q:Person)            # right arrow\n(a:Person)<-[r:KNOWS]-(b:Person)            # left arrow\n(a:Person)-[r:KNOWS]-(b:Person)             # undirected\n(a:Person)-[r:KNOWS, 1, 3]->(b:Person)      # variable-length *1..3\n(a) --> (b)                                 # simple right arrow\n(a) <-- (b)                                 # simple left arrow\n\nBare patterns in a block are implicit MATCH clauses.\n\n","category":"section"},{"location":"llm/#Clause-Functions","page":"Neo4jQuery.jl — LLM Reference","title":"Clause Functions","text":"DSL Cypher\nwhere(cond1, cond2) WHERE cond1 AND cond2\nret(expr => :alias, ...) RETURN expr AS alias, ...\nreturning(expr => :alias) RETURN expr AS alias (synonym)\nret(distinct, expr) RETURN DISTINCT expr\norder(expr, :desc) ORDER BY expr DESC\ntake(n) / skip(n) LIMIT n / SKIP n\nmatch(p1, p2) MATCH p1, p2\noptional(pattern) OPTIONAL MATCH pattern\ncreate(pattern) CREATE pattern\nmerge(pattern) MERGE pattern\nwith(expr => :alias, ...) WITH expr AS alias, ...\nunwind($list => :var) UNWIND $list AS var\ndelete(vars...) DELETE vars\ndetach_delete(vars...) DETACH DELETE vars\non_create(p.prop = val) ON CREATE SET p.prop = val\non_match(p.prop = val) ON MATCH SET p.prop = val\nremove(p.prop) REMOVE p.prop\np.prop = $val (assignment) SET p.prop = $val\nunion() UNION\nunion_all() UNION ALL\ncall(begin ... end) CALL { ... } subquery\nload_csv(url => :row) LOAD CSV FROM url AS row\nload_csv_headers(url => :row) LOAD CSV WITH HEADERS FROM url AS row\nforeach(var, :in, expr, begin ... end) FOREACH (var IN expr | ...)\ncreate_index(:Label, :prop) CREATE INDEX FOR (n:Label) ON (n.prop)\ncreate_index(:Label, :prop, :name) named index\ndrop_index(:name) DROP INDEX name IF EXISTS\ncreate_constraint(:Label, :prop, :unique) uniqueness constraint\ncreate_constraint(:Label, :prop, :not_null, :name) NOT NULL constraint (named)\ndrop_constraint(:name) DROP CONSTRAINT name IF EXISTS\n\n","category":"section"},{"location":"llm/#WHERE-Operator-Mapping","page":"Neo4jQuery.jl — LLM Reference","title":"WHERE Operator Mapping","text":"Julia Cypher\n== =\n!= <>\n&& AND\n|| OR\n! NOT\n>=, <=, >, < same\n+, -, *, /, %, ^ same (arithmetic)\nstartswith(p.name, \"A\") p.name STARTS WITH 'A'\nendswith(p.name, \"e\") p.name ENDS WITH 'e'\ncontains(p.name, \"li\") p.name CONTAINS 'li'\nin(p.name, $list) p.name IN $list\nisnothing(p.email) p.email IS NULL\nmatches(p.name, \"^A.*\") p.name =~ '^A.*'\nexists((p)-[:R]->(q)) EXISTS { MATCH (p)-[:R]->(q) }\nif/elseif/else/end CASE WHEN ... THEN ... ELSE ... END\n\nMulti-condition where() auto-ANDs: where(a, b, c) → WHERE a AND b AND c.\n\n","category":"section"},{"location":"llm/#Parameter-Capture","page":"Neo4jQuery.jl — LLM Reference","title":"Parameter Capture","text":"$var captures Julia variables as safe Cypher parameters. Works in where(), property assignments, unwind(), skip(), take(), and any expression.\n\nmin_age = 25\nresult = @cypher conn begin\n    p::Person\n    where(p.age > $min_age)\n    ret(p.name)\nend\n\n","category":"section"},{"location":"llm/#Auto-SET","page":"Neo4jQuery.jl — LLM Reference","title":"Auto-SET","text":"Property assignments become SET clauses; multiple merge into one:\n\n@cypher conn begin\n    p::Person\n    where(p.name == $name)\n    p.age = $new_age\n    p.email = $new_email\n    ret(p)\nend\n# → MATCH (p:Person) WHERE p.name = $name SET p.age = $new_age, p.email = $new_email RETURN p\n\n","category":"section"},{"location":"llm/#Complete-Examples","page":"Neo4jQuery.jl — LLM Reference","title":"Complete Examples","text":"","category":"section"},{"location":"llm/#Aggregation-with-WITH","page":"Neo4jQuery.jl — LLM Reference","title":"Aggregation with WITH","text":"result = @cypher conn begin\n    p::Person >> r::KNOWS >> q::Person\n    with(p, count(r) => :degree)\n    where(degree > $min_connections)\n    order(degree, :desc)\n    ret(p.name => :person, degree)\nend","category":"section"},{"location":"llm/#OPTIONAL-MATCH","page":"Neo4jQuery.jl — LLM Reference","title":"OPTIONAL MATCH","text":"result = @cypher conn begin\n    p::Person\n    optional(p >> w::WORKS_AT >> c::Company)\n    ret(p.name => :person, c.name => :company)\nend","category":"section"},{"location":"llm/#Batch-with-UNWIND","page":"Neo4jQuery.jl — LLM Reference","title":"Batch with UNWIND","text":"people = [Dict(\"name\" => \"Dave\", \"age\" => 28), Dict(\"name\" => \"Eve\", \"age\" => 22)]\nresult = @cypher conn begin\n    unwind($people => :person)\n    create((p:Person))\n    p.name = person.name\n    p.age = person.age\n    ret(p)\nend","category":"section"},{"location":"llm/#UNION","page":"Neo4jQuery.jl — LLM Reference","title":"UNION","text":"result = @cypher conn begin\n    p::Person\n    where(p.age > 30)\n    ret(p.name => :name)\n    union()\n    p::Person\n    where(startswith(p.name, \"A\"))\n    ret(p.name => :name)\nend","category":"section"},{"location":"llm/#CALL-subquery","page":"Neo4jQuery.jl — LLM Reference","title":"CALL subquery","text":"result = @cypher conn begin\n    p::Person\n    call(begin\n        with(p)\n        p >> r::KNOWS >> friend::Person\n        ret(count(friend) => :friend_count)\n    end)\n    ret(p.name => :name, friend_count)\nend","category":"section"},{"location":"llm/#FOREACH","page":"Neo4jQuery.jl — LLM Reference","title":"FOREACH","text":"names = [\"Alice\", \"Bob\"]\n@cypher conn begin\n    p::Person\n    where(in(p.name, $names))\n    with(collect(p) => :people)\n    foreach(people => :n, begin\n        n.verified = true\n    end)\nend","category":"section"},{"location":"llm/#MERGE-with-conditional-SET","page":"Neo4jQuery.jl — LLM Reference","title":"MERGE with conditional SET","text":"result = @cypher conn begin\n    merge((p:Person))\n    on_create(p.created_at = $now)\n    on_match(p.last_seen = $now)\n    ret(p)\nend","category":"section"},{"location":"llm/#Delete","page":"Neo4jQuery.jl — LLM Reference","title":"Delete","text":"@cypher conn begin\n    (p:Person)\n    where(p.name == $target)\n    detach_delete(p)\nend","category":"section"},{"location":"llm/#Pagination","page":"Neo4jQuery.jl — LLM Reference","title":"Pagination","text":"result = @cypher conn begin\n    p::Person\n    ret(p.name => :name)\n    order(p.name)\n    skip($offset)\n    take($page_size)\nend","category":"section"},{"location":"llm/#Variable-length-paths","page":"Neo4jQuery.jl — LLM Reference","title":"Variable-length paths","text":"result = @cypher conn begin\n    (a:Person)-[r:KNOWS, 1, 3]->(b:Person)\n    ret(a.name => :start, b.name => :reachable)\nend","category":"section"},{"location":"llm/#CASE/WHEN","page":"Neo4jQuery.jl — LLM Reference","title":"CASE/WHEN","text":"result = @cypher conn begin\n    p::Person\n    ret(p.name => :name, if p.age > 65; \"senior\"; elseif p.age > 30; \"adult\"; else; \"young\"; end => :category)\nend","category":"section"},{"location":"llm/#EXISTS-subquery","page":"Neo4jQuery.jl — LLM Reference","title":"EXISTS subquery","text":"result = @cypher conn begin\n    p::Person\n    where(exists((p)-[:KNOWS]->(:Person)))\n    ret(p.name)\nend","category":"section"},{"location":"llm/#Regex-matching","page":"Neo4jQuery.jl — LLM Reference","title":"Regex matching","text":"result = @cypher conn begin\n    p::Person\n    where(matches(p.name, \"^A.*e\\$\"))\n    ret(p.name)\nend\n\n","category":"section"},{"location":"llm/#DSL-Known-Limitations","page":"Neo4jQuery.jl — LLM Reference","title":"DSL Known Limitations","text":"These Cypher features are not supported by the DSL:\n\nInline property patterns in MATCH ({name: $v}) — Julia's parser cannot parse {…}; use where() instead\nshortestPath / allShortestPaths\nProcedure calls via CALL db.xxx() (distinct from CALL subqueries)\nMap projections and list comprehensions (Cypher sense)\n\n","category":"section"},{"location":"llm/#Type-Mapping-(Typed-JSON)","page":"Neo4jQuery.jl — LLM Reference","title":"Type Mapping (Typed JSON)","text":"Neo4j Query API uses Typed JSON envelopes: {\"$type\": \"Integer\", \"_value\": \"42\"}.\n\nNeo4j Type Julia Type\nNull nothing\nBoolean Bool\nInteger Int64\nFloat Float64\nString String\nBase64 Vector{UInt8}\nList Vector\nMap JSON.Object\nDate Dates.Date\nTime Dates.Time\nLocalTime Dates.Time\nOffsetDateTime ZonedDateTime\nLocalDateTime DateTime\nDuration CypherDuration\nPoint CypherPoint\nNode Node\nRelationship Relationship\nPath Path\nVector CypherVector\n\nJulia→Neo4j serialization (to_typed_json): Julia values are wrapped in typed envelopes when sent as parameters.\n\n","category":"section"},{"location":"llm/#HTTP-Protocol-Details","page":"Neo4jQuery.jl — LLM Reference","title":"HTTP Protocol Details","text":"Content-Type: application/vnd.neo4j.query.v1.1 (Typed JSON)\nStreaming Accept: application/vnd.neo4j.query.v1.1+jsonl (JSONL)\nImplicit query endpoint: {base_url}/db/{database}/query/v2\nTransaction endpoint: {base_url}/db/{database}/query/v2/tx\nTransaction operations: POST .../tx (begin), POST .../tx/{id} (query), POST .../tx/{id}/commit, DELETE .../tx/{id} (rollback)\nCluster affinity via neo4j-cluster-affinity header (Aura)\n\n","category":"section"},{"location":"llm/#Source-File-Map","page":"Neo4jQuery.jl — LLM Reference","title":"Source File Map","text":"File Purpose\nsrc/Neo4jQuery.jl Module definition, includes, exports\nsrc/auth.jl BasicAuth, BearerAuth, auth_header\nsrc/connection.jl Neo4jConnection, connect, discovery\nsrc/cypher_macro.jl CypherQuery, @cypher_str\nsrc/env.jl dotenv, connect_from_env, URI parsing\nsrc/errors.jl Error types hierarchy\nsrc/query.jl query() for connections and CypherQuery\nsrc/request.jl HTTP helpers, error handling\nsrc/result.jl QueryResult, QueryCounters, Notification\nsrc/streaming.jl stream(), StreamingResult, summary\nsrc/transactions.jl Transaction, begin_transaction, commit!, etc.\nsrc/typed_json.jl Typed JSON (de)serialization\nsrc/types.jl Node, Relationship, Path, spatial/temporal\nsrc/dsl/schema.jl @node, @rel, PropertyDef, validation\nsrc/dsl/compile.jl AST→Cypher compilation (macro expansion time)\nsrc/dsl/mutations.jl @create, @merge, @relate\nsrc/dsl/cypher.jl @cypher macro (unified DSL)","category":"section"},{"location":"guide/dsl/#dsl","page":"DSL","title":"DSL","text":"Neo4jQuery includes a compile-time DSL that translates Julia expressions into parameterised Cypher. The unified @cypher macro gives you type-safe, injection-proof graph operations with Julia-native syntax.","category":"section"},{"location":"guide/dsl/#Schema-declarations","page":"DSL","title":"Schema declarations","text":"Register node and relationship schemas for validation:\n\n@node Person begin\n    name::String\n    age::Int\n    email::String = \"\"    # optional, with default\nend\n\n@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\nSchemas are stored in a global registry and used by mutation macros to validate properties at runtime.\n\nget_node_schema(:Person)\n\nget_rel_schema(:KNOWS)\n\nLabel-only schemas (no properties):\n\n@node Marker\n\n@rel LINKS","category":"section"},{"location":"guide/dsl/#Property-validation","page":"DSL","title":"Property validation","text":"Validation throws if required properties are missing and warns on unknown properties:\n\nschema = get_node_schema(:Person)\nvalidate_node_properties(schema, Dict{String,Any}(\"name\" => \"Alice\", \"age\" => 30))\nprintln(\"Node validation passed\")\n\nrel_schema = get_rel_schema(:KNOWS)\nvalidate_rel_properties(rel_schema, Dict{String,Any}(\"since\" => 2024))\nprintln(\"Relationship validation passed\")","category":"section"},{"location":"guide/dsl/#@cypher-—-the-unified-query-builder","page":"DSL","title":"@cypher — the unified query builder","text":"@cypher compiles a Julia block into a single parameterised Cypher query. It combines full Cypher coverage with ergonomic Julia-native syntax:\n\nresult = @cypher conn begin\n    p::Person >> r::KNOWS >> q::Person\n    where(p.age > $min_age, q.name == $target)\n    ret(p.name => :name, r.since, q.name => :friend)\n    order(p.age, :desc)\n    take(10)\nend\n\nThis expands at compile time into:\n\nMATCH (p:Person)-[r:KNOWS]->(q:Person)\nWHERE p.age > $min_age AND q.name = $target\nRETURN p.name AS name, r.since, q.name AS friend\nORDER BY p.age DESC\nLIMIT 10","category":"section"},{"location":"guide/dsl/#Pattern-syntax","page":"DSL","title":"Pattern syntax","text":"@cypher supports two pattern styles. Use whichever feels natural — they both compile to the same Cypher.","category":"section"},{"location":"guide/dsl/#chain-syntax-(recommended)","page":"DSL","title":">> chain syntax (recommended)","text":"The >> operator is the universal pattern connector. It works the same way in MATCH, CREATE, MERGE, and OPTIONAL MATCH.\n\n# Labeled node (Julia type annotation)\np::Person                    # → (p:Person)\n\n# Anonymous node\n::Person                     # → (:Person)\n\n# Right-directed chain\np::Person >> r::KNOWS >> q::Person\n# → (p:Person)-[r:KNOWS]->(q:Person)\n\n# Anonymous relationship in chain\np::Person >> KNOWS >> q::Person\n# → (p:Person)-[:KNOWS]->(q:Person)\n\n# Left-directed chain (<< operator)\np::Person << r::KNOWS << q::Person\n# → (p:Person)<-[r:KNOWS]-(q:Person)\n\n# Multi-hop chain\na::Person >> r::KNOWS >> b::Person >> s::WORKS_AT >> c::Company\n# → (a:Person)-[r:KNOWS]->(b:Person)-[s:WORKS_AT]->(c:Company)\n\n# Mixed-direction chain (>> and << in the same path)\n# Use >> for forward hops and << for backward hops.\n# Each relationship must be bracketed by the same operator:\n#   >> rel >>  for forward,  << rel <<  for backward.\ndr::Drug >> ::TREATS >> d::Disease << ::ASSOCIATED_WITH << g::Gene\n# → (dr:Drug)-[:TREATS]->(d:Disease)<-[:ASSOCIATED_WITH]-(g:Gene)\n\n# Longer mixed chains work with any number of direction changes\na::A >> ::R1 >> b::B << ::R2 << c::C >> ::R3 >> d::D\n# → (a:A)-[:R1]->(b:B)<-[:R2]-(c:C)-[:R3]->(d:D)","category":"section"},{"location":"guide/dsl/#Arrow-syntax","page":"DSL","title":"Arrow syntax","text":"The classic Cypher-like arrow syntax also works:\n\n# Right arrow (typed)\n(p:Person)-[r:KNOWS]->(q:Person)\n\n# Simple directed arrow\n(a) --> (b)\n\n# Left arrow (typed)\n(a:Person)<-[r:KNOWS]-(b:Person)\n\n# Undirected\n(a:Person)-[r:KNOWS]-(b:Person)\n\n# Variable-length\n(a:Person)-[r:KNOWS, 1, 3]->(b:Person)\n# → (a:Person)-[r:KNOWS*1..3]->(b:Person)\n\n# Chained path\n(a)-[r:R]->(b)-[s:S]->(c)\n\n# Multiple patterns (comma-separated)\nmatch((p:Person), (c:Company))","category":"section"},{"location":"guide/dsl/#Clause-functions","page":"DSL","title":"Clause functions","text":"All clauses use plain function-call syntax — no @ prefixes:\n\nFunction Cypher\nwhere(cond1, cond2, ...) WHERE cond1 AND cond2 AND ...\nret(expr => :alias, ...) RETURN expr AS alias, ...\nreturning(expr => :alias) RETURN expr AS alias (synonym for ret)\nret(distinct, expr) RETURN DISTINCT expr\norder(expr, :desc) ORDER BY expr DESC\ntake(n) / skip(n) LIMIT n / SKIP n\nmatch(p1, p2) MATCH p1, p2 (explicit multi-pattern)\noptional(pattern) OPTIONAL MATCH pattern\ncreate(pattern) CREATE pattern\nmerge(pattern) MERGE pattern\nwith(expr => :alias, ...) WITH expr AS alias, ...\nunwind($list => :var) UNWIND $list AS var\ndelete(vars...) DELETE vars\ndetach_delete(vars...) DETACH DELETE vars\non_create(p.prop = val) ON CREATE SET p.prop = val\non_match(p.prop = val) ON MATCH SET p.prop = val\nremove(p.prop) REMOVE p.prop\np.prop = $val (assignment) SET p.prop = $val (auto-detected)\nunion() UNION\nunion_all() UNION ALL\ncall(begin ... end) CALL { ... } subquery\nload_csv(url => :row) LOAD CSV FROM url AS row\nload_csv_headers(url => :row) LOAD CSV WITH HEADERS FROM url AS row\nforeach(var, :in, expr, begin ... end) FOREACH (var IN expr | ...)\ncreate_index(:Label, :prop) CREATE INDEX FOR (n:Label) ON (n.prop)\ndrop_index(:name) DROP INDEX name IF EXISTS\ncreate_constraint(:Label, :prop, :unique) CREATE CONSTRAINT ... IS UNIQUE\ndrop_constraint(:name) DROP CONSTRAINT name IF EXISTS","category":"section"},{"location":"guide/dsl/#Implicit-MATCH","page":"DSL","title":"Implicit MATCH","text":"Bare graph patterns in a @cypher block are automatically treated as MATCH clauses:\n\n@cypher conn begin\n    p::Person >> r::KNOWS >> q::Person    # implicit MATCH\n    where(p.age > 25)\n    ret(p.name, q.name)\nend","category":"section"},{"location":"guide/dsl/#WHERE-operators","page":"DSL","title":"WHERE operators","text":"Julia operators are translated to Cypher:\n\nJulia Cypher\n== =\n!= <>\n&& AND\n|| OR\n! NOT\n>=, <=, >, < >=, <=, >, <\nstartswith STARTS WITH\nendswith ENDS WITH\ncontains CONTAINS\nin / ∈ IN\nisnothing IS NULL\nmatches =~ (regex match)\nexists((p)-[:R]->(q)) EXISTS { MATCH ... }\nif ... elseif ... else ... end CASE WHEN ... THEN ... ELSE ... END\n\nArithmetic operators (+, -, *, /, %, ^) are also supported:\n\nwhere(p.score * 2 + 10 > $threshold)\nwhere(p.id % 2 == 0)\n\nMulti-condition WHERE auto-ANDs:\n\nwhere(p.age > 25, p.active == true, startswith(p.name, \"A\"))\n# → WHERE p.age > 25 AND p.active = true AND p.name STARTS WITH 'A'","category":"section"},{"location":"guide/dsl/#Parameter-capture","page":"DSL","title":"Parameter capture","text":"$var references capture Julia variables as safe Cypher parameters:\n\nmin_age = 25\nresult = @cypher conn begin\n    p::Person\n    where(p.age > $min_age)\n    ret(p.name => :name)\nend\n\nParameters work in where(), property assignments, unwind(), skip(), take(), and any expression position.","category":"section"},{"location":"guide/dsl/#Keyword-arguments","page":"DSL","title":"Keyword arguments","text":"Pass query options after the block:\n\nresult = @cypher conn begin\n    p::Person\n    ret(p.name)\nend include_counters=true\n\nnote: Automatic access_mode\n@cypher automatically sets access_mode=:read for pure read queries and access_mode=:write when any mutation clause is present (CREATE/MERGE/SET/DELETE/…). You rarely need to specify it manually. An explicit access_mode=:write (or :read) after end overrides the inferred value.","category":"section"},{"location":"guide/dsl/#Complete-end-to-end-example","page":"DSL","title":"Complete end-to-end example","text":"","category":"section"},{"location":"guide/dsl/#Step-1:-Define-your-graph-model","page":"DSL","title":"Step 1: Define your graph model","text":"@node Person begin\n    name::String\n    age::Int\n    email::String = \"\"\nend\n\n@node Company begin\n    name::String\n    founded::Int\n    industry::String = \"Technology\"\nend\n\n@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\n@rel WORKS_AT begin\n    role::String\n    since::Int\nend","category":"section"},{"location":"guide/dsl/#Step-2:-Create-nodes-using-schemas","page":"DSL","title":"Step 2: Create nodes using schemas","text":"alice = @create conn Person(name=\"Alice\", age=30, email=\"alice@example.com\")\n\nbob = @create conn Person(name=\"Bob\", age=25)\n\ncarol = @create conn Person(name=\"Carol\", age=35)\n\nacme = @create conn Company(name=\"Acme Corp\", founded=2010)","category":"section"},{"location":"guide/dsl/#Step-3:-Create-relationships","page":"DSL","title":"Step 3: Create relationships","text":"rel1 = @relate conn alice => KNOWS(since=2020) => bob\n\nrel2 = @relate conn alice => KNOWS(since=2022, weight=0.8) => carol\n\nrel3 = @relate conn bob => KNOWS(since=2023) => carol\n\n@relate conn alice => WORKS_AT(role=\"Engineer\", since=2021) => acme\n\n@relate conn bob => WORKS_AT(role=\"Designer\", since=2022) => acme","category":"section"},{"location":"guide/dsl/#Step-4:-Query-with-@cypher","page":"DSL","title":"Step 4: Query with @cypher","text":"min_age = 20\nresult = @cypher conn begin\n    p::Person >> r::KNOWS >> friend::Person\n    where(p.name == \"Alice\", friend.age > $min_age)\n    ret(friend.name => :name, r.since => :since)\n    order(r.since, :desc)\nend\n\nfor row in result\n    println(row.name, \" — known since \", row.since)\nend","category":"section"},{"location":"guide/dsl/#Step-5:-Aggregation-with-WITH","page":"DSL","title":"Step 5: Aggregation with WITH","text":"min_connections = 1\nresult = @cypher conn begin\n    p::Person >> r::KNOWS >> q::Person\n    with(p, count(r) => :degree)\n    where(degree > $min_connections)\n    order(degree, :desc)\n    ret(p.name => :person, degree)\nend","category":"section"},{"location":"guide/dsl/#Step-6:-Friend-of-friend-recommendations","page":"DSL","title":"Step 6: Friend-of-friend recommendations","text":"my_name = \"Bob\"\nresult = @cypher conn begin\n    (me:Person)-[:KNOWS]->(friend:Person)-[:KNOWS]->(fof:Person)\n    where(me.name == $my_name, fof.name != me.name)\n    ret(distinct, fof.name => :suggestion)\n    take(10)\nend","category":"section"},{"location":"guide/dsl/#Step-7:-Updating-data","page":"DSL","title":"Step 7: Updating data","text":"name = \"Alice\"\nnew_age = 31\nnew_email = \"alice@latest.com\"\n\nresult = @cypher conn begin\n    p::Person\n    where(p.name == $name)\n    p.age = $new_age           # auto-SET\n    p.email = $new_email       # merged into same SET clause\n    ret(p)\nend\n\nThis generates: MATCH (p:Person) WHERE p.name = $name SET p.age = $new_age, p.email = $new_email RETURN p","category":"section"},{"location":"guide/dsl/#Step-8:-MERGE-with-conditional-SET","page":"DSL","title":"Step 8: MERGE with conditional SET","text":"node = @merge conn Person(name=\"Alice\") on_create(age=30) on_match(last_seen=\"2025-02-15\")\n\nOr using @cypher for more complex patterns:\n\nnow = \"2025-02-15\"\nresult = @cypher conn begin\n    merge((p:Person))\n    on_create(p.created_at = $now)\n    on_match(p.last_seen = $now)\n    ret(p)\nend","category":"section"},{"location":"guide/dsl/#Step-9:-Batch-operations-with-UNWIND","page":"DSL","title":"Step 9: Batch operations with UNWIND","text":"people = [\n    Dict(\"name\" => \"Dave\", \"age\" => 28),\n    Dict(\"name\" => \"Eve\", \"age\" => 22),\n    Dict(\"name\" => \"Frank\", \"age\" => 40),\n]\n\nresult = @cypher conn begin\n    unwind($people => :person)\n    create((p:Person))\n    p.name = person.name\n    p.age = person.age\n    ret(p)\nend","category":"section"},{"location":"guide/dsl/#Step-10:-OPTIONAL-MATCH","page":"DSL","title":"Step 10: OPTIONAL MATCH","text":"result = @cypher conn begin\n    p::Person\n    optional(p >> w::WORKS_AT >> c::Company)\n    ret(p.name => :person, c.name => :company, w.role => :role)\n    order(p.name)\nend","category":"section"},{"location":"guide/dsl/#Step-11:-Pagination","page":"DSL","title":"Step 11: Pagination","text":"page = 2\npage_size = 10\noffset = (page - 1) * page_size\n\nresult = @cypher conn begin\n    p::Person\n    ret(p.name => :name, p.age => :age)\n    order(p.name)\n    skip($offset)\n    take($page_size)\nend","category":"section"},{"location":"guide/dsl/#Step-12:-Deleting-data","page":"DSL","title":"Step 12: Deleting data","text":"target = \"Frank\"\n@cypher conn begin\n    (p:Person)\n    where(p.name == $target)\n    detach_delete(p)\nend\n\n# Remove a property\nresult = @cypher conn begin\n    p::Person\n    remove(p.email)\n    ret(p)\nend","category":"section"},{"location":"guide/dsl/#Step-13:-Complex-WHERE-conditions","page":"DSL","title":"Step 13: Complex WHERE conditions","text":"result = @cypher conn begin\n    p::Person\n    where(startswith(p.name, \"A\"), !(isnothing(p.email)), p.age >= 18)\n    ret(p.name => :name, p.email => :email)\nend\n\n# IN operator with a parameter\nallowed_names = [\"Alice\", \"Bob\", \"Carol\"]\nresult = @cypher conn begin\n    p::Person\n    where(in(p.name, $allowed_names))\n    ret(p)\nend","category":"section"},{"location":"guide/dsl/#Step-14:-Aggregation-functions","page":"DSL","title":"Step 14: Aggregation functions","text":"result = @cypher conn begin\n    p::Person\n    ret(count(p) => :total, avg(p.age) => :avg_age, collect(p.name) => :names)\nend","category":"section"},{"location":"guide/dsl/#Step-15:-Pattern-direction-variants","page":"DSL","title":"Step 15: Pattern direction variants","text":"# Left-directed chain\nresult = @cypher conn begin\n    a::Person << r::KNOWS << b::Person\n    ret(a.name => :target, b.name => :source, r.since => :since)\nend\n\n# Arrow syntax (left arrow)\nresult = @cypher conn begin\n    (a:Person)<-[r:KNOWS]-(b:Person)\n    ret(a.name => :target, b.name => :source)\nend\n\n# Variable-length — find paths of 1 to 3 hops\nresult = @cypher conn begin\n    (a:Person)-[r:KNOWS, 1, 3]->(b:Person)\n    ret(a.name => :start, b.name => :reachable)\nend","category":"section"},{"location":"guide/dsl/#Step-16:-Regex-matching","page":"DSL","title":"Step 16: Regex matching","text":"result = @cypher conn begin\n    p::Person\n    where(matches(p.name, \"^A.*e\\$\"))\n    ret(p.name => :name)\nend","category":"section"},{"location":"guide/dsl/#Step-17:-CASE/WHEN-expressions","page":"DSL","title":"Step 17: CASE/WHEN expressions","text":"Use Julia's if/elseif/else/end syntax to generate Cypher CASE expressions:\n\nresult = @cypher conn begin\n    p::Person\n    ret(p.name => :name, if p.age > 65; \"senior\"; elseif p.age > 30; \"adult\"; else; \"young\"; end => :category)\nend\n\nGenerates:\n\nRETURN p.name AS name, CASE WHEN p.age > 65 THEN 'senior' WHEN p.age > 30 THEN 'adult' ELSE 'young' END AS category","category":"section"},{"location":"guide/dsl/#Step-18:-EXISTS-subqueries","page":"DSL","title":"Step 18: EXISTS subqueries","text":"result = @cypher conn begin\n    p::Person\n    where(exists((p)-[:KNOWS]->(:Person)))\n    ret(p.name => :name)\nend\n\n# Negated EXISTS\nresult = @cypher conn begin\n    p::Person\n    where(!(exists((p)-[:KNOWS]->(:Person))))\n    ret(p.name => :loner)\nend","category":"section"},{"location":"guide/dsl/#Step-19:-UNION-and-UNION-ALL","page":"DSL","title":"Step 19: UNION and UNION ALL","text":"Combine multiple query parts:\n\nresult = @cypher conn begin\n    p::Person\n    where(p.age > 30)\n    ret(p.name => :name)\n    union()\n    p::Person\n    where(startswith(p.name, \"A\"))\n    ret(p.name => :name)\nend\n\nresult = @cypher conn begin\n    p::Person\n    ret(p.name => :name)\n    union_all()\n    c::Company\n    ret(c.name => :name)\nend","category":"section"},{"location":"guide/dsl/#Step-20:-CALL-subqueries","page":"DSL","title":"Step 20: CALL subqueries","text":"Nest a full sub-query with call():\n\nresult = @cypher conn begin\n    p::Person\n    call(begin\n        with(p)\n        p >> r::KNOWS >> friend::Person\n        ret(count(friend) => :friend_count)\n    end)\n    ret(p.name => :name, friend_count)\n    order(friend_count, :desc)\nend","category":"section"},{"location":"guide/dsl/#Step-21:-LOAD-CSV","page":"DSL","title":"Step 21: LOAD CSV","text":"Import data from CSV files. The WITH HEADERS variant is recommended as it maps columns by name:\n\n# With headers (recommended)\n@cypher conn begin\n    load_csv_headers(\"file:///data/people.csv\" => :row)\n    create(p::Person)\n    p.name = row.name\n    p.age = row.age\nend\n\n# Without headers (row is a raw list)\n@cypher conn begin\n    load_csv(\"file:///data/people.csv\" => :row)\n    create(p::Person)\n    p.name = row\n    ret(p)\nend\n\nnote: Note\nLOAD CSV requires the CSV file to be accessible from the Neo4j server. For file:// URLs, the server must be configured with server.directories.import.","category":"section"},{"location":"guide/dsl/#Step-22:-FOREACH","page":"DSL","title":"Step 22: FOREACH","text":"Apply updates over a collection:\n\nnames = [\"Alice\", \"Bob\", \"Carol\"]\n@cypher conn begin\n    p::Person\n    where(in(p.name, $names))\n    with(collect(p) => :people)\n    foreach(people => :n, begin\n        n.verified = true\n    end)\nend\nprintln(\"FOREACH applied\")\n\nFOREACH body supports property assignments (auto-SET), create(), merge(), delete(), detach_delete(), remove(), and nested foreach().","category":"section"},{"location":"guide/dsl/#Step-23:-Index-and-constraint-management","page":"DSL","title":"Step 23: Index and constraint management","text":"@cypher conn begin\n    create_index(:Person, :name)\nend\nprintln(\"Index created\")\n\n# Named index\n@cypher conn begin\n    create_index(:Person, :email, :person_email_idx)\nend\nprintln(\"Named index created\")\n\n# Drop an index\n@cypher conn begin\n    drop_index(:person_email_idx)\nend\nprintln(\"Index dropped\")\n\n# Uniqueness constraint\n@cypher conn begin\n    create_constraint(:Person, :email, :unique)\nend\nprintln(\"Constraint created\")\n\n# NOT NULL constraint (named)\n@cypher conn begin\n    create_constraint(:Person, :name, :not_null, :person_name_required)\nend\nprintln(\"NOT NULL constraint created\")\n\n# Drop a constraint\n@cypher conn begin\n    drop_constraint(:person_name_required)\nend\nprintln(\"Constraint dropped\")","category":"section"},{"location":"guide/dsl/#Comprehension-form","page":"DSL","title":"Comprehension form","text":"For simple match-filter-return queries, use Julia's comprehension syntax:\n\nresult = @cypher conn [p.name for p in Person if p.age > 25]\n\nresult = @cypher conn [p for p in Person]\n\nresult = @cypher conn [(p.name, p.age) for p in Person]\n\nresult = @cypher conn [p.name => :n for p in Person]","category":"section"},{"location":"guide/dsl/#Known-limitations","page":"DSL","title":"Known limitations","text":"These Cypher features are not supported by the DSL:\n\nInline property patterns in MATCH ({name: $v}) — Julia's parser cannot parse {…} as an expression; use where() instead\nShortest path functions (shortestPath, allShortestPaths)\nProcedure calls via CALL db.xxx() (distinct from CALL subqueries)\nMap projections and list comprehensions in the Cypher sense","category":"section"},{"location":"guide/dsl/#Standalone-mutations","page":"DSL","title":"Standalone mutations","text":"For common single-entity operations, use the dedicated macros:","category":"section"},{"location":"guide/dsl/#@create-—-create-a-node","page":"DSL","title":"@create — create a node","text":"node = @create conn Person(name=\"Diana\", age=28)\n\nValidates against the registered Person schema (if present).","category":"section"},{"location":"guide/dsl/#@merge-—-upsert-a-node","page":"DSL","title":"@merge — upsert a node","text":"node = @merge conn Person(name=\"Diana\") on_create(age=28, email=\"d@b.com\") on_match(age=29)\n\nSimple merge without on_create/on_match:\n\nnode = @merge conn Person(name=\"Diana\", age=29)","category":"section"},{"location":"guide/dsl/#@relate-—-create-a-relationship","page":"DSL","title":"@relate — create a relationship","text":"diana = @create conn Person(name=\"Diana2\", age=28)\nedgar = @create conn Person(name=\"Edgar\", age=32)\n\nrel = @relate conn diana => KNOWS(since=2024) => edgar\n\nprintln(rel.type)\nprintln(rel[\"since\"])\n\nMatches nodes by elementId() and validates against the KNOWS schema (if registered).","category":"section"},{"location":"guide/queries/#queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"guide/queries/#Implicit-(auto-commit)-queries","page":"Queries","title":"Implicit (auto-commit) queries","text":"The simplest way to execute Cypher:\n\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name\")\n\nEvery call creates an implicit (auto-commit) transaction that opens and closes with a single request.","category":"section"},{"location":"guide/queries/#Parameters-with-@cypher_str-(recommended)","page":"Queries","title":"Parameters with @cypher_str (recommended)","text":"The cypher\"\" string macro automatically captures local variables as parameterised Cypher — no escaping, no boilerplate:\n\nname = \"Alice\"\nage = 30\nq = cypher\"CREATE (p:Person {name: $name, age: $age}) RETURN p\"\nresult = query(conn, q)\n\nThe macro produces a CypherQuery that carries both the parameterised statement and the captured bindings. This prevents Cypher injection and enables server-side query plan caching.\n\nMulti-parameter example:\n\nmin_age = 25\ncity = \"Berlin\"\nq = cypher\"MATCH (p:Person) WHERE p.age > $min_age AND p.city = $city RETURN p\"\nresult = query(conn, q; access_mode=:read)","category":"section"},{"location":"guide/queries/#Parameters-with-raw-strings","page":"Queries","title":"Parameters with raw strings","text":"If you prefer raw strings, pass a parameters dict.  Use \\$ to denote Neo4j parameter placeholders, or {{param}} Mustache-style placeholders to avoid escaping entirely:\n\n# Mustache-style (no escaping needed)\nresult = query(conn,\n    \"MATCH (p:Person {name: {{name}}}) RETURN p\",\n    parameters=Dict{String,Any}(\"name\" => \"Alice\"))\n\n# Traditional \\$-style\nresult = query(conn,\n    \"MATCH (p:Person) WHERE p.age > \\$min_age AND p.age < \\$max_age RETURN p.name AS name, p.age AS age\",\n    parameters=Dict{String,Any}(\"min_age\" => 20, \"max_age\" => 40);\n    access_mode=:read)","category":"section"},{"location":"guide/queries/#Options","page":"Queries","title":"Options","text":"Keyword Type Default Description\nparameters Dict{String,Any} Dict() Query parameters\naccess_mode Symbol :write :read or :write — server routing hint\ninclude_counters Bool false Include mutation statistics\nbookmarks Vector{String} String[] Causal consistency bookmarks\nimpersonated_user Union{String, Nothing} nothing Impersonate a different user","category":"section"},{"location":"guide/queries/#Working-with-results","page":"Queries","title":"Working with results","text":"QueryResult supports indexing, iteration, and standard Julia protocols:\n\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age ORDER BY p.name\")\n\n# Indexing\nfirst_row = result[1]\nprintln(\"First: \", first_row)\n\n# Fields\nprintln(\"Fields: \", result.fields)\n\n# Iteration\nfor row in result\n    println(row.name, \" — \", row.age)\nend\n\n# Comprehensions\nnames = [row.name for row in result]\nprintln(\"Names: \", names)\n\n# Standard functions\nprintln(\"Length: \", length(result))\nprintln(\"Empty? \", isempty(result))","category":"section"},{"location":"guide/queries/#Counters","page":"Queries","title":"Counters","text":"When include_counters=true, the result includes a QueryCounters struct:\n\nresult = query(conn, \"CREATE (n:Test) RETURN n\"; include_counters=true)\nc = result.counters\nprintln(\"Nodes created: \", c.nodes_created)\nprintln(\"Properties set: \", c.properties_set)\nprintln(\"Labels added: \", c.labels_added)\n\nAvailable counter fields: nodes_created, nodes_deleted, relationships_created, relationships_deleted, properties_set, labels_added, labels_removed, indexes_added, indexes_removed, constraints_added, constraints_removed, contains_updates, contains_system_updates, system_updates.","category":"section"},{"location":"guide/queries/#Bookmarks","page":"Queries","title":"Bookmarks","text":"Every result carries bookmarks for causal consistency across queries:\n\nr1 = query(conn, \"CREATE (n:Test)\")\nr2 = query(conn, \"MATCH (n:Test) RETURN n\"; bookmarks=r1.bookmarks)\nprintln(\"Bookmarks: \", length(r2.bookmarks), \" bookmark(s)\")\nprintln(\"Test nodes found: \", length(r2))","category":"section"},{"location":"guide/queries/#Notifications","page":"Queries","title":"Notifications","text":"The server may attach performance warnings or deprecation hints:\n\nresult = query(conn, \"MATCH (a), (b) RETURN a, b\")\nfor n in result.notifications\n    println(n.severity, \": \", n.title)\n    println(\"  \", n.description)\nend\nprintln(\"Notifications: \", length(result.notifications))","category":"section"},{"location":"guide/queries/#Graph-types","page":"Queries","title":"Graph types","text":"Nodes, relationships, and paths are returned as rich Julia structs:\n\nresult = query(conn, \"MATCH (p:Person)-[r:KNOWS]->(q) RETURN p, r, q\")\nrow = result[1]\n\nnode = row.p\nprintln(\"Node: \", node)\nprintln(\"Labels: \", node.labels)\nprintln(\"Name: \", node[\"name\"])\n\nrel = row.r\nprintln(\"Rel type: \", rel.type)\nprintln(\"Since: \", rel[\"since\"])","category":"section"},{"location":"guide/queries/#Paths","page":"Queries","title":"Paths","text":"result = query(conn, \"\"\"\n    MATCH path = (a:Person)-[:KNOWS*1..3]->(b:Person)\n    WHERE a.name = 'Alice'\n    RETURN path\n\"\"\"; access_mode=:read)\n\np = result[1].path\nprintln(\"Path: \", p)\nprintln(\"Elements: \", p.elements)","category":"section"},{"location":"guide/queries/#Spatial-values","page":"Queries","title":"Spatial values","text":"result = query(conn, \"RETURN point({latitude: 51.5, longitude: -0.1}) AS pt\")\npt = result[1].pt\nprintln(\"SRID: \", pt.srid)\nprintln(\"Coordinates: \", pt.coordinates)","category":"section"},{"location":"guide/queries/#Duration-values","page":"Queries","title":"Duration values","text":"result = query(conn, \"RETURN duration('P1Y2M3DT4H') AS d\")\nd = result[1].d\nprintln(\"Duration: \", d.value)","category":"section"},{"location":"#Neo4jQuery.jl","page":"Home","title":"Neo4jQuery.jl","text":"A modern Julia client for Neo4j using the Query API v2.\n\n(Image: Build Status) (Image: Documentation (stable)) (Image: Documentation (dev)) (Image: codecov) (Image: Aqua QA) (Image: JET)","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Query API v2 — uses Neo4j's modern HTTP endpoint with Typed JSON for lossless data exchange.\nParameterised Cypher — the @cypher_str macro captures local variables as safe query parameters, preventing injection and enabling server-side caching.\nExplicit & implicit transactions — both auto-commit queries and full begin/commit/rollback lifecycle with a convenient do-block API.\nStreaming results — row-by-row iteration over JSONL responses for memory-efficient processing of large result sets.\nRich type mapping — automatic round-trip conversion between Julia types (Int64, Float64, Date, DateTime, ZonedDateTime, …) and Neo4j's type system, including spatial (CypherPoint), temporal (CypherDuration), and vector (CypherVector) values.\nGraph DSL — the unified @cypher macro plus @create, @merge, and @relate let you write Julia-native graph operations that compile to parameterised Cypher at macro-expansion time. @cypher offers >> chain operators, bare type annotations, function-call clauses, auto-SET, and comprehension forms.\nFull Cypher coverage — directed, left-arrow, and undirected patterns; variable-length relationships; CASE/WHEN expressions; EXISTS subqueries; regex matching (matches()); UNION/UNION ALL; CALL subqueries; LOAD CSV; FOREACH; and index/constraint management.\nSchema declarations — @node and @rel register typed schemas with validation for safer graph mutations.\nFlexible authentication — BasicAuth (HTTP Basic) and BearerAuth (token) with an extension point for custom strategies.\nEnvironment configuration — connect_from_env loads credentials from .env files or environment variables with automatic URI scheme parsing.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Neo4jQuery\n\n# Connect\nconn = connect(\"localhost\", \"neo4j\"; port=7474, auth=BasicAuth(\"neo4j\", \"password\"))\n\n# Query\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\nfor row in result\n    println(\"\\$(row.name) is \\$(row.age) years old\")\nend\n\n# Parameterised query\nname = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p\"\nresult = query(conn, q)\n\nSee the Getting Started guide for installation instructions and a more complete walkthrough.","category":"section"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/connections.md\",\n    \"guide/queries.md\",\n    \"guide/transactions.md\",\n    \"guide/streaming.md\",\n    \"guide/dsl.md\",\n    \"guide/biomedical_case_study.md\",\n    \"api.md\",\n]\nDepth = 1","category":"section"},{"location":"guide/streaming/#streaming","page":"Streaming","title":"Streaming","text":"For large result sets, streaming avoids loading all rows into memory at once. Results arrive as JSONL (one JSON object per line) and are parsed lazily.","category":"section"},{"location":"guide/streaming/#Basic-usage","page":"Streaming","title":"Basic usage","text":"sr = stream(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\n\nfor row in sr\n    println(row.name, \" — \", row.age)\nend\n\nEach iterate call reads and parses the next row from the HTTP response body.","category":"section"},{"location":"guide/streaming/#Streaming-in-transactions","page":"Streaming","title":"Streaming in transactions","text":"# Implicit transaction\nsr = stream(conn, \"MATCH (p) RETURN p\"; access_mode=:read)\ncollect(sr)  # consume the stream\nprintln(\"Streamed \", length(collect(stream(conn, \"MATCH (p) RETURN p\"; access_mode=:read))), \" rows\")\n\n# Explicit transaction\ntx = begin_transaction(conn)\nsr = stream(tx, \"MATCH (p) RETURN p\")\nrows = collect(sr)\ncommit!(tx)\nprintln(\"Streamed \", length(rows), \" rows in transaction\")","category":"section"},{"location":"guide/streaming/#Options","page":"Streaming","title":"Options","text":"stream accepts the same keyword arguments as query:\n\nKeyword Description\nparameters Query parameters\naccess_mode :read or :write\ninclude_counters Include mutation counters in summary\nbookmarks Causal consistency bookmarks\nimpersonated_user User impersonation","category":"section"},{"location":"guide/streaming/#Summary","page":"Streaming","title":"Summary","text":"After fully consuming the stream, call summary to get metadata:\n\nsr = stream(conn, \"MATCH (p:Person) RETURN p\")\nrows = collect(sr)   # consume all rows\n\ns = summary(sr)\nprintln(\"Bookmarks: \", length(s.bookmarks))\n\nnote: Note\nsummary must be explicitly imported with import Neo4jQuery: summary because Base.summary takes precedence over the re-exported name. Alternatively, use the qualified form Neo4jQuery.summary(sr).\n\nwarning: Warning\nsummary is only available after the stream has been fully consumed. Calling it mid-stream will block until all remaining rows are read.","category":"section"},{"location":"guide/streaming/#Collecting-rows","page":"Streaming","title":"Collecting rows","text":"You can materialize the entire stream with collect:\n\nsr = stream(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\nrows = collect(sr)\n\n# rows is a Vector; use normal Julia operations\nnames = [r.name for r in rows]\nages  = [r.age  for r in rows]\nprintln(\"Names: \", names)\nprintln(\"Ages: \", ages)","category":"section"},{"location":"guide/streaming/#Streaming-with-parameters","page":"Streaming","title":"Streaming with parameters","text":"# Recommended: use cypher\"\" for parameterised streaming\nmin_age = 25\nsr = stream(conn, cypher\"MATCH (p:Person) WHERE p.age > $min_age RETURN p.name AS name\")\n\nfor row in sr\n    println(row.name)\nend\n\n# Also works: raw string with parameters dict\nsr = stream(conn, \"MATCH (p:Person) WHERE p.age > \\$min_age RETURN p.name AS name\",\n    parameters=Dict{String,Any}(\"min_age\" => 25))\n\nfor row in sr\n    println(row.name)\nend","category":"section"},{"location":"guide/streaming/#Streaming-inside-a-transaction","page":"Streaming","title":"Streaming inside a transaction","text":"Streaming works within explicit transactions for multi-step workflows:\n\ntransaction(conn) do tx\n    # Step 1: create a node\n    query(tx, \"CREATE (p:Person {name: 'Diana', age: 28})\")\n\n    # Step 2: stream results from the same transaction\n    sr = stream(tx, \"MATCH (p:Person) RETURN p.name AS name\")\n    for row in sr\n        println(\"Found: \", row.name)\n    end\nend","category":"section"},{"location":"guide/streaming/#CypherQuery-support","page":"Streaming","title":"CypherQuery support","text":"name = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p\"\nsr = stream(conn, q)\n\nfor row in sr\n    println(row.p)\nend","category":"section"},{"location":"guide/streaming/#StreamingResult-details","page":"Streaming","title":"StreamingResult details","text":"A StreamingResult tracks its consumption state:\n\nField Type Description\nfields Vector Column names\nconsumed Bool true after all rows have been read\n_summary internal Populated after consumption; access via summary\n\nThe iterator protocol (Base.iterate) is implemented, so streaming results work with for loops, collect, comprehensions, and any iterator combinator.","category":"section"},{"location":"guide/connections/#connections","page":"Connections","title":"Connections","text":"Neo4jQuery connects to Neo4j over HTTP using the Query API v2.","category":"section"},{"location":"guide/connections/#connect","page":"Connections","title":"connect","text":"conn = connect(host, database;\n    port=7474,\n    auth=BasicAuth(\"neo4j\", \"password\"),\n    scheme=\"http\")\n\nOn construction the client hits the discovery endpoint (GET /) to verify the server is reachable.\n\nArguments:\n\nParameter Type Default Description\nhost String required Hostname or IP\ndatabase String required Database name (e.g. \"neo4j\")\nport Int 7474 HTTP port\nauth AbstractAuth required Authentication strategy\nscheme String \"http\" \"http\" or \"https\"","category":"section"},{"location":"guide/connections/#connect_from_env","page":"Connections","title":"connect_from_env","text":"Loads connection details from environment variables, optionally reading them from a .env file first:\n\nconn = connect_from_env()\nprintln(conn)\n\nExpected variables (with default prefix NEO4J_):\n\nVariable Description\nNEO4J_URI Full URI, e.g. neo4j+s://xxx.databases.neo4j.io\nNEO4J_USERNAME Username\nNEO4J_PASSWORD Password\nNEO4J_DATABASE Database name\n\nThe URI scheme is parsed to determine HTTP vs HTTPS:\n\nneo4j+s://, bolt+s://, https:// → HTTPS\nneo4j://, bolt://, http:// → HTTP","category":"section"},{"location":"guide/connections/#Authentication","page":"Connections","title":"Authentication","text":"Two strategies are available:\n\n# HTTP Basic Auth (RFC 7617)\nauth = BasicAuth(\"neo4j\", \"password\")\nprintln(auth)\n\n# Bearer token auth\nauth = BearerAuth(\"eyJhbGciOi...\")\nprintln(auth)\n\nBoth produce an Authorization header used on every request. Implement auth_header(::YourAuth) for custom strategies.","category":"section"},{"location":"guide/connections/#The-dotenv-helper","page":"Connections","title":"The dotenv helper","text":"You can load .env files independently:\n\nvars = dotenv(\".env\"; overwrite=false)\n\nSupports comments (#), quoted values, and export prefix. Existing ENV keys are preserved unless overwrite=true.","category":"section"},{"location":"guide/connections/#.env-file-format","page":"Connections","title":".env file format","text":"# Comment lines are ignored\nNEO4J_URI=neo4j+s://xxx.databases.neo4j.io\nNEO4J_USERNAME=neo4j\nNEO4J_PASSWORD=secret\nNEO4J_DATABASE=neo4j\n\n# Quoted values (quotes are stripped)\nNEO4J_PASSWORD=\"my secret password\"\nNEO4J_PASSWORD='my secret password'\n\n# \"export\" prefix is supported\nexport NEO4J_URI=neo4j://localhost","category":"section"},{"location":"guide/connections/#URI-scheme-mapping","page":"Connections","title":"URI scheme mapping","text":"The scheme in NEO4J_URI is mapped to HTTP or HTTPS:\n\nURI Scheme Protocol Default Port\nneo4j:// HTTP 7474\nbolt:// HTTP 7474\nhttp:// HTTP 7474\nneo4j+s:// HTTPS 443\nneo4j+ssc:// HTTPS 443\nbolt+s:// HTTPS 443\nbolt+ssc:// HTTPS 443\nhttps:// HTTPS 443","category":"section"},{"location":"guide/connections/#Custom-authentication","page":"Connections","title":"Custom authentication","text":"To implement a custom auth strategy, define a struct that subtypes AbstractAuth and implement auth_header:\n\nstruct ApiKeyAuth <: Neo4jQuery.AbstractAuth\n    key::String\nend\n\nNeo4jQuery.auth_header(a::ApiKeyAuth) = \"ApiKey $(a.key)\"\n\nconn = connect(\"localhost\", \"neo4j\"; auth=ApiKeyAuth(\"my-api-key\"))","category":"section"},{"location":"guide/connections/#Verifying-a-connection","page":"Connections","title":"Verifying a connection","text":"connect hits the discovery endpoint on construction. If the server is unreachable, it will throw an error immediately:\n\ntry\n    conn = connect(\"localhost\", \"neo4j\"; auth=BasicAuth(\"neo4j\", \"pw\"))\n    println(\"Connected to: \", conn.host)\ncatch e\n    println(\"Connection failed: \", e)\nend","category":"section"},{"location":"guide/connections/#Displaying-a-connection","page":"Connections","title":"Displaying a connection","text":"conn = connect(\"localhost\", \"neo4j\"; auth=BasicAuth(\"neo4j\", \"pw\"))\nprintln(conn)  # Neo4jConnection(http://localhost:7474, db=neo4j)","category":"section"}]
}
