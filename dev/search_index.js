var documenterSearchIndex = {"docs":
[{"location":"guide/transactions/#transactions","page":"Transactions","title":"Transactions","text":"Neo4jQuery supports both implicit (auto-commit) and explicit transactions.","category":"section"},{"location":"guide/transactions/#Explicit-transactions","page":"Transactions","title":"Explicit transactions","text":"Open a transaction, run multiple queries, then commit or rollback:\n\ntx = begin_transaction(conn)\n\nquery(tx, \"CREATE (a:Account {name: \\$name})\",\n    parameters=Dict{String,Any}(\"name\" => \"Savings\"))\nquery(tx, \"CREATE (a:Account {name: \\$name})\",\n    parameters=Dict{String,Any}(\"name\" => \"Checking\"))\n\nbookmarks = commit!(tx)","category":"section"},{"location":"guide/transactions/#Rollback","page":"Transactions","title":"Rollback","text":"tx = begin_transaction(conn)\nquery(tx, \"CREATE (n:Temp)\")\nrollback!(tx)\n# The Temp node never persists","category":"section"},{"location":"guide/transactions/#Initial-statement","page":"Transactions","title":"Initial statement","text":"begin_transaction accepts an optional initial statement:\n\ntx = begin_transaction(conn;\n    statement=\"CREATE (n:Init) RETURN n\",\n    parameters=Dict{String,Any}())","category":"section"},{"location":"guide/transactions/#Final-statement-on-commit","page":"Transactions","title":"Final statement on commit","text":"commit! can run a final statement atomically with the commit:\n\nbookmarks = commit!(tx;\n    statement=\"CREATE (n:Final) RETURN n\",\n    parameters=Dict{String,Any}())","category":"section"},{"location":"guide/transactions/#Do-block-(recommended)","page":"Transactions","title":"Do-block (recommended)","text":"The safest pattern — auto-commits on success, auto-rolls-back on exception:\n\ntransaction(conn) do tx\n    query(tx, \"CREATE (a:Person {name: 'Alice'})\")\n    query(tx, \"CREATE (b:Person {name: 'Bob'})\")\n    query(tx, \"\"\"\n        MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n        CREATE (a)-[:KNOWS]->(b)\n    \"\"\")\nend\n\nIf any exception occurs inside the block, the transaction is automatically rolled back before the exception propagates:\n\ntry\n    transaction(conn) do tx\n        query(tx, \"CREATE (n:Temp)\")\n        error(\"something went wrong\")\n    end\ncatch e\n    # Transaction was rolled back — no :Temp node was created\nend","category":"section"},{"location":"guide/transactions/#Transaction-state","page":"Transactions","title":"Transaction state","text":"The Transaction struct tracks its lifecycle:\n\ntx = begin_transaction(conn)\n# tx.committed == false, tx.rolled_back == false\n\ncommit!(tx)\n# tx.committed == true\n\n# Subsequent queries on a committed/rolled-back tx will error","category":"section"},{"location":"api/#api-reference","page":"API Reference","title":"API Reference","text":"Full reference for all public types and functions.","category":"section"},{"location":"api/#Connection","page":"API Reference","title":"Connection","text":"","category":"section"},{"location":"api/#Authentication","page":"API Reference","title":"Authentication","text":"","category":"section"},{"location":"api/#Environment","page":"API Reference","title":"Environment","text":"","category":"section"},{"location":"api/#Query","page":"API Reference","title":"Query","text":"","category":"section"},{"location":"api/#Transactions","page":"API Reference","title":"Transactions","text":"","category":"section"},{"location":"api/#Streaming","page":"API Reference","title":"Streaming","text":"","category":"section"},{"location":"api/#Result-Types","page":"API Reference","title":"Result Types","text":"","category":"section"},{"location":"api/#Graph-Types","page":"API Reference","title":"Graph Types","text":"","category":"section"},{"location":"api/#Errors","page":"API Reference","title":"Errors","text":"","category":"section"},{"location":"api/#DSL-—-Schema","page":"API Reference","title":"DSL — Schema","text":"","category":"section"},{"location":"api/#DSL-—-Macros","page":"API Reference","title":"DSL — Macros","text":"","category":"section"},{"location":"api/#Neo4jQuery.Neo4jConnection","page":"API Reference","title":"Neo4jQuery.Neo4jConnection","text":"Neo4jConnection\n\nRepresents a connection to a Neo4j database via the Query API v2.\n\nCreate one with connect rather than calling the constructor directly.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.connect","page":"API Reference","title":"Neo4jQuery.connect","text":"connect(host, database; port=7474, auth, scheme=\"http\") -> Neo4jConnection\n\nEstablish a connection to a Neo4j instance.  Validates connectivity by hitting the discovery endpoint (GET /).\n\nExample\n\nconn = connect(\"localhost\", \"neo4j\"; auth=BasicAuth(\"neo4j\", \"password\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.connect_from_env","page":"API Reference","title":"Neo4jQuery.connect_from_env","text":"connect_from_env(; path=\".env\", prefix=\"NEO4J_\") -> Neo4jConnection\n\nConvenience constructor that loads credentials from environment variables (optionally reading a .env file first) and returns a ready-to-use connection.\n\nExpected variables (with default NEO4J_ prefix):\n\nNEO4J_URI      — full URI, e.g. neo4j+s://xxx.databases.neo4j.io\nNEO4J_USERNAME — e.g. neo4j\nNEO4J_PASSWORD — the password\nNEO4J_DATABASE — e.g. neo4j  (defaults to \"neo4j\" if unset)\n\nThe URI scheme is mapped automatically:\n\nneo4j+s://, neo4j+ssc:// → HTTPS (port 443)\nneo4j://, bolt:// → HTTP (port 7474)\n\nExample\n\nconn = connect_from_env()                    # reads .env, connects\nconn = connect_from_env(path=\"prod.env\")     # different file\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.AbstractAuth","page":"API Reference","title":"Neo4jQuery.AbstractAuth","text":"AbstractAuth\n\nAbstract type for authentication strategies used to authorize Neo4j requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.BasicAuth","page":"API Reference","title":"Neo4jQuery.BasicAuth","text":"BasicAuth(username::String, password::String)\n\nHTTP Basic authentication (RFC 7617).  Generates an Authorization: Basic … header from the supplied credentials.\n\nExample\n\nauth = BasicAuth(\"neo4j\", \"verysecret\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.BearerAuth","page":"API Reference","title":"Neo4jQuery.BearerAuth","text":"BearerAuth(token::String)\n\nHTTP Bearer-token authentication.  Generates an Authorization: Bearer … header from the supplied token.\n\nExample\n\nauth = BearerAuth(\"xbhkjnlvianztghqwawxqfe\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.dotenv","page":"API Reference","title":"Neo4jQuery.dotenv","text":"dotenv(path=\".env\"; overwrite=false) -> Dict{String,String}\n\nParse a .env file and load its key-value pairs into ENV. Returns the parsed dictionary.\n\nLines starting with # are treated as comments and ignored. Empty lines are skipped.  Values may optionally be quoted with \" or '.\n\nIf overwrite is false (default), existing ENV entries are not overwritten—the file values serve as defaults.\n\nExample\n\ndotenv()                        # loads .env from current directory\ndotenv(\"config/.env.test\")      # loads a specific file\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.query","page":"API Reference","title":"Neo4jQuery.query","text":"query(conn, statement; parameters, access_mode, include_counters, bookmarks, impersonated_user) -> QueryResult\n\nExecute a Cypher statement against the database using an implicit transaction.\n\nArguments\n\nconn::Neo4jConnection — the connection to use.\nstatement::String — the Cypher query text.\n\nKeyword Arguments\n\nparameters::Dict{String,Any}=Dict{String,Any}() — query parameters.\naccess_mode::Symbol=:write — :read or :write for cluster routing.\ninclude_counters::Bool=false — whether to request query counters.\nbookmarks::Vector{String}=String[] — bookmarks for causal consistency.\nimpersonated_user::Union{String,Nothing}=nothing — run as another user.\n\nExample\n\nresult = query(conn, \"MATCH (n:Person) RETURN n.name AS name LIMIT 10\")\nfor row in result\n    println(row.name)\nend\n\n\n\n\n\nquery(conn, q::CypherQuery; kwargs...) -> QueryResult\n\nExecute a CypherQuery (typically from the @cypher_str macro). Parameters from the CypherQuery are merged with any extra parameters kwarg (the kwarg takes precedence on conflicts).\n\n\n\n\n\nquery(tx::Transaction, statement; parameters, include_counters) -> QueryResult\n\nExecute a Cypher statement inside an open transaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.CypherQuery","page":"API Reference","title":"Neo4jQuery.CypherQuery","text":"CypherQuery\n\nA Cypher query statement together with its parameter bindings.  Typically constructed via the @cypher_str string macro.\n\nFields\n\nstatement::String — the Cypher text (with $param placeholders)\nparameters::Dict{String,Any} — parameter name → Julia value\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.@cypher_str","page":"API Reference","title":"Neo4jQuery.@cypher_str","text":"@cypher_str -> CypherQuery\n\nCreate a CypherQuery from a Cypher string literal, automatically capturing local variables referenced with $ as query parameters.\n\nJulia does not interpolate $ inside non-standard string literals, so the $ is passed through verbatim and the macro can detect it as a Cypher parameter reference.\n\nExample\n\nname = \"Alice\"\nage  = 42\nq = cypher\"MATCH (n:Person {name: $name, age: $age}) RETURN n\"\n# CypherQuery(\"MATCH (n:Person {name: $name, age: $age}) RETURN n\", 2 parameters)\n# q.parameters == Dict(\"name\" => \"Alice\", \"age\" => 42)\n\nThe resulting query uses parameterised Cypher, which is both safer (no injection) and faster (query plan caching).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.Transaction","page":"API Reference","title":"Neo4jQuery.Transaction","text":"Transaction\n\nAn explicit Neo4j transaction.  Obtain one via begin_transaction or the transaction do-block helper.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.begin_transaction","page":"API Reference","title":"Neo4jQuery.begin_transaction","text":"begin_transaction(conn; statement=nothing, parameters=Dict{String,Any}()) -> Transaction\n\nOpen a new explicit transaction, optionally executing an initial statement.\n\nExample\n\ntx = begin_transaction(conn)\nresult = query(tx, \"CREATE (n:Person {name: 'Alice'}) RETURN n\")\ncommit!(tx)\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.commit!","page":"API Reference","title":"Neo4jQuery.commit!","text":"commit!(tx; statement=nothing, parameters=Dict{String,Any}()) -> Vector{String}\n\nCommit an open transaction, optionally executing a final statement. Returns the bookmarks from the committed transaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.rollback!","page":"API Reference","title":"Neo4jQuery.rollback!","text":"rollback!(tx::Transaction) -> Nothing\n\nRoll back an open transaction, discarding all changes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.transaction","page":"API Reference","title":"Neo4jQuery.transaction","text":"transaction(f, conn; kwargs...) -> result\n\nExecute f(tx) inside an explicit transaction.  The transaction is committed if f returns normally, or rolled back if an exception is thrown.\n\nExample\n\ntransaction(conn) do tx\n    query(tx, \"CREATE (a:Person {name: 'Alice'})\")\n    query(tx, \"CREATE (b:Person {name: 'Bob'})\")\nend  # auto-commit\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.stream","page":"API Reference","title":"Neo4jQuery.stream","text":"stream(conn, statement; parameters, access_mode, bookmarks, impersonated_user) -> StreamingResult\n\nExecute a Cypher query with streaming enabled.  Returns a StreamingResult that yields NamedTuple rows via iteration.\n\nExample\n\nfor row in stream(conn, \"MATCH (n:Person) RETURN n.name AS name\")\n    println(row.name)\nend\n\n\n\n\n\nstream(tx::Transaction, statement; parameters) -> StreamingResult\n\nExecute a streaming query inside an existing explicit transaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.StreamingResult","page":"API Reference","title":"Neo4jQuery.StreamingResult","text":"StreamingResult\n\nAn in-progress streaming query result.  Implements Julia's iteration protocol so records can be consumed with a for loop:\n\nfor row in stream(conn, \"MATCH (n) RETURN n.name AS name\")\n    println(row.name)\nend\n\nAfter iteration completes (or is interrupted), call summary to retrieve bookmarks, counters, and notifications.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.summary","page":"API Reference","title":"Neo4jQuery.summary","text":"summary(sr::StreamingResult) -> NamedTuple\n\nAccess bookmarks, counters, notifications, and query plans after the stream has been consumed.  Returns a NamedTuple with keys:\n\nbookmarks::Vector{String}\ncounters::Union{QueryCounters, Nothing}\nnotifications::Vector{Notification}\ntransaction::Union{JSON.Object, Nothing}\nquery_plan::Union{JSON.Object, Nothing}\nprofiled_query_plan::Union{JSON.Object, Nothing}\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.QueryResult","page":"API Reference","title":"Neo4jQuery.QueryResult","text":"QueryResult\n\nThe result of a Cypher query.  Supports iteration and indexing—each row is a NamedTuple whose keys match the query's field names.\n\nIteration\n\nfor row in result\n    println(row.name, \" is \", row.age, \" years old\")\nend\n\nIndexing\n\nresult[1]          # first row as NamedTuple\nresult[end]        # last row\nlength(result)     # number of rows\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.QueryCounters","page":"API Reference","title":"Neo4jQuery.QueryCounters","text":"QueryCounters\n\nStatistics about database changes performed by a query.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Notification","page":"API Reference","title":"Neo4jQuery.Notification","text":"Notification\n\nA server notification (performance warning, deprecation hint, etc.) attached to a query response.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Node","page":"API Reference","title":"Neo4jQuery.Node","text":"Node\n\nA Neo4j graph node with an element ID, labels, and a property map.\n\nProperty access is supported via both indexing and dot syntax:\n\nnode[\"name\"]   # indexing\nnode.name      # dot syntax\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Relationship","page":"API Reference","title":"Neo4jQuery.Relationship","text":"Relationship\n\nA Neo4j graph relationship with an element ID, start/end node element IDs, a type string, and a property map.\n\nrel[\"since\"]   # indexing\nrel.since      # dot syntax\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Path","page":"API Reference","title":"Neo4jQuery.Path","text":"Path\n\nA Neo4j graph path—an alternating sequence of Node and Relationship objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherPoint","page":"API Reference","title":"Neo4jQuery.CypherPoint","text":"CypherPoint\n\nA Cypher spatial point value.  Stored as an SRID integer and a coordinate vector. Serialised on the wire as a WKT string, e.g. \"SRID=7203;POINT (1.2 3.4)\".\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherDuration","page":"API Reference","title":"Neo4jQuery.CypherDuration","text":"CypherDuration\n\nA Cypher duration value.  Stored as the original ISO-8601 string (e.g. \"P14DT16H12M\").\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherVector","page":"API Reference","title":"Neo4jQuery.CypherVector","text":"CypherVector\n\nA Neo4j vector value (Enterprise Edition).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Neo4jError","page":"API Reference","title":"Neo4jQuery.Neo4jError","text":"Neo4jError <: Exception\n\nAbstract base type for all Neo4j-related errors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.AuthenticationError","page":"API Reference","title":"Neo4jQuery.AuthenticationError","text":"AuthenticationError <: Neo4jError\n\nRaised when the server returns HTTP 401 (missing, incorrect, or invalid credentials).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Neo4jQueryError","page":"API Reference","title":"Neo4jQuery.Neo4jQueryError","text":"Neo4jQueryError <: Neo4jError\n\nRaised when the server response contains an errors array (query syntax errors, constraint violations, etc.).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.TransactionExpiredError","page":"API Reference","title":"Neo4jQuery.TransactionExpiredError","text":"TransactionExpiredError <: Neo4jError\n\nRaised when a request targets a transaction that has already expired or been rolled back on the server side.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.PropertyDef","page":"API Reference","title":"Neo4jQuery.PropertyDef","text":"PropertyDef\n\nA single property definition within a node or relationship schema.\n\nFields\n\nname::Symbol — property name\ntype::Symbol — Julia type name (e.g. :String, :Int)\nrequired::Bool — whether the property must be supplied on creation\ndefault — default value for optional properties, or nothing for required\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.NodeSchema","page":"API Reference","title":"Neo4jQuery.NodeSchema","text":"NodeSchema\n\nSchema descriptor for a Neo4j node label, created by the @node macro.\n\nFields\n\nlabel::Symbol — the Neo4j label (e.g. :Person)\nproperties::Vector{PropertyDef} — typed property definitions\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.RelSchema","page":"API Reference","title":"Neo4jQuery.RelSchema","text":"RelSchema\n\nSchema descriptor for a Neo4j relationship type, created by the @rel macro.\n\nFields\n\nreltype::Symbol — the relationship type (e.g. :KNOWS)\nproperties::Vector{PropertyDef} — typed property definitions\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.@node","page":"API Reference","title":"Neo4jQuery.@node","text":"@node Name begin\n    field::Type\n    optional_field::Type = default_value\nend\n\nDeclare a node schema with label Name and typed properties.\n\nCreates a constant Name::NodeSchema and registers it for runtime validation in @create and @merge operations.\n\nExample\n\n@node Person begin\n    name::String\n    age::Int\n    email::String = \"\"\nend\n\n# Person is now a NodeSchema constant\nPerson.label       # :Person\nPerson.properties  # [PropertyDef(:name, :String, true, nothing), ...]\n\n\n\n\n\n@node Name\n\nDeclare a node schema with no properties (label-only).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@rel","page":"API Reference","title":"Neo4jQuery.@rel","text":"@rel TYPE begin\n    field::Type\n    optional_field::Type = default_value\nend\n\nDeclare a relationship schema with type TYPE and typed properties.\n\nCreates a constant TYPE::RelSchema and registers it for runtime validation.\n\nExample\n\n@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\n\n\n\n\n@rel TYPE\n\nDeclare a relationship schema with no properties (type-only).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.get_node_schema","page":"API Reference","title":"Neo4jQuery.get_node_schema","text":"Look up a registered node schema by label, or return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.get_rel_schema","page":"API Reference","title":"Neo4jQuery.get_rel_schema","text":"Look up a registered relationship schema by type, or return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.validate_node_properties","page":"API Reference","title":"Neo4jQuery.validate_node_properties","text":"validate_node_properties(schema::NodeSchema, props::Dict{String,<:Any})\n\nValidate that props satisfies the schema's required properties. Warns on unknown properties not declared in the schema. Throws on missing required properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.validate_rel_properties","page":"API Reference","title":"Neo4jQuery.validate_rel_properties","text":"validate_rel_properties(schema::RelSchema, props::Dict{String,<:Any})\n\nValidate that props satisfies the schema's required properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.@query","page":"API Reference","title":"Neo4jQuery.@query","text":"@query conn begin\n    @match (p:Person)-[r:KNOWS]->(q:Person)\n    @where p.age > $min_age && q.name == $target\n    @return p.name => :name, r.since, q.name => :friend\n    @orderby p.age :desc\n    @limit 10\nend -> QueryResult\n\nBuild and execute a parameterized Cypher query from a declarative DSL block.\n\nThe Cypher text is assembled at compile-time. Variables referenced with $ are captured as query parameters at runtime (safe, injection-free).\n\nGraph Pattern Syntax (inside @match / @optional_match / @create / @merge)\n\nJulia DSL Cypher\n(p:Person) (p:Person)\n(p:Person) --> (q:Person) (p:Person)-->(q:Person)\n(p:Person)-[r:KNOWS]->(q:Person) (p:Person)-[r:KNOWS]->(q:Person)\n(:Person)-[:KNOWS]->(:Person) (:Person)-[:KNOWS]->(:Person)\n\nWHERE Conditions\n\nJulia DSL Cypher\np.age > $min_age p.age > $min_age\np.name == \"Alice\" p.name = 'Alice'\np.age > 25 && p.active p.age > 25 AND p.active\n!(p.deleted) NOT (p.deleted)\nstartswith(p.name, \"A\") p.name STARTS WITH 'A'\np.tag in $tags p.tag IN $tags\n\nRETURN with Aliases\n\nJulia DSL Cypher\np.name p.name\np.name => :name p.name AS name\ncount(p) => :total count(p) AS total\n\nComplete Example\n\nmin_age = 25\ntarget = \"Bob\"\n\nresult = @query conn begin\n    @match (p:Person)-[r:KNOWS]->(q:Person)\n    @where p.age > $min_age && q.name == $target\n    @return p.name => :name, r.since => :since, q.name => :friend\n    @orderby p.age :desc\n    @limit 10\nend\n\nfor row in result\n    println(row.name, \" knows \", row.friend, \" since \", row.since)\nend\n\nMutation Queries\n\nname = \"Alice\"\n@query conn begin\n    @match (p:Person)\n    @where p.name == $name\n    @set p.age = $new_age\n    @return p\nend\n\n@query conn begin\n    @create (p:Person)-[r:KNOWS]->(q:Person)\n    @set p.name = $name1\n    @set q.name = $name2\n    @set r.since = $since\n    @return p, r, q\nend\n\nKeyword Arguments\n\nPass access_mode, include_counters, etc. as keyword arguments after the block:\n\nresult = @query conn begin\n    @match (p:Person)\n    @return p.name\nend access_mode=:read include_counters=true\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@create","page":"API Reference","title":"Neo4jQuery.@create","text":"@create conn Label(prop1=val1, prop2=val2, ...)\n\nCreate a single node with the given label and properties. Returns the created Node.\n\nIf a schema is registered for Label (via @node), properties are validated at runtime — missing required properties raise an error.\n\nExample\n\n@node Person begin\n    name::String\n    age::Int\nend\n\nalice = @create conn Person(name=\"Alice\", age=30)\n# alice is a Node with labels=[\"Person\"], properties={name: \"Alice\", age: 30}\n\n# Variables work too:\nname = \"Bob\"\nage = 25\nbob = @create conn Person(name=name, age=age)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@merge","page":"API Reference","title":"Neo4jQuery.@merge","text":"@merge conn Label(match_prop=val) on_create(prop=val, ...) on_match(prop=val, ...)\n\nMERGE a node by matching properties, with optional ON CREATE SET and ON MATCH SET.\n\nReturns the merged Node.\n\nExample\n\n# Merge by name, set age only on creation, update last_seen on every match\nnode = @merge conn Person(name=\"Alice\") on_create(age=30) on_match(last_seen=\"2025-02-15\")\n\n# Simple merge (no on_create/on_match):\nnode = @merge conn Person(name=\"Alice\", age=30)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@relate","page":"API Reference","title":"Neo4jQuery.@relate","text":"@relate conn start_node => REL_TYPE(props...) => end_node\n\nCreate a relationship between two existing Node objects. Returns the created Relationship.\n\nUses elementId() to match the start and end nodes.\n\nExample\n\nalice = @create conn Person(name=\"Alice\", age=30)\nbob   = @create conn Person(name=\"Bob\", age=25)\n\nrel = @relate conn alice => KNOWS(since=2024) => bob\n# rel is a Relationship with type=\"KNOWS\", properties={since: 2024}\n\n\n\n\n\n","category":"macro"},{"location":"guide/dsl/#dsl","page":"DSL","title":"DSL","text":"Neo4jQuery includes a compile-time DSL that translates Julia expressions into parameterised Cypher. This gives you type-safe, injection-proof graph operations with Julia-native syntax.","category":"section"},{"location":"guide/dsl/#Schema-declarations","page":"DSL","title":"Schema declarations","text":"Register node and relationship schemas for validation:\n\n@node Person begin\n    name::String\n    age::Int\n    email::String = \"\"    # optional, with default\nend\n\n@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\nSchemas are stored in a global registry and used by mutation macros to validate properties at macro-expansion time.\n\n# Look up registered schemas\nschema = get_node_schema(:Person)\nschema = get_rel_schema(:KNOWS)\n\n# Label-only schemas (no properties)\n@node Marker\n@rel LINKS","category":"section"},{"location":"guide/dsl/#Property-validation","page":"DSL","title":"Property validation","text":"validate_node_properties(schema, Dict{String,Any}(\"name\" => \"Alice\", \"age\" => 30))\n# Throws if required properties are missing\n# Warns on unknown properties","category":"section"},{"location":"guide/dsl/#@query-—-the-query-builder","page":"DSL","title":"@query — the query builder","text":"The main DSL macro compiles a Julia block into a single parameterised Cypher query:\n\nresult = @query conn begin\n    @match (p:Person)-[r:KNOWS]->(q:Person)\n    @where p.age > 25 && q.name != \"Bob\"\n    @return p.name => :name, q.name => :friend, r.since => :year\n    @orderby p.name\n    @limit 10\nend access_mode=:read\n\nThis expands at compile time into:\n\nMATCH (p:Person)-[r:KNOWS]->(q:Person)\nWHERE p.age > 25 AND q.name <> 'Bob'\nRETURN p.name AS name, q.name AS friend, r.since AS year\nORDER BY p.name\nLIMIT 10","category":"section"},{"location":"guide/dsl/#Available-clauses","page":"DSL","title":"Available clauses","text":"Clause Description\n@match MATCH pattern\n@optional_match OPTIONAL MATCH pattern\n@where WHERE conditions\n@return RETURN expressions (with => :alias for AS)\n@with WITH projection (pipe between query parts)\n@unwind UNWIND list AS variable\n@create CREATE pattern\n@merge MERGE pattern\n@set SET property assignments\n@remove REMOVE labels or properties\n@delete DELETE variables\n@detach_delete DETACH DELETE variables\n@orderby ORDER BY expressions\n@skip SKIP n\n@limit LIMIT n\n@on_create_set ON CREATE SET (inside @merge)\n@on_match_set ON MATCH SET (inside @merge)","category":"section"},{"location":"guide/dsl/#Pattern-syntax","page":"DSL","title":"Pattern syntax","text":"# Labeled node\n@match (p:Person)\n\n# Simple directed edge\n@match (a) --> (b)\n\n# Typed relationship\n@match (p:Person)-[r:KNOWS]->(q:Person)\n\n# Chained path\n@match (a)-[r:R]->(b)-[s:S]->(c)","category":"section"},{"location":"guide/dsl/#WHERE-operators","page":"DSL","title":"WHERE operators","text":"Julia operators are translated to Cypher:\n\nJulia Cypher\n== =\n!= <>\n&& AND\n|| OR\n! NOT\nstartswith STARTS WITH\nendswith ENDS WITH\ncontains CONTAINS\nin / ∈ IN\nisnothing IS NULL","category":"section"},{"location":"guide/dsl/#Parameter-capture","page":"DSL","title":"Parameter capture","text":"$var references in the DSL capture Julia variables as safe Cypher parameters:\n\nmin_age = 25\nresult = @query conn begin\n    @match (p:Person)\n    @where p.age > $min_age\n    @return p.name => :name\nend","category":"section"},{"location":"guide/dsl/#Standalone-mutations","page":"DSL","title":"Standalone mutations","text":"For common single-entity operations, use the dedicated macros:","category":"section"},{"location":"guide/dsl/#@create-—-create-a-node","page":"DSL","title":"@create — create a node","text":"node = @create conn Person(name=\"Alice\", age=30)\n# Returns: Node\n\nValidates against the registered Person schema (if present).","category":"section"},{"location":"guide/dsl/#@merge-—-upsert-a-node","page":"DSL","title":"@merge — upsert a node","text":"node = @merge conn Person(name=\"Alice\") on_create(age=30, email=\"a@b.com\") on_match(age=31)\n# MERGE (n:Person {name: $p_name})\n# ON CREATE SET n.age = $p_age, n.email = $p_email\n# ON MATCH SET n.age = $p_age_match\n# RETURN n","category":"section"},{"location":"guide/dsl/#@relate-—-create-a-relationship","page":"DSL","title":"@relate — create a relationship","text":"alice = ...  # Node from a previous query\nbob = ...    # Node from a previous query\n\nrel = @relate conn alice => KNOWS(since=2024) => bob\n# Returns: Relationship\n\nMatches nodes by elementId() and validates against the KNOWS schema.","category":"section"},{"location":"getting_started/#getting-started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Neo4jQuery.jl is currently installed from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/algunion/Neo4jQuery.jl\")","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"You need a running Neo4j instance (5.x or later) with the Query API v2 enabled. This is the default for:\n\nNeo4j Aura (cloud)\nNeo4j Community / Enterprise 5.x+ (self-hosted)","category":"section"},{"location":"getting_started/#Connecting","page":"Getting Started","title":"Connecting","text":"The simplest way to connect:\n\nusing Neo4jQuery\n\nconn = connect(\"localhost\", \"neo4j\";\n    port=7474,\n    auth=BasicAuth(\"neo4j\", \"password\"),\n    scheme=\"http\")\n\nOr load credentials from environment variables / a .env file:\n\n# .env file:\n# NEO4J_URI=neo4j+s://xxxx.databases.neo4j.io\n# NEO4J_USERNAME=neo4j\n# NEO4J_PASSWORD=secret\n# NEO4J_DATABASE=neo4j\n\nconn = connect_from_env(path=\".env\")\n\nSee Connections for full details.","category":"section"},{"location":"getting_started/#Your-First-Query","page":"Getting Started","title":"Your First Query","text":"# Create a node\nresult = query(conn,\n    \"CREATE (p:Person {name: \\$name, age: \\$age}) RETURN p\",\n    parameters=Dict{String,Any}(\"name\" => \"Alice\", \"age\" => 30);\n    include_counters=true)\n\nprintln(result[1].p)           # Node(\"4:xxx:0\", [\"Person\"], ...)\nprintln(result.counters)        # QueryCounters(nodes_created=1, ...)\n\n# Read it back with the @cypher_str macro\nname = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p.name AS name, p.age AS age\"\nresult = query(conn, q; access_mode=:read)\nprintln(result[1].name)         # \"Alice\"","category":"section"},{"location":"getting_started/#What's-Next?","page":"Getting Started","title":"What's Next?","text":"Queries — parameterised queries, counters, bookmarks\nTransactions — explicit begin/commit/rollback and do-block API\nStreaming — memory-efficient row-by-row iteration\nDSL — @query, @create, @merge, @relate macros\nAPI Reference — full function and type documentation","category":"section"},{"location":"guide/queries/#queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"guide/queries/#Implicit-(auto-commit)-queries","page":"Queries","title":"Implicit (auto-commit) queries","text":"The simplest way to execute Cypher:\n\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name\")\n\nEvery call creates an implicit (auto-commit) transaction that opens and closes with a single request.","category":"section"},{"location":"guide/queries/#Parameters","page":"Queries","title":"Parameters","text":"Always use parameters for user-supplied values — never interpolate into Cypher strings:\n\nresult = query(conn,\n    \"MATCH (p:Person {name: \\$name}) RETURN p\",\n    parameters=Dict{String,Any}(\"name\" => \"Alice\"))","category":"section"},{"location":"guide/queries/#The-@cypher_str-macro","page":"Queries","title":"The @cypher_str macro","text":"A safer, more ergonomic approach — local variables prefixed with $ are automatically captured:\n\nname = \"Alice\"\nage = 30\nq = cypher\"CREATE (p:Person {name: $name, age: $age}) RETURN p\"\nresult = query(conn, q)\n\nThe macro produces a CypherQuery that carries both the parameterised statement and the captured bindings. This prevents Cypher injection and enables server-side query plan caching.","category":"section"},{"location":"guide/queries/#Options","page":"Queries","title":"Options","text":"Keyword Type Default Description\nparameters Dict{String,Any} Dict() Query parameters\naccess_mode Symbol :write :read or :write — server routing hint\ninclude_counters Bool false Include mutation statistics\nbookmarks Vector{String} String[] Causal consistency bookmarks\nimpersonated_user Union{String, Nothing} nothing Impersonate a different user","category":"section"},{"location":"guide/queries/#Working-with-results","page":"Queries","title":"Working with results","text":"QueryResult supports indexing, iteration, and standard Julia protocols:\n\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age ORDER BY p.name\")\n\n# Indexing\nfirst_row = result[1]          # NamedTuple\nlast_row  = result[end]\n\n# Fields\nprintln(result.fields)          # [\"name\", \"age\"]\n\n# Iteration\nfor row in result\n    println(row.name, \" — \", row.age)\nend\n\n# Standard functions\nlength(result)\nisempty(result)\nfirst(result)\nlast(result)","category":"section"},{"location":"guide/queries/#Counters","page":"Queries","title":"Counters","text":"When include_counters=true, the result includes a QueryCounters struct:\n\nresult = query(conn, \"CREATE (n:Test) RETURN n\"; include_counters=true)\nc = result.counters\nprintln(c.nodes_created)        # 1","category":"section"},{"location":"guide/queries/#Bookmarks","page":"Queries","title":"Bookmarks","text":"Every result carries bookmarks for causal consistency across queries:\n\nr1 = query(conn, \"CREATE (n:Test)\")\nr2 = query(conn, \"MATCH (n:Test) RETURN n\"; bookmarks=r1.bookmarks)","category":"section"},{"location":"guide/queries/#Graph-types","page":"Queries","title":"Graph types","text":"Nodes, relationships, and paths are returned as rich Julia structs:\n\nresult = query(conn, \"MATCH (p:Person)-[r:KNOWS]->(q) RETURN p, r, q\")\nrow = result[1]\n\nnode = row.p           # Node\nnode.element_id        # \"4:xxx:0\"\nnode.labels            # [\"Person\"]\nnode[\"name\"]           # property access via getindex\nnode.name              # property access via getproperty\n\nrel = row.r            # Relationship\nrel.type               # \"KNOWS\"\nrel[\"since\"]           # property access","category":"section"},{"location":"#Neo4jQuery.jl","page":"Home","title":"Neo4jQuery.jl","text":"A modern Julia client for Neo4j using the Query API v2.\n\n(Image: Build Status) (Image: Documentation (stable)) (Image: Documentation (dev)) (Image: codecov)","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Query API v2 — uses Neo4j's modern HTTP endpoint with Typed JSON for lossless data exchange.\nParameterised Cypher — the @cypher_str macro captures local variables as safe query parameters, preventing injection and enabling server-side caching.\nExplicit & implicit transactions — both auto-commit queries and full begin/commit/rollback lifecycle with a convenient do-block API.\nStreaming results — row-by-row iteration over JSONL responses for memory-efficient processing of large result sets.\nRich type mapping — automatic round-trip conversion between Julia types (Int64, Float64, Date, DateTime, ZonedDateTime, …) and Neo4j's type system.\nGraph DSL — macros @query, @create, @merge, and @relate let you write Julia-native graph operations that compile to parameterised Cypher at macro-expansion time.\nSchema declarations — @node and @rel register typed schemas with validation for safer graph mutations.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Neo4jQuery\n\n# Connect\nconn = connect(\"localhost\", \"neo4j\"; port=7687, auth=BasicAuth(\"neo4j\", \"password\"))\n\n# Query\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\nfor row in result\n    println(\"\\$(row.name) is \\$(row.age) years old\")\nend\n\n# Parameterised query\nname = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p\"\nresult = query(conn, q)\n\nSee the Getting Started guide for installation instructions and a more complete walkthrough.","category":"section"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/connections.md\",\n    \"guide/queries.md\",\n    \"guide/transactions.md\",\n    \"guide/streaming.md\",\n    \"guide/dsl.md\",\n    \"api.md\",\n]\nDepth = 1","category":"section"},{"location":"guide/streaming/#streaming","page":"Streaming","title":"Streaming","text":"For large result sets, streaming avoids loading all rows into memory at once. Results arrive as JSONL (one JSON object per line) and are parsed lazily.","category":"section"},{"location":"guide/streaming/#Basic-usage","page":"Streaming","title":"Basic usage","text":"sr = stream(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\n\nfor row in sr\n    println(row.name, \" — \", row.age)\nend\n\nEach iterate call reads and parses the next row from the HTTP response body.","category":"section"},{"location":"guide/streaming/#Streaming-in-transactions","page":"Streaming","title":"Streaming in transactions","text":"# Implicit transaction\nsr = stream(conn, \"MATCH (p) RETURN p\"; access_mode=:read)\n\n# Explicit transaction\ntx = begin_transaction(conn)\nsr = stream(tx, \"MATCH (p) RETURN p\")\n# ... consume rows ...\ncommit!(tx)","category":"section"},{"location":"guide/streaming/#Options","page":"Streaming","title":"Options","text":"stream accepts the same keyword arguments as query:\n\nKeyword Description\nparameters Query parameters\naccess_mode :read or :write\ninclude_counters Include mutation counters in summary\nbookmarks Causal consistency bookmarks\nimpersonated_user User impersonation","category":"section"},{"location":"guide/streaming/#Summary","page":"Streaming","title":"Summary","text":"After fully consuming the stream, call summary to get metadata:\n\nsr = stream(conn, \"MATCH (p:Person) RETURN p\")\nrows = collect(sr)   # consume all rows\n\ns = summary(sr)\n# s.bookmarks, s.counters, s.notifications, etc.\n\nwarning: Warning\nsummary is only available after the stream has been fully consumed. Calling it mid-stream will block until all remaining rows are read.","category":"section"},{"location":"guide/streaming/#CypherQuery-support","page":"Streaming","title":"CypherQuery support","text":"name = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p\"\nsr = stream(conn, q)","category":"section"},{"location":"guide/connections/#connections","page":"Connections","title":"Connections","text":"Neo4jQuery connects to Neo4j over HTTP using the Query API v2.","category":"section"},{"location":"guide/connections/#connect","page":"Connections","title":"connect","text":"conn = connect(host, database;\n    port=7474,\n    auth=BasicAuth(\"neo4j\", \"password\"),\n    scheme=\"http\")\n\nOn construction the client hits the discovery endpoint (GET /) to verify the server is reachable.\n\nArguments:\n\nParameter Type Default Description\nhost String required Hostname or IP\ndatabase String required Database name (e.g. \"neo4j\")\nport Int 7474 HTTP port\nauth AbstractAuth required Authentication strategy\nscheme String \"http\" \"http\" or \"https\"","category":"section"},{"location":"guide/connections/#connect_from_env","page":"Connections","title":"connect_from_env","text":"Loads connection details from environment variables, optionally reading them from a .env file first:\n\nconn = connect_from_env(; path=\".env\", prefix=\"NEO4J_\")\n\nExpected variables (with default prefix NEO4J_):\n\nVariable Description\nNEO4J_URI Full URI, e.g. neo4j+s://xxx.databases.neo4j.io\nNEO4J_USERNAME Username\nNEO4J_PASSWORD Password\nNEO4J_DATABASE Database name\n\nThe URI scheme is parsed to determine HTTP vs HTTPS:\n\nneo4j+s://, bolt+s://, https:// → HTTPS\nneo4j://, bolt://, http:// → HTTP","category":"section"},{"location":"guide/connections/#Authentication","page":"Connections","title":"Authentication","text":"Two strategies are available:\n\n# HTTP Basic Auth (RFC 7617)\nauth = BasicAuth(\"neo4j\", \"password\")\n\n# Bearer token auth\nauth = BearerAuth(\"eyJhbGciOi...\")\n\nBoth produce an Authorization header used on every request. Implement auth_header(::YourAuth) for custom strategies.","category":"section"},{"location":"guide/connections/#The-dotenv-helper","page":"Connections","title":"The dotenv helper","text":"You can load .env files independently:\n\nvars = dotenv(\".env\"; overwrite=false)\n\nSupports comments (#), quoted values, and export prefix. Existing ENV keys are preserved unless overwrite=true.","category":"section"}]
}
