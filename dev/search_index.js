var documenterSearchIndex = {"docs":
[{"location":"guide/transactions/#transactions","page":"Transactions","title":"Transactions","text":"Neo4jQuery supports both implicit (auto-commit) and explicit transactions.","category":"section"},{"location":"guide/transactions/#Explicit-transactions","page":"Transactions","title":"Explicit transactions","text":"Open a transaction, run multiple queries, then commit or rollback:\n\ntx = begin_transaction(conn)\n\nquery(tx, \"CREATE (a:Account {name: \\$name})\",\n    parameters=Dict{String,Any}(\"name\" => \"Savings\"))\nquery(tx, \"CREATE (a:Account {name: \\$name})\",\n    parameters=Dict{String,Any}(\"name\" => \"Checking\"))\n\nbookmarks = commit!(tx)","category":"section"},{"location":"guide/transactions/#Rollback","page":"Transactions","title":"Rollback","text":"tx = begin_transaction(conn)\nquery(tx, \"CREATE (n:Temp)\")\nrollback!(tx)\n# The Temp node never persists","category":"section"},{"location":"guide/transactions/#Initial-statement","page":"Transactions","title":"Initial statement","text":"begin_transaction accepts an optional initial statement:\n\ntx = begin_transaction(conn;\n    statement=\"CREATE (n:Init) RETURN n\",\n    parameters=Dict{String,Any}())","category":"section"},{"location":"guide/transactions/#Final-statement-on-commit","page":"Transactions","title":"Final statement on commit","text":"commit! can run a final statement atomically with the commit:\n\nbookmarks = commit!(tx;\n    statement=\"CREATE (n:Final) RETURN n\",\n    parameters=Dict{String,Any}())","category":"section"},{"location":"guide/transactions/#Using-@cypher_str-in-transactions","page":"Transactions","title":"Using @cypher_str in transactions","text":"The @cypher_str macro works seamlessly within transactions:\n\ntx = begin_transaction(conn)\n\nname = \"Alice\"\nage = 30\nresult = query(tx, cypher\"CREATE (p:Person {name: $name, age: $age}) RETURN p\")\n\nname = \"Bob\"\nage = 25\nquery(tx, cypher\"CREATE (p:Person {name: $name, age: $age}) RETURN p\")\n\n# Create a relationship between them\nquery(tx, \"\"\"\n    MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n    CREATE (a)-[:KNOWS {since: 2024}]->(b)\n\"\"\")\n\nbookmarks = commit!(tx)","category":"section"},{"location":"guide/transactions/#Do-block-(recommended)","page":"Transactions","title":"Do-block (recommended)","text":"The safest pattern — auto-commits on success, auto-rolls-back on exception:\n\ntransaction(conn) do tx\n    query(tx, \"CREATE (a:Person {name: 'Alice'})\")\n    query(tx, \"CREATE (b:Person {name: 'Bob'})\")\n    query(tx, \"\"\"\n        MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n        CREATE (a)-[:KNOWS]->(b)\n    \"\"\")\nend\n\nIf any exception occurs inside the block, the transaction is automatically rolled back before the exception propagates:\n\ntry\n    transaction(conn) do tx\n        query(tx, \"CREATE (n:Temp)\")\n        error(\"something went wrong\")\n    end\ncatch e\n    # Transaction was rolled back — no :Temp node was created\nend","category":"section"},{"location":"guide/transactions/#Complete-example-using-do-block","page":"Transactions","title":"Complete example using do-block","text":"# Build a small graph atomically\ntransaction(conn) do tx\n    # Create people\n    query(tx, \"CREATE (a:Person {name: \\$name, age: \\$age})\",\n        parameters=Dict{String,Any}(\"name\" => \"Alice\", \"age\" => 30))\n    query(tx, \"CREATE (b:Person {name: \\$name, age: \\$age})\",\n        parameters=Dict{String,Any}(\"name\" => \"Bob\", \"age\" => 25))\n    query(tx, \"CREATE (c:Person {name: \\$name, age: \\$age})\",\n        parameters=Dict{String,Any}(\"name\" => \"Carol\", \"age\" => 35))\n\n    # Create relationships\n    query(tx, \"\"\"\n        MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})\n        CREATE (a)-[:KNOWS {since: 2020}]->(b)\n    \"\"\")\n    query(tx, \"\"\"\n        MATCH (a:Person {name: 'Alice'}), (c:Person {name: 'Carol'})\n        CREATE (a)-[:KNOWS {since: 2022}]->(c)\n    \"\"\")\nend\n# All five operations commit together, or none do","category":"section"},{"location":"guide/transactions/#Transaction-state","page":"Transactions","title":"Transaction state","text":"The Transaction struct tracks its lifecycle:\n\ntx = begin_transaction(conn)\n# tx.committed == false, tx.rolled_back == false\n\ncommit!(tx)\n# tx.committed == true\n\n# Subsequent queries on a committed/rolled-back tx will error\n\nAttempting to use a committed or rolled-back transaction raises an error:\n\ntx = begin_transaction(conn)\ncommit!(tx)\n\n# This will throw an error:\n# query(tx, \"RETURN 1\")  # \"Transaction tx-123 has already been committed\"","category":"section"},{"location":"api/#api-reference","page":"API Reference","title":"API Reference","text":"Full reference for all public types and functions.","category":"section"},{"location":"api/#Connection","page":"API Reference","title":"Connection","text":"","category":"section"},{"location":"api/#Authentication","page":"API Reference","title":"Authentication","text":"","category":"section"},{"location":"api/#Environment","page":"API Reference","title":"Environment","text":"","category":"section"},{"location":"api/#Query","page":"API Reference","title":"Query","text":"","category":"section"},{"location":"api/#Transactions","page":"API Reference","title":"Transactions","text":"","category":"section"},{"location":"api/#Streaming","page":"API Reference","title":"Streaming","text":"","category":"section"},{"location":"api/#Result-Types","page":"API Reference","title":"Result Types","text":"","category":"section"},{"location":"api/#Graph-Types","page":"API Reference","title":"Graph Types","text":"","category":"section"},{"location":"api/#Errors","page":"API Reference","title":"Errors","text":"","category":"section"},{"location":"api/#DSL-—-Schema","page":"API Reference","title":"DSL — Schema","text":"","category":"section"},{"location":"api/#DSL-—-Macros","page":"API Reference","title":"DSL — Macros","text":"","category":"section"},{"location":"api/#Neo4jQuery.Neo4jConnection","page":"API Reference","title":"Neo4jQuery.Neo4jConnection","text":"Neo4jConnection\n\nRepresents a connection to a Neo4j database via the Query API v2.\n\nCreate one with connect rather than calling the constructor directly.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.connect","page":"API Reference","title":"Neo4jQuery.connect","text":"connect(host, database; port=7474, auth, scheme=\"http\") -> Neo4jConnection\n\nEstablish a connection to a Neo4j instance.  Validates connectivity by hitting the discovery endpoint (GET /).\n\nExample\n\nconn = connect(\"localhost\", \"neo4j\"; auth=BasicAuth(\"neo4j\", \"password\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.connect_from_env","page":"API Reference","title":"Neo4jQuery.connect_from_env","text":"connect_from_env(; path=\".env\", prefix=\"NEO4J_\") -> Neo4jConnection\n\nConvenience constructor that loads credentials from environment variables (optionally reading a .env file first) and returns a ready-to-use connection.\n\nExpected variables (with default NEO4J_ prefix):\n\nNEO4J_URI      — full URI, e.g. neo4j+s://xxx.databases.neo4j.io\nNEO4J_USERNAME — e.g. neo4j\nNEO4J_PASSWORD — the password\nNEO4J_DATABASE — e.g. neo4j  (defaults to \"neo4j\" if unset)\n\nThe URI scheme is mapped automatically:\n\nneo4j+s://, neo4j+ssc:// → HTTPS (port 443)\nneo4j://, bolt:// → HTTP (port 7474)\n\nExample\n\nconn = connect_from_env()                    # reads .env, connects\nconn = connect_from_env(path=\"prod.env\")     # different file\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.AbstractAuth","page":"API Reference","title":"Neo4jQuery.AbstractAuth","text":"AbstractAuth\n\nAbstract type for authentication strategies used to authorize Neo4j requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.BasicAuth","page":"API Reference","title":"Neo4jQuery.BasicAuth","text":"BasicAuth(username::String, password::String)\n\nHTTP Basic authentication (RFC 7617).  Generates an Authorization: Basic … header from the supplied credentials.\n\nExample\n\nauth = BasicAuth(\"neo4j\", \"verysecret\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.BearerAuth","page":"API Reference","title":"Neo4jQuery.BearerAuth","text":"BearerAuth(token::String)\n\nHTTP Bearer-token authentication.  Generates an Authorization: Bearer … header from the supplied token.\n\nExample\n\nauth = BearerAuth(\"xbhkjnlvianztghqwawxqfe\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.dotenv","page":"API Reference","title":"Neo4jQuery.dotenv","text":"dotenv(path=\".env\"; overwrite=false) -> Dict{String,String}\n\nParse a .env file and load its key-value pairs into ENV. Returns the parsed dictionary.\n\nLines starting with # are treated as comments and ignored. Empty lines are skipped.  Values may optionally be quoted with \" or '.\n\nIf overwrite is false (default), existing ENV entries are not overwritten—the file values serve as defaults.\n\nExample\n\ndotenv()                        # loads .env from current directory\ndotenv(\"config/.env.test\")      # loads a specific file\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.query","page":"API Reference","title":"Neo4jQuery.query","text":"query(conn, statement; parameters, access_mode, include_counters, bookmarks, impersonated_user) -> QueryResult\n\nExecute a Cypher statement against the database using an implicit transaction.\n\nArguments\n\nconn::Neo4jConnection — the connection to use.\nstatement::String — the Cypher query text.\n\nKeyword Arguments\n\nparameters::Dict{String,Any}=Dict{String,Any}() — query parameters.\naccess_mode::Symbol=:write — :read or :write for cluster routing.\ninclude_counters::Bool=false — whether to request query counters.\nbookmarks::Vector{String}=String[] — bookmarks for causal consistency.\nimpersonated_user::Union{String,Nothing}=nothing — run as another user.\n\nExample\n\nresult = query(conn, \"MATCH (n:Person) RETURN n.name AS name LIMIT 10\")\nfor row in result\n    println(row.name)\nend\n\n\n\n\n\nquery(conn, q::CypherQuery; kwargs...) -> QueryResult\n\nExecute a CypherQuery (typically from the @cypher_str macro). Parameters from the CypherQuery are merged with any extra parameters kwarg (the kwarg takes precedence on conflicts).\n\n\n\n\n\nquery(tx::Transaction, statement; parameters, include_counters) -> QueryResult\n\nExecute a Cypher statement inside an open transaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.CypherQuery","page":"API Reference","title":"Neo4jQuery.CypherQuery","text":"CypherQuery\n\nA Cypher query statement together with its parameter bindings.  Typically constructed via the @cypher_str string macro.\n\nFields\n\nstatement::String — the Cypher text (with $param placeholders)\nparameters::Dict{String,Any} — parameter name → Julia value\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.@cypher_str","page":"API Reference","title":"Neo4jQuery.@cypher_str","text":"@cypher_str -> CypherQuery\n\nCreate a CypherQuery from a Cypher string literal, automatically capturing local variables referenced with $ as query parameters.\n\nJulia does not interpolate $ inside non-standard string literals, so the $ is passed through verbatim and the macro can detect it as a Cypher parameter reference.\n\nExample\n\nname = \"Alice\"\nage  = 42\nq = cypher\"MATCH (n:Person {name: $name, age: $age}) RETURN n\"\n# CypherQuery(\"MATCH (n:Person {name: $name, age: $age}) RETURN n\", 2 parameters)\n# q.parameters == Dict(\"name\" => \"Alice\", \"age\" => 42)\n\nThe resulting query uses parameterised Cypher, which is both safer (no injection) and faster (query plan caching).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.Transaction","page":"API Reference","title":"Neo4jQuery.Transaction","text":"Transaction\n\nAn explicit Neo4j transaction.  Obtain one via begin_transaction or the transaction do-block helper.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.begin_transaction","page":"API Reference","title":"Neo4jQuery.begin_transaction","text":"begin_transaction(conn; statement=nothing, parameters=Dict{String,Any}()) -> Transaction\n\nOpen a new explicit transaction, optionally executing an initial statement.\n\nExample\n\ntx = begin_transaction(conn)\nresult = query(tx, \"CREATE (n:Person {name: 'Alice'}) RETURN n\")\ncommit!(tx)\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.commit!","page":"API Reference","title":"Neo4jQuery.commit!","text":"commit!(tx; statement=nothing, parameters=Dict{String,Any}()) -> Vector{String}\n\nCommit an open transaction, optionally executing a final statement. Returns the bookmarks from the committed transaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.rollback!","page":"API Reference","title":"Neo4jQuery.rollback!","text":"rollback!(tx::Transaction) -> Nothing\n\nRoll back an open transaction, discarding all changes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.transaction","page":"API Reference","title":"Neo4jQuery.transaction","text":"transaction(f, conn; kwargs...) -> result\n\nExecute f(tx) inside an explicit transaction.  The transaction is committed if f returns normally, or rolled back if an exception is thrown.\n\nExample\n\ntransaction(conn) do tx\n    query(tx, \"CREATE (a:Person {name: 'Alice'})\")\n    query(tx, \"CREATE (b:Person {name: 'Bob'})\")\nend  # auto-commit\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.stream","page":"API Reference","title":"Neo4jQuery.stream","text":"stream(conn, statement; parameters, access_mode, bookmarks, impersonated_user) -> StreamingResult\n\nExecute a Cypher query with streaming enabled.  Returns a StreamingResult that yields NamedTuple rows via iteration.\n\nExample\n\nfor row in stream(conn, \"MATCH (n:Person) RETURN n.name AS name\")\n    println(row.name)\nend\n\n\n\n\n\nstream(tx::Transaction, statement; parameters) -> StreamingResult\n\nExecute a streaming query inside an existing explicit transaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.StreamingResult","page":"API Reference","title":"Neo4jQuery.StreamingResult","text":"StreamingResult\n\nAn in-progress streaming query result.  Implements Julia's iteration protocol so records can be consumed with a for loop:\n\nfor row in stream(conn, \"MATCH (n) RETURN n.name AS name\")\n    println(row.name)\nend\n\nAfter iteration completes (or is interrupted), call summary to retrieve bookmarks, counters, and notifications.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.summary","page":"API Reference","title":"Neo4jQuery.summary","text":"summary(sr::StreamingResult) -> NamedTuple\n\nAccess bookmarks, counters, notifications, and query plans after the stream has been consumed.  Returns a NamedTuple with keys:\n\nbookmarks::Vector{String}\ncounters::Union{QueryCounters, Nothing}\nnotifications::Vector{Notification}\ntransaction::Union{JSON.Object, Nothing}\nquery_plan::Union{JSON.Object, Nothing}\nprofiled_query_plan::Union{JSON.Object, Nothing}\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.QueryResult","page":"API Reference","title":"Neo4jQuery.QueryResult","text":"QueryResult\n\nThe result of a Cypher query.  Supports iteration and indexing—each row is a NamedTuple whose keys match the query's field names.\n\nIteration\n\nfor row in result\n    println(row.name, \" is \", row.age, \" years old\")\nend\n\nIndexing\n\nresult[1]          # first row as NamedTuple\nresult[end]        # last row\nlength(result)     # number of rows\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.QueryCounters","page":"API Reference","title":"Neo4jQuery.QueryCounters","text":"QueryCounters\n\nStatistics about database changes performed by a query.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Notification","page":"API Reference","title":"Neo4jQuery.Notification","text":"Notification\n\nA server notification (performance warning, deprecation hint, etc.) attached to a query response.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Node","page":"API Reference","title":"Neo4jQuery.Node","text":"Node\n\nA Neo4j graph node with an element ID, labels, and a property map.\n\nProperty access is supported via both indexing and dot syntax:\n\nnode[\"name\"]   # indexing\nnode.name      # dot syntax\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Relationship","page":"API Reference","title":"Neo4jQuery.Relationship","text":"Relationship\n\nA Neo4j graph relationship with an element ID, start/end node element IDs, a type string, and a property map.\n\nrel[\"since\"]   # indexing\nrel.since      # dot syntax\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Path","page":"API Reference","title":"Neo4jQuery.Path","text":"Path\n\nA Neo4j graph path—an alternating sequence of Node and Relationship objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherPoint","page":"API Reference","title":"Neo4jQuery.CypherPoint","text":"CypherPoint\n\nA Cypher spatial point value.  Stored as an SRID integer and a coordinate vector. Serialised on the wire as a WKT string, e.g. \"SRID=7203;POINT (1.2 3.4)\".\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherDuration","page":"API Reference","title":"Neo4jQuery.CypherDuration","text":"CypherDuration\n\nA Cypher duration value.  Stored as the original ISO-8601 string (e.g. \"P14DT16H12M\").\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.CypherVector","page":"API Reference","title":"Neo4jQuery.CypherVector","text":"CypherVector\n\nA Neo4j vector value (Enterprise Edition).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Neo4jError","page":"API Reference","title":"Neo4jQuery.Neo4jError","text":"Neo4jError <: Exception\n\nAbstract base type for all Neo4j-related errors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.AuthenticationError","page":"API Reference","title":"Neo4jQuery.AuthenticationError","text":"AuthenticationError <: Neo4jError\n\nRaised when the server returns HTTP 401 (missing, incorrect, or invalid credentials).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.Neo4jQueryError","page":"API Reference","title":"Neo4jQuery.Neo4jQueryError","text":"Neo4jQueryError <: Neo4jError\n\nRaised when the server response contains an errors array (query syntax errors, constraint violations, etc.).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.TransactionExpiredError","page":"API Reference","title":"Neo4jQuery.TransactionExpiredError","text":"TransactionExpiredError <: Neo4jError\n\nRaised when a request targets a transaction that has already expired or been rolled back on the server side.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.PropertyDef","page":"API Reference","title":"Neo4jQuery.PropertyDef","text":"PropertyDef\n\nA single property definition within a node or relationship schema.\n\nFields\n\nname::Symbol — property name\ntype::Symbol — Julia type name (e.g. :String, :Int)\nrequired::Bool — whether the property must be supplied on creation\ndefault — default value for optional properties, or nothing for required\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.NodeSchema","page":"API Reference","title":"Neo4jQuery.NodeSchema","text":"NodeSchema\n\nSchema descriptor for a Neo4j node label, created by the @node macro.\n\nFields\n\nlabel::Symbol — the Neo4j label (e.g. :Person)\nproperties::Vector{PropertyDef} — typed property definitions\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.RelSchema","page":"API Reference","title":"Neo4jQuery.RelSchema","text":"RelSchema\n\nSchema descriptor for a Neo4j relationship type, created by the @rel macro.\n\nFields\n\nreltype::Symbol — the relationship type (e.g. :KNOWS)\nproperties::Vector{PropertyDef} — typed property definitions\n\n\n\n\n\n","category":"type"},{"location":"api/#Neo4jQuery.@node","page":"API Reference","title":"Neo4jQuery.@node","text":"@node Name begin\n    field::Type\n    optional_field::Type = default_value\nend\n\nDeclare a node schema with label Name and typed properties.\n\nCreates a constant Name::NodeSchema and registers it for runtime validation in @create and @merge operations.\n\nExample\n\n@node Person begin\n    name::String\n    age::Int\n    email::String = \"\"\nend\n\n# Person is now a NodeSchema constant\nPerson.label       # :Person\nPerson.properties  # [PropertyDef(:name, :String, true, nothing), ...]\n\n\n\n\n\n@node Name\n\nDeclare a node schema with no properties (label-only).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@rel","page":"API Reference","title":"Neo4jQuery.@rel","text":"@rel TYPE begin\n    field::Type\n    optional_field::Type = default_value\nend\n\nDeclare a relationship schema with type TYPE and typed properties.\n\nCreates a constant TYPE::RelSchema and registers it for runtime validation.\n\nExample\n\n@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\n\n\n\n\n@rel TYPE\n\nDeclare a relationship schema with no properties (type-only).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.get_node_schema","page":"API Reference","title":"Neo4jQuery.get_node_schema","text":"Look up a registered node schema by label, or return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.get_rel_schema","page":"API Reference","title":"Neo4jQuery.get_rel_schema","text":"Look up a registered relationship schema by type, or return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.validate_node_properties","page":"API Reference","title":"Neo4jQuery.validate_node_properties","text":"validate_node_properties(schema::NodeSchema, props::Dict{String,<:Any})\n\nValidate that props satisfies the schema's required properties. Warns on unknown properties not declared in the schema. Throws on missing required properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.validate_rel_properties","page":"API Reference","title":"Neo4jQuery.validate_rel_properties","text":"validate_rel_properties(schema::RelSchema, props::Dict{String,<:Any})\n\nValidate that props satisfies the schema's required properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neo4jQuery.@query","page":"API Reference","title":"Neo4jQuery.@query","text":"@query conn begin\n    @match (p:Person)-[r:KNOWS]->(q:Person)\n    @where p.age > $min_age && q.name == $target\n    @return p.name => :name, r.since, q.name => :friend\n    @orderby p.age :desc\n    @limit 10\nend -> QueryResult\n\nBuild and execute a parameterized Cypher query from a declarative DSL block.\n\nThe Cypher text is assembled at compile-time. Variables referenced with $ are captured as query parameters at runtime (safe, injection-free).\n\nGraph Pattern Syntax (inside @match / @optional_match / @create / @merge)\n\nJulia DSL Cypher\n(p:Person) (p:Person)\n(p:Person) --> (q:Person) (p:Person)-->(q:Person)\n(p:Person)-[r:KNOWS]->(q:Person) (p:Person)-[r:KNOWS]->(q:Person)\n(:Person)-[:KNOWS]->(:Person) (:Person)-[:KNOWS]->(:Person)\n\nWHERE Conditions\n\nJulia DSL Cypher\np.age > $min_age p.age > $min_age\np.name == \"Alice\" p.name = 'Alice'\np.age > 25 && p.active p.age > 25 AND p.active\n!(p.deleted) NOT (p.deleted)\nstartswith(p.name, \"A\") p.name STARTS WITH 'A'\np.tag in $tags p.tag IN $tags\n\nRETURN with Aliases\n\nJulia DSL Cypher\np.name p.name\np.name => :name p.name AS name\ncount(p) => :total count(p) AS total\n\nComplete Example\n\nmin_age = 25\ntarget = \"Bob\"\n\nresult = @query conn begin\n    @match (p:Person)-[r:KNOWS]->(q:Person)\n    @where p.age > $min_age && q.name == $target\n    @return p.name => :name, r.since => :since, q.name => :friend\n    @orderby p.age :desc\n    @limit 10\nend\n\nfor row in result\n    println(row.name, \" knows \", row.friend, \" since \", row.since)\nend\n\nMutation Queries\n\nname = \"Alice\"\n@query conn begin\n    @match (p:Person)\n    @where p.name == $name\n    @set p.age = $new_age\n    @return p\nend\n\n@query conn begin\n    @create (p:Person)-[r:KNOWS]->(q:Person)\n    @set p.name = $name1\n    @set q.name = $name2\n    @set r.since = $since\n    @return p, r, q\nend\n\nKeyword Arguments\n\nPass access_mode, include_counters, etc. as keyword arguments after the block:\n\nresult = @query conn begin\n    @match (p:Person)\n    @return p.name\nend access_mode=:read include_counters=true\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@graph","page":"API Reference","title":"Neo4jQuery.@graph","text":"@graph conn begin ... end\n@graph conn [comprehension]\n\nHyper-ergonomic graph query DSL that compiles to parameterized Cypher.\n\nPattern Syntax\n\nJulia Cypher\np::Person (p:Person)\n::Person (:Person)\np::Person >> r::KNOWS >> q::Person (p:Person)-[r:KNOWS]->(q:Person)\np::Person >> KNOWS >> q::Person (p:Person)-[:KNOWS]->(q:Person)\np::Person << r::KNOWS << q::Person (p:Person)<-[r:KNOWS]-(q:Person)\n(p::Person)-[r::KNOWS]->(q::Person) (p:Person)-[r:KNOWS]->(q:Person)\n(p) --> (q) (p)-->(q)\na::A >> R1 >> b::B >> R2 >> c::C (a:A)-[:R1]->(b:B)-[:R2]->(c:C)\n\nClause Functions (no @ prefix needed)\n\nClause Cypher\nwhere(cond1, cond2) WHERE cond1 AND cond2\nret(expr => :alias, ...) RETURN expr AS alias, ...\nret(distinct, expr) RETURN DISTINCT expr\norder(expr, :desc) ORDER BY expr DESC\ntake(n) / skip(n) LIMIT n / SKIP n\ncreate(pattern) CREATE pattern\nmerge(pattern) MERGE pattern\noptional(pattern) OPTIONAL MATCH pattern\np.prop = val (assignment) SET p.prop = val\nwith(expr => :alias, ...) WITH expr AS alias, ...\nunwind($list => :var) UNWIND $list AS var\ndelete(vars...) / detach_delete() DELETE / DETACH DELETE\non_create(p.age = val) (after merge) ON CREATE SET p.age = val\non_match(p.age = val) (after merge) ON MATCH SET p.age = val\nmatch(p1, p2) (explicit multi) MATCH p1, p2\n\nExamples\n\n# ── Simple node query ──\nresult = @graph conn begin\n    p::Person\n    where(p.age > 25)\n    ret(p.name, p.age)\nend\n\n# ── Relationship traversal with >> chains ──\nresult = @graph conn begin\n    p::Person >> r::KNOWS >> q::Person\n    where(p.age > $min_age, q.name == $target)\n    ret(p.name => :name, r.since, q.name => :friend)\n    order(p.age, :desc)\n    take(10)\nend\n\n# ── Multi-hop traversal ──\nresult = @graph conn begin\n    a::Person >> r::KNOWS >> b::Person >> s::WORKS_AT >> c::Company\n    ret(a.name, b.name, c.name)\nend\n\n# ── Mutations with auto-SET ──\n@graph conn begin\n    p::Person\n    where(p.name == $name)\n    p.age = $new_age\n    p.active = true\n    ret(p)\nend\n\n# ── Create with properties ──\n@graph conn begin\n    create(p::Person)\n    p.name = $name\n    p.age = $age\n    ret(p)\nend\n\n# ── Merge with on_create / on_match ──\n@graph conn begin\n    merge(p::Person)\n    on_create(p.created = true)\n    on_match(p.updated = true)\n    ret(p)\nend\n\n# ── Comprehension form (simple queries) ──\nresult = @graph conn [p.name for p in Person if p.age > 25]\nresult = @graph conn [p for p in Person]\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@create","page":"API Reference","title":"Neo4jQuery.@create","text":"@create conn Label(prop1=val1, prop2=val2, ...)\n\nCreate a single node with the given label and properties. Returns the created Node.\n\nIf a schema is registered for Label (via @node), properties are validated at runtime — missing required properties raise an error.\n\nExample\n\n@node Person begin\n    name::String\n    age::Int\nend\n\nalice = @create conn Person(name=\"Alice\", age=30)\n# alice is a Node with labels=[\"Person\"], properties={name: \"Alice\", age: 30}\n\n# Variables work too:\nname = \"Bob\"\nage = 25\nbob = @create conn Person(name=name, age=age)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@merge","page":"API Reference","title":"Neo4jQuery.@merge","text":"@merge conn Label(match_prop=val) on_create(prop=val, ...) on_match(prop=val, ...)\n\nMERGE a node by matching properties, with optional ON CREATE SET and ON MATCH SET.\n\nReturns the merged Node.\n\nExample\n\n# Merge by name, set age only on creation, update last_seen on every match\nnode = @merge conn Person(name=\"Alice\") on_create(age=30) on_match(last_seen=\"2025-02-15\")\n\n# Simple merge (no on_create/on_match):\nnode = @merge conn Person(name=\"Alice\", age=30)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Neo4jQuery.@relate","page":"API Reference","title":"Neo4jQuery.@relate","text":"@relate conn start_node => REL_TYPE(props...) => end_node\n\nCreate a relationship between two existing Node objects. Returns the created Relationship.\n\nUses elementId() to match the start and end nodes.\n\nExample\n\nalice = @create conn Person(name=\"Alice\", age=30)\nbob   = @create conn Person(name=\"Bob\", age=25)\n\nrel = @relate conn alice => KNOWS(since=2024) => bob\n# rel is a Relationship with type=\"KNOWS\", properties={since: 2024}\n\n\n\n\n\n","category":"macro"},{"location":"guide/biomedical_case_study/#biomedical-case-study","page":"Biomedical Case Study","title":"Biomedical Knowledge Graph — Case Study","text":"This case study demonstrates building a realistic biomedical knowledge graph using the Neo4jQuery DSL. It covers schema declarations, node/relationship creation, and complex analytical queries — with side-by-side comparisons of raw Cypher vs the @query DSL vs the @graph DSL.\n\nNeo4jQuery offers two macro-based query interfaces:\n\n@query — uses @sub-macro syntax (@match, @where, @return, …) and Cypher-like patterns (p:Person)-[r:KNOWS]->(q:Person)\n@graph — uses plain function-call syntax (where(), ret(), order(), …) and Julia-native >> chain patterns p::Person >> r::KNOWS >> q::Person\n\nBoth compile to identical Cypher at macro expansion time. The examples below show all three approaches.\n\nThe full runnable scripts are:\n\ntest/biomedical_graph_test.jl — @query / @create / @relate version\ntest/biomedical_graph_dsl_test.jl — @graph version\n\n","category":"section"},{"location":"guide/biomedical_case_study/#Domain-model","page":"Biomedical Case Study","title":"Domain model","text":"The graph models a clinical/biomedical knowledge base with 12 node types and 17 relationship types:\n\nNode Labels Relationship Types\nDisease ASSOCIATED_WITH\nGene TARGETS\nProtein INHIBITS\nDrug ENCODES\nClinicalTrial PARTICIPATES_IN\nPatient DIAGNOSED_WITH\nHospital ENROLLED_IN\nPhysician TREATS\nPathway PRESCRIBED_BY\nSymptom LOCATED_AT\nBiomarker PRESENTS_WITH\nPublication INDICATES, PUBLISHED_IN\n EXPRESSES, HAS_SIDE_EFFECT\n INTERACTS_WITH\n\n","category":"section"},{"location":"guide/biomedical_case_study/#1.-Schema-declarations","page":"Biomedical Case Study","title":"1. Schema declarations","text":"","category":"section"},{"location":"guide/biomedical_case_study/#Raw-Cypher","page":"Biomedical Case Study","title":"Raw Cypher","text":"Cypher has no built-in schema declarations. You rely on conventions and documentation:\n\n// No schema — just hope everyone remembers the properties\nCREATE (d:Disease {name: \"Breast Cancer\", icd10_code: \"C50\", category: \"Oncology\", chronic: true})\n// Oops, someone writes: CREATE (d:Disease {naam: \"Lung Cancer\"})  — no error","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-(@query-and-@graph-share-the-same-schemas)","page":"Biomedical Case Study","title":"Julia DSL (@query and @graph share the same schemas)","text":"using Neo4jQuery\n\n@node Disease begin\n    name::String\n    icd10_code::String\n    category::String\n    chronic::Bool\nend\n\n@node Gene begin\n    symbol::String\n    full_name::String\n    chromosome::String\n    locus::String = \"\"       # optional, with default\nend\n\n@node Protein begin\n    uniprot_id::String\n    name::String\n    molecular_weight::Float64\n    function_desc::String = \"\"\nend\n\n@node Drug begin\n    name::String\n    trade_name::String\n    mechanism::String\n    approved_year::Int\n    phase::String = \"approved\"\nend\n\n@node Patient begin\n    patient_id::String\n    age::Int\n    sex::String\n    ethnicity::String = \"\"\nend\n\n# Relationships get schemas too\n@rel ASSOCIATED_WITH begin\n    score::Float64\n    source::String\nend\n\n@rel TARGETS begin\n    action::String\n    binding_affinity::Float64 = 0.0\nend\n\n@rel TREATS begin\n    efficacy::Float64\n    evidence_level::String\nend\n\n@rel DIAGNOSED_WITH begin\n    diagnosis_date::String\n    stage::String = \"\"\nend\n\nSchemas enable runtime validation — misspelled properties, missing required fields, and type mismatches are caught immediately. Both @query and @graph use the same schema registry.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#2.-Creating-nodes","page":"Biomedical Case Study","title":"2. Creating nodes","text":"","category":"section"},{"location":"guide/biomedical_case_study/#Raw-Cypher-2","page":"Biomedical Case Study","title":"Raw Cypher","text":"CREATE (d:Disease {name: 'Breast Cancer', icd10_code: 'C50', category: 'Oncology', chronic: true})\nRETURN d\n\nCREATE (g:Gene {symbol: 'BRCA1', full_name: 'BRCA1 DNA Repair Associated',\n                chromosome: '17q21.31', locus: '17q21'})\nRETURN g\n\nCREATE (drug:Drug {name: 'Trastuzumab', trade_name: 'Herceptin',\n                   mechanism: 'HER2 monoclonal antibody', approved_year: 1998})\nRETURN drug","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-—-@create-macro","page":"Biomedical Case Study","title":"Julia DSL — @create macro","text":"breast_cancer = @create conn Disease(\n    name=\"Breast Cancer\",\n    icd10_code=\"C50\",\n    category=\"Oncology\",\n    chronic=true\n)\n\nbrca1 = @create conn Gene(\n    symbol=\"BRCA1\", full_name=\"BRCA1 DNA Repair Associated\",\n    chromosome=\"17q21.31\", locus=\"17q21\"\n)\n\ntrastuzumab = @create conn Drug(\n    name=\"Trastuzumab\", trade_name=\"Herceptin\",\n    mechanism=\"HER2 monoclonal antibody\", approved_year=1998\n)\n\nEach call returns a Node object you can use directly to create relationships.","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-—-@graph-macro","page":"Biomedical Case Study","title":"Julia DSL — @graph macro","text":"breast_cancer = let\n    r = @graph conn begin\n        create(d::Disease)\n        d.name = \"Breast Cancer\"\n        d.icd10_code = \"C50\"\n        d.category = \"Oncology\"\n        d.chronic = true\n        ret(d)\n    end\n    r[1].d\nend\n\nbrca1 = let\n    r = @graph conn begin\n        create(g::Gene)\n        g.symbol = \"BRCA1\"\n        g.full_name = \"BRCA1 DNA Repair Associated\"\n        g.chromosome = \"17q21.31\"\n        g.locus = \"17q21\"\n        ret(g)\n    end\n    r[1].g\nend\n\ntrastuzumab = let\n    r = @graph conn begin\n        create(d::Drug)\n        d.name = \"Trastuzumab\"\n        d.trade_name = \"Herceptin\"\n        d.mechanism = \"HER2 monoclonal antibody\"\n        d.approved_year = 1998\n        ret(d)\n    end\n    r[1].d\nend\n\nThe @graph approach uses create() + property assignments (d.name = \"...\") which compile to CREATE (d:Disease) SET d.name = '...'. Properties are set via auto-SET detection.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#3.-Creating-relationships","page":"Biomedical Case Study","title":"3. Creating relationships","text":"","category":"section"},{"location":"guide/biomedical_case_study/#Raw-Cypher-3","page":"Biomedical Case Study","title":"Raw Cypher","text":"// Need to match nodes by some property first\nMATCH (g:Gene {symbol: 'BRCA1'}), (d:Disease {name: 'Breast Cancer'})\nCREATE (g)-[r:ASSOCIATED_WITH {score: 0.95, source: 'ClinVar'}]->(d)\nRETURN r\n\nMATCH (drug:Drug {name: 'Trastuzumab'}), (d:Disease {name: 'Breast Cancer'})\nCREATE (drug)-[r:TREATS {efficacy: 0.85, evidence_level: '1A'}]->(d)\nRETURN r","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-—-@relate-macro","page":"Biomedical Case Study","title":"Julia DSL — @relate macro","text":"# Nodes already in scope from @create — @relate uses elementId() automatically\n@relate conn brca1 => ASSOCIATED_WITH(score=0.95, source=\"ClinVar\") => breast_cancer\n\n@relate conn trastuzumab => TREATS(efficacy=0.85, evidence_level=\"1A\") => breast_cancer\n\nNo need to re-match nodes by property. The DSL uses elementId() from the returned Node objects — zero ambiguity, zero duplication.","category":"section"},{"location":"guide/biomedical_case_study/#Julia-DSL-—-@graph-macro-2","page":"Biomedical Case Study","title":"Julia DSL — @graph macro","text":"# Match nodes by property, then create the relationship with arrow syntax\n@graph conn begin\n    match(g::Gene, d::Disease)\n    where(g.symbol == \"BRCA1\", d.name == \"Breast Cancer\")\n    create((g) - [r::ASSOCIATED_WITH] -> (d))\n    r.score = 0.95\n    r.source = \"ClinVar\"\n    ret(r)\nend\n\n@graph conn begin\n    match(drug::Drug, d::Disease)\n    where(drug.name == \"Trastuzumab\", d.name == \"Breast Cancer\")\n    create((drug) - [r::TREATS] -> (d))\n    r.efficacy = 0.85\n    r.evidence_level = \"1A\"\n    ret(r)\nend\n\nThe @graph approach uses match() + where() to locate nodes, then create() with arrow patterns. Relationship properties are set via auto-SET.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.-Complex-queries-—-side-by-side","page":"Biomedical Case Study","title":"4. Complex queries — side by side","text":"","category":"section"},{"location":"guide/biomedical_case_study/#4.1-Multi-hop:-Gene-Protein-Pathway-for-a-disease","page":"Biomedical Case Study","title":"4.1 Multi-hop: Gene → Protein → Pathway for a disease","text":"Raw Cypher:\n\nMATCH (g:Gene)-[:ASSOCIATED_WITH]->(d:Disease {name: 'Breast Cancer'})\nMATCH (g)-[:ENCODES]->(p:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\nRETURN g.symbol AS gene, p.name AS protein, pw.name AS pathway\nORDER BY g.symbol\n\n@query DSL:\n\ndisease_name = \"Breast Cancer\"\nresult = @query conn begin\n    @match (g:Gene)-[:ASSOCIATED_WITH]->(d:Disease)\n    @match (g)-[:ENCODES]->(p:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\n    @where d.name == $disease_name\n    @return g.symbol => :gene, p.name => :protein, pw.name => :pathway\n    @orderby g.symbol\nend\n\n@graph DSL:\n\ndisease_name = \"Breast Cancer\"\nresult = @graph conn begin\n    g::Gene >> ::ASSOCIATED_WITH >> d::Disease\n    g >> ::ENCODES >> p::Protein >> ::PARTICIPATES_IN >> pw::Pathway\n    where(d.name == $disease_name)\n    ret(g.symbol => :gene, p.name => :protein, pw.name => :pathway)\n    order(g.symbol)\nend\n\nThe >> chains replace -[]-> arrow syntax. Bare patterns become implicit MATCH clauses.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.2-Drug-repurposing-—-shared-pathway-targets","page":"Biomedical Case Study","title":"4.2 Drug repurposing — shared pathway targets","text":"Raw Cypher:\n\nMATCH (drug:Drug)-[:TARGETS]->(prot:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\nMATCH (prot2:Protein)-[:PARTICIPATES_IN]->(pw)\nMATCH (g:Gene)-[:ENCODES]->(prot2)\nMATCH (g)-[:ASSOCIATED_WITH]->(d:Disease {name: 'Breast Cancer'})\nRETURN drug.name AS drug, pw.name AS pathway, g.symbol AS gene\nORDER BY drug.name\n\n@query DSL:\n\ntarget_disease = \"Breast Cancer\"\nresult = @query conn begin\n    @match (drug:Drug)-[:TARGETS]->(prot:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\n    @match (prot2:Protein)-[:PARTICIPATES_IN]->(pw)\n    @match (g:Gene)-[:ENCODES]->(prot2)\n    @match (g)-[:ASSOCIATED_WITH]->(d:Disease)\n    @where d.name == $target_disease\n    @return drug.name => :drug, pw.name => :pathway, g.symbol => :gene\n    @orderby drug.name\nend\n\n@graph DSL:\n\ntarget_disease = \"Breast Cancer\"\nresult = @graph conn begin\n    drug::Drug >> ::TARGETS >> prot::Protein >> ::PARTICIPATES_IN >> pw::Pathway\n    prot2::Protein >> ::PARTICIPATES_IN >> pw\n    g::Gene >> ::ENCODES >> prot2\n    g >> ::ASSOCIATED_WITH >> d::Disease\n    where(d.name == $target_disease)\n    ret(drug.name => :drug, pw.name => :pathway, g.symbol => :gene)\n    order(drug.name)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.3-Patient-cohort-analysis-with-optional-trial-enrollment","page":"Biomedical Case Study","title":"4.3 Patient cohort analysis with optional trial enrollment","text":"Raw Cypher:\n\nMATCH (pt:Patient)-[dx:DIAGNOSED_WITH]->(d:Disease)\nOPTIONAL MATCH (pt)-[e:ENROLLED_IN]->(ct:ClinicalTrial)\nRETURN pt.patient_id AS patient, d.name AS disease,\n       dx.stage AS stage, ct.trial_id AS trial\nORDER BY d.name, pt.patient_id\n\n@query DSL:\n\nresult = @query conn begin\n    @match (pt:Patient)-[dx:DIAGNOSED_WITH]->(d:Disease)\n    @optional_match (pt)-[e:ENROLLED_IN]->(ct:ClinicalTrial)\n    @return pt.patient_id => :patient, d.name => :disease,\n            dx.stage => :stage, ct.trial_id => :trial\n    @orderby d.name pt.patient_id\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    pt::Patient >> dx::DIAGNOSED_WITH >> d::Disease\n    optional(pt >> e::ENROLLED_IN >> ct::ClinicalTrial)\n    ret(pt.patient_id => :patient, d.name => :disease,\n        dx.stage => :stage, ct.trial_id => :trial)\n    order(d.name, pt.patient_id)\nend\n\noptional() maps to OPTIONAL MATCH and accepts the same >> chain patterns.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.4-Aggregation:-drug-count-and-average-efficacy-per-disease","page":"Biomedical Case Study","title":"4.4 Aggregation: drug count and average efficacy per disease","text":"Raw Cypher:\n\nMATCH (drug:Drug)-[t:TREATS]->(d:Disease)\nWITH d.name AS disease, count(drug) AS drug_count, avg(t.efficacy) AS mean_efficacy\nWHERE drug_count > 1\nRETURN disease, drug_count, mean_efficacy\nORDER BY drug_count DESC\n\n@query DSL:\n\nresult = @query conn begin\n    @match (drug:Drug)-[t:TREATS]->(d:Disease)\n    @with d.name => :disease, count(drug) => :drug_count, avg(t.efficacy) => :mean_efficacy\n    @where drug_count > 1\n    @return disease, drug_count, mean_efficacy\n    @orderby drug_count :desc\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    drug::Drug >> t::TREATS >> d::Disease\n    with(d.name => :disease, count(drug) => :drug_count, avg(t.efficacy) => :mean_efficacy)\n    where(drug_count > 1)\n    ret(disease, drug_count, mean_efficacy)\n    order(drug_count, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.5-Side-effect-overlap-between-drugs","page":"Biomedical Case Study","title":"4.5 Side effect overlap between drugs","text":"Raw Cypher:\n\nMATCH (d1:Drug)-[:HAS_SIDE_EFFECT]->(s:Symptom)\nMATCH (d2:Drug)-[:HAS_SIDE_EFFECT]->(s)\nWHERE d1.name < d2.name\nRETURN d1.name AS drug1, d2.name AS drug2, collect(s.name) AS shared_effects\nORDER BY d1.name\n\n@query DSL:\n\nresult = @query conn begin\n    @match (d1:Drug)-[:HAS_SIDE_EFFECT]->(s:Symptom)\n    @match (d2:Drug)-[:HAS_SIDE_EFFECT]->(s)\n    @where d1.name < d2.name\n    @return d1.name => :drug1, d2.name => :drug2, collect(s.name) => :shared_effects\n    @orderby d1.name\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    d1::Drug >> ::HAS_SIDE_EFFECT >> s::Symptom\n    d2::Drug >> ::HAS_SIDE_EFFECT >> s\n    where(d1.name < d2.name)\n    ret(d1.name => :drug1, d2.name => :drug2, collect(s.name) => :shared_effects)\n    order(d1.name)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.6-Full-patient-journey-—-diagnosis-to-treatment","page":"Biomedical Case Study","title":"4.6 Full patient journey — diagnosis to treatment","text":"Raw Cypher:\n\nMATCH (pt:Patient {patient_id: $pid})-[dx:DIAGNOSED_WITH]->(d:Disease)\nMATCH (drug:Drug)-[t:TREATS]->(d)\nOPTIONAL MATCH (pt)-[e:ENROLLED_IN]->(ct:ClinicalTrial)\nOPTIONAL MATCH (drug)-[:HAS_SIDE_EFFECT]->(se:Symptom)\nRETURN d.name AS disease, drug.name AS drug_option,\n       t.efficacy AS efficacy, ct.title AS trial,\n       collect(se.name) AS side_effects\nORDER BY t.efficacy DESC\n\n@query DSL:\n\npid = \"PT-2024-001\"\nresult = @query conn begin\n    @match (pt:Patient)-[dx:DIAGNOSED_WITH]->(d:Disease)\n    @match (drug:Drug)-[t:TREATS]->(d)\n    @where pt.patient_id == $pid\n    @optional_match (pt)-[e:ENROLLED_IN]->(ct:ClinicalTrial)\n    @optional_match (drug)-[:HAS_SIDE_EFFECT]->(se:Symptom)\n    @return d.name => :disease, drug.name => :drug_option,\n            t.efficacy => :efficacy, ct.title => :trial,\n            collect(se.name) => :side_effects\n    @orderby t.efficacy :desc\nend\n\n@graph DSL:\n\npid = \"PT-2024-001\"\nresult = @graph conn begin\n    pt::Patient >> dx::DIAGNOSED_WITH >> d::Disease\n    drug::Drug >> t::TREATS >> d\n    where(pt.patient_id == $pid)\n    optional(pt >> e::ENROLLED_IN >> ct::ClinicalTrial)\n    optional(drug >> ::HAS_SIDE_EFFECT >> se::Symptom)\n    ret(d.name => :disease, drug.name => :drug_option,\n        t.efficacy => :efficacy, ct.title => :trial,\n        collect(se.name) => :side_effects)\n    order(t.efficacy, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.7-Genes-with-multiple-disease-associations","page":"Biomedical Case Study","title":"4.7 Genes with multiple disease associations","text":"Raw Cypher:\n\nMATCH (g:Gene)-[a:ASSOCIATED_WITH]->(d:Disease)\nWITH g.symbol AS gene, count(d) AS disease_count, collect(d.name) AS diseases\nWHERE disease_count >= $min_diseases\nRETURN gene, disease_count, diseases\nORDER BY disease_count DESC\n\n@query DSL:\n\nmin_diseases = 2\nresult = @query conn begin\n    @match (g:Gene)-[a:ASSOCIATED_WITH]->(d:Disease)\n    @with g.symbol => :gene, count(d) => :disease_count, collect(d.name) => :diseases\n    @where disease_count >= $min_diseases\n    @return gene, disease_count, diseases\n    @orderby disease_count :desc\nend\n\n@graph DSL:\n\nmin_diseases = 2\nresult = @graph conn begin\n    g::Gene >> a::ASSOCIATED_WITH >> d::Disease\n    with(g.symbol => :gene, count(d) => :disease_count, collect(d.name) => :diseases)\n    where(disease_count >= $min_diseases)\n    ret(gene, disease_count, diseases)\n    order(disease_count, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.8-Hospital-physician-coverage","page":"Biomedical Case Study","title":"4.8 Hospital physician coverage","text":"Raw Cypher:\n\nMATCH (ph:Physician)-[:LOCATED_AT]->(h:Hospital)\nRETURN h.name AS hospital, collect(ph.specialty) AS specialties,\n       count(ph) AS physician_count\nORDER BY physician_count DESC\n\n@query DSL:\n\nresult = @query conn begin\n    @match (ph:Physician)-[:LOCATED_AT]->(h:Hospital)\n    @return h.name => :hospital, collect(ph.specialty) => :specialties,\n            count(ph) => :physician_count\n    @orderby physician_count :desc\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    ph::Physician >> ::LOCATED_AT >> h::Hospital\n    ret(h.name => :hospital, collect(ph.specialty) => :specialties,\n        count(ph) => :physician_count)\n    order(physician_count, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.9-Biomarker-guided-treatment-selection","page":"Biomedical Case Study","title":"4.9 Biomarker-guided treatment selection","text":"Raw Cypher:\n\nMATCH (bm:Biomarker)-[:INDICATES]->(d:Disease)\nMATCH (drug:Drug)-[:TREATS]->(d)\nRETURN bm.name AS biomarker, d.name AS disease,\n       drug.name AS drug, drug.mechanism AS mechanism\nORDER BY bm.name, drug.name\n\n@query DSL:\n\nresult = @query conn begin\n    @match (bm:Biomarker)-[:INDICATES]->(d:Disease)\n    @match (drug:Drug)-[:TREATS]->(d)\n    @return bm.name => :biomarker, d.name => :disease,\n            drug.name => :drug, drug.mechanism => :mechanism\n    @orderby bm.name drug.name\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    bm::Biomarker >> ::INDICATES >> d::Disease\n    drug::Drug >> ::TREATS >> d\n    ret(bm.name => :biomarker, d.name => :disease,\n        drug.name => :drug, drug.mechanism => :mechanism)\n    order(bm.name, drug.name)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.10-Full-knowledge-chain:-Biomarker-Disease-Gene-Protein-Pathway","page":"Biomedical Case Study","title":"4.10 Full knowledge chain: Biomarker → Disease → Gene → Protein → Pathway","text":"Raw Cypher:\n\nMATCH (bm:Biomarker)-[:INDICATES]->(d:Disease)\nMATCH (g:Gene)-[:ASSOCIATED_WITH]->(d)\nMATCH (g)-[:ENCODES]->(p:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\nRETURN bm.name AS biomarker, d.name AS disease,\n       g.symbol AS gene, p.name AS protein, pw.name AS pathway\nORDER BY d.name, g.symbol\n\n@query DSL:\n\nresult = @query conn begin\n    @match (bm:Biomarker)-[:INDICATES]->(d:Disease)\n    @match (g:Gene)-[:ASSOCIATED_WITH]->(d)\n    @match (g)-[:ENCODES]->(p:Protein)-[:PARTICIPATES_IN]->(pw:Pathway)\n    @return bm.name => :biomarker, d.name => :disease,\n            g.symbol => :gene, p.name => :protein, pw.name => :pathway\n    @orderby d.name g.symbol\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    bm::Biomarker >> ::INDICATES >> d::Disease\n    g::Gene >> ::ASSOCIATED_WITH >> d\n    g >> ::ENCODES >> p::Protein >> ::PARTICIPATES_IN >> pw::Pathway\n    ret(bm.name => :biomarker, d.name => :disease,\n        g.symbol => :gene, p.name => :protein, pw.name => :pathway)\n    order(d.name, g.symbol)\nend\n\nA five-hop traversal across the entire knowledge base — expressed as readable Julia. The >> chains make the directionality explicit and composable.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.11-Batch-insert-with-UNWIND","page":"Biomedical Case Study","title":"4.11 Batch insert with UNWIND","text":"Raw Cypher:\n\nUNWIND $adverse_events AS ae\nMATCH (drug:Drug)\nWHERE drug.name = ae.drug_name\nCREATE (drug)-[:REPORTED_AE]->(event:AdverseEvent)\nSET event.name = ae.event, event.grade = ae.grade\nRETURN drug.name AS drug, event.name AS event, event.grade AS grade\n\n@query DSL:\n\nadverse_events = [\n    Dict(\"drug_name\" => \"Trastuzumab\", \"event\" => \"Cardiotoxicity\", \"grade\" => 2),\n    Dict(\"drug_name\" => \"Erlotinib\", \"event\" => \"Rash\", \"grade\" => 1),\n    Dict(\"drug_name\" => \"Pembrolizumab\", \"event\" => \"Pneumonitis\", \"grade\" => 3),\n    Dict(\"drug_name\" => \"Olaparib\", \"event\" => \"Anemia\", \"grade\" => 2),\n]\n\nresult = @query conn begin\n    @unwind $adverse_events => :ae\n    @match (drug:Drug)\n    @where drug.name == ae.drug_name\n    @create (drug)-[:REPORTED_AE]->(event:AdverseEvent)\n    @set event.name = ae.event\n    @set event.grade = ae.grade\n    @return drug.name => :drug, event.name => :event, event.grade => :grade\nend\n\n@graph DSL:\n\nadverse_events = [\n    Dict(\"drug_name\" => \"Trastuzumab\", \"event\" => \"Cardiotoxicity\", \"grade\" => 2),\n    Dict(\"drug_name\" => \"Erlotinib\", \"event\" => \"Rash\", \"grade\" => 1),\n    Dict(\"drug_name\" => \"Pembrolizumab\", \"event\" => \"Pneumonitis\", \"grade\" => 3),\n    Dict(\"drug_name\" => \"Olaparib\", \"event\" => \"Anemia\", \"grade\" => 2),\n]\n\nresult = @graph conn begin\n    unwind($adverse_events => :ae)\n    drug::Drug\n    where(drug.name == ae.drug_name)\n    create((drug) - [::REPORTED_AE] -> (event::AdverseEvent))\n    event.name = ae.event\n    event.grade = ae.grade\n    ret(drug.name => :drug, event.name => :event, event.grade => :grade)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.12-Complex-WHERE-with-string-functions","page":"Biomedical Case Study","title":"4.12 Complex WHERE with string functions","text":"Raw Cypher:\n\nMATCH (g:Gene)-[:ASSOCIATED_WITH]->(d:Disease)\nWHERE g.chromosome STARTS WITH '17' AND d.category = 'Oncology'\nRETURN g.symbol AS gene, g.chromosome AS chr, d.name AS disease\nORDER BY g.symbol\n\n@query DSL:\n\nresult = @query conn begin\n    @match (g:Gene)-[:ASSOCIATED_WITH]->(d:Disease)\n    @where startswith(g.chromosome, \"17\") && d.category == \"Oncology\"\n    @return g.symbol => :gene, g.chromosome => :chr, d.name => :disease\n    @orderby g.symbol\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    g::Gene >> ::ASSOCIATED_WITH >> d::Disease\n    where(startswith(g.chromosome, \"17\"), d.category == \"Oncology\")\n    ret(g.symbol => :gene, g.chromosome => :chr, d.name => :disease)\n    order(g.symbol)\nend\n\nMulti-condition where() auto-ANDs conditions — no need for &&.\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.13-WITH-pipeline-—-treatment-landscape","page":"Biomedical Case Study","title":"4.13 WITH pipeline — treatment landscape","text":"Raw Cypher:\n\nMATCH (drug:Drug)-[t:TREATS]->(d:Disease)\nWITH d, count(drug) AS n_drugs, avg(t.efficacy) AS avg_eff\nMATCH (g:Gene)-[:ASSOCIATED_WITH]->(d)\nRETURN d.name AS disease, n_drugs, avg_eff, count(g) AS n_genes\nORDER BY n_drugs DESC\n\n@query DSL:\n\nresult = @query conn begin\n    @match (drug:Drug)-[t:TREATS]->(d:Disease)\n    @with d, count(drug) => :n_drugs, avg(t.efficacy) => :avg_eff\n    @match (g:Gene)-[:ASSOCIATED_WITH]->(d)\n    @return d.name => :disease, n_drugs, avg_eff,\n            count(g) => :n_genes\n    @orderby n_drugs :desc\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    drug::Drug >> t::TREATS >> d::Disease\n    with(d, count(drug) => :n_drugs, avg(t.efficacy) => :avg_eff)\n    g::Gene >> ::ASSOCIATED_WITH >> d\n    ret(d.name => :disease, n_drugs, avg_eff, count(g) => :n_genes)\n    order(n_drugs, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#4.14-Publication-Disease-knowledge-network","page":"Biomedical Case Study","title":"4.14 Publication → Disease knowledge network","text":"Raw Cypher:\n\nMATCH (pub:Publication)-[:PUBLISHED_IN]->(d:Disease)\nMATCH (drug:Drug)-[:TREATS]->(d)\nWITH pub, d, collect(drug.name) AS drugs\nRETURN pub.title AS publication, pub.journal AS journal,\n       d.name AS disease, drugs\nORDER BY pub.year DESC\n\n@query DSL:\n\nresult = @query conn begin\n    @match (pub:Publication)-[:PUBLISHED_IN]->(d:Disease)\n    @match (drug:Drug)-[:TREATS]->(d)\n    @with pub, d, collect(drug.name) => :drugs\n    @return pub.title => :publication, pub.journal => :journal,\n            d.name => :disease, drugs\n    @orderby pub.year :desc\nend\n\n@graph DSL:\n\nresult = @graph conn begin\n    pub::Publication >> ::PUBLISHED_IN >> d::Disease\n    drug::Drug >> ::TREATS >> d\n    with(pub, d, collect(drug.name) => :drugs)\n    ret(pub.title => :publication, pub.journal => :journal,\n        d.name => :disease, drugs)\n    order(pub.year, :desc)\nend\n\n","category":"section"},{"location":"guide/biomedical_case_study/#Key-takeaways","page":"Biomedical Case Study","title":"Key takeaways","text":"Aspect Raw Cypher @query DSL @graph DSL\nInjection safety Manual parameterisation Automatic — $var captures safely Same — $var captures safely\nSchema validation None built-in @node/@rel with runtime checks Same shared schema registry\nNode references Re-match by property elementId() via @relate match() + where() + create()\nPatterns (p:Person)-[r:KNOWS]->(q:Person) Same Cypher-like syntax p::Person >> r::KNOWS >> q::Person\nClauses Cypher keywords @match, @where, @return where(), ret(), order()\nOperator mapping <>, AND, STARTS WITH !=, &&, startswith Same Julia-native operators\nReturn aliases expr AS alias expr => :alias expr => :alias\nMutations CREATE, SET @create, @set create() + auto-SET assignments\nOPTIONAL MATCH OPTIONAL MATCH @optional_match optional()\nCompile-time String at runtime Cypher assembled at macro expansion Same — identical Cypher output","category":"section"},{"location":"guide/biomedical_case_study/#@query-vs-@graph-—-when-to-use-which?","page":"Biomedical Case Study","title":"@query vs @graph — when to use which?","text":"@query — closest to raw Cypher; familiar if you already know Cypher syntax. Best with @create/@relate for schema-validated mutations.\n@graph — Julia-native feel with :: type annotation syntax and >> chain operators. Best for complex multi-hop traversals where the chain notation improves readability.\n\nBoth compile to identical Cypher at macro expansion time — there is zero runtime overhead for query construction. Only parameter values are captured at runtime.","category":"section"},{"location":"getting_started/#getting-started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Neo4jQuery.jl is currently installed from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/algunion/Neo4jQuery.jl\")","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"You need a running Neo4j instance (5.x or later) with the Query API v2 enabled. This is the default for:\n\nNeo4j Aura (cloud)\nNeo4j Community / Enterprise 5.x+ (self-hosted)","category":"section"},{"location":"getting_started/#Connecting","page":"Getting Started","title":"Connecting","text":"The simplest way to connect:\n\nusing Neo4jQuery\n\nconn = connect(\"localhost\", \"neo4j\";\n    port=7474,\n    auth=BasicAuth(\"neo4j\", \"password\"),\n    scheme=\"http\")\n\nOr load credentials from environment variables / a .env file:\n\n# .env file:\n# NEO4J_URI=neo4j+s://xxxx.databases.neo4j.io\n# NEO4J_USERNAME=neo4j\n# NEO4J_PASSWORD=secret\n# NEO4J_DATABASE=neo4j\n\nconn = connect_from_env(path=\".env\")\n\nSee Connections for full details.","category":"section"},{"location":"getting_started/#Your-First-Query","page":"Getting Started","title":"Your First Query","text":"# Create a node\nresult = query(conn,\n    \"CREATE (p:Person {name: \\$name, age: \\$age}) RETURN p\",\n    parameters=Dict{String,Any}(\"name\" => \"Alice\", \"age\" => 30);\n    include_counters=true)\n\nprintln(result[1].p)           # Node(:Person {name: \"Alice\", age: 30})\nprintln(result.counters)        # QueryCounters(nodes_created=1, properties_set=2, labels_added=1)\n\n# Read it back with the @cypher_str macro\nname = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p.name AS name, p.age AS age\"\nresult = query(conn, q; access_mode=:read)\nprintln(result[1].name)         # \"Alice\"","category":"section"},{"location":"getting_started/#Quick-DSL-Example","page":"Getting Started","title":"Quick DSL Example","text":"The DSL lets you write graph queries in Julia syntax:\n\n# Define your data model\n@node Person begin\n    name::String\n    age::Int\nend\n\n@rel KNOWS begin\n    since::Int\nend\n\n# Create nodes\nalice = @create conn Person(name=\"Alice\", age=30)\nbob   = @create conn Person(name=\"Bob\", age=25)\n\n# Create a relationship between them\nrel = @relate conn alice => KNOWS(since=2024) => bob\n\n# Query the graph\nmin_age = 20\nresult = @query conn begin\n    @match (p:Person)-[r:KNOWS]->(friend:Person)\n    @where p.name == \"Alice\" && friend.age > $min_age\n    @return friend.name => :name, r.since => :since\nend\n\nfor row in result\n    println(row.name, \" — known since \", row.since)\nend\n\nSee DSL for the full guide with advanced examples.","category":"section"},{"location":"getting_started/#Quick-@graph-Example","page":"Getting Started","title":"Quick @graph Example","text":"The @graph macro provides a hyper-ergonomic alternative with Julia-native syntax:\n\n# Same query as above, but with @graph syntax\nmin_age = 20\nresult = @graph conn begin\n    p::Person >> r::KNOWS >> friend::Person\n    where(p.name == \"Alice\", friend.age > $min_age)\n    ret(friend.name => :name, r.since => :since)\n    order(r.since, :desc)\nend\n\n# Or as a one-liner comprehension\nresult = @graph conn [p.name for p in Person if p.age > 20]\n\n# Mutations with auto-SET\n@graph conn begin\n    p::Person\n    where(p.name == \"Alice\")\n    p.age = 31\n    ret(p)\nend\n\nSee DSL — @graph for the full guide.","category":"section"},{"location":"getting_started/#What's-Next?","page":"Getting Started","title":"What's Next?","text":"Queries — parameterised queries, counters, bookmarks\nTransactions — explicit begin/commit/rollback and do-block API\nStreaming — memory-efficient row-by-row iteration\nDSL — @query, @create, @merge, @relate macros\nAPI Reference — full function and type documentation","category":"section"},{"location":"guide/dsl/#dsl","page":"DSL","title":"DSL","text":"Neo4jQuery includes a compile-time DSL that translates Julia expressions into parameterised Cypher. This gives you type-safe, injection-proof graph operations with Julia-native syntax.","category":"section"},{"location":"guide/dsl/#Schema-declarations","page":"DSL","title":"Schema declarations","text":"Register node and relationship schemas for validation:\n\n@node Person begin\n    name::String\n    age::Int\n    email::String = \"\"    # optional, with default\nend\n\n@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\nSchemas are stored in a global registry and used by mutation macros to validate properties at runtime.\n\n# Look up registered schemas\nschema = get_node_schema(:Person)\nschema = get_rel_schema(:KNOWS)\n\n# Label-only schemas (no properties)\n@node Marker\n@rel LINKS","category":"section"},{"location":"guide/dsl/#Property-validation","page":"DSL","title":"Property validation","text":"validate_node_properties(schema, Dict{String,Any}(\"name\" => \"Alice\", \"age\" => 30))\n# Throws if required properties are missing\n# Warns on unknown properties\n\n# Works the same way for relationships\nrel_schema = get_rel_schema(:KNOWS)\nvalidate_rel_properties(rel_schema, Dict{String,Any}(\"since\" => 2024))","category":"section"},{"location":"guide/dsl/#@query-—-the-query-builder","page":"DSL","title":"@query — the query builder","text":"The main DSL macro compiles a Julia block into a single parameterised Cypher query:\n\nresult = @query conn begin\n    @match (p:Person)-[r:KNOWS]->(q:Person)\n    @where p.age > 25 && q.name != \"Bob\"\n    @return p.name => :name, q.name => :friend, r.since => :year\n    @orderby p.name\n    @limit 10\nend\n\nThis expands at compile time into:\n\nMATCH (p:Person)-[r:KNOWS]->(q:Person)\nWHERE p.age > 25 AND q.name <> 'Bob'\nRETURN p.name AS name, q.name AS friend, r.since AS year\nORDER BY p.name\nLIMIT 10","category":"section"},{"location":"guide/dsl/#Available-clauses","page":"DSL","title":"Available clauses","text":"Clause Description\n@match MATCH pattern\n@optional_match OPTIONAL MATCH pattern\n@where WHERE conditions\n@return RETURN expressions (with => :alias for AS)\n@with WITH projection (pipe between query parts)\n@unwind UNWIND list AS variable\n@create CREATE pattern\n@merge MERGE pattern\n@set SET property assignments (multiple SETs merge into one)\n@remove REMOVE labels or properties\n@delete DELETE variables\n@detach_delete DETACH DELETE variables\n@orderby ORDER BY expressions\n@skip SKIP n\n@limit LIMIT n\n@on_create_set ON CREATE SET (after @merge)\n@on_match_set ON MATCH SET (after @merge)\n@union UNION (deduplicated)\n@union_all UNION ALL (preserves duplicates)\n@call CALL { ... } subquery block\n@load_csv LOAD CSV FROM 'url' AS row\n@load_csv_headers LOAD CSV WITH HEADERS FROM 'url' AS row\n@foreach FOREACH (var IN expr | ...)\n@create_index CREATE INDEX FOR (n:Label) ON (n.prop)\n@drop_index DROP INDEX name IF EXISTS\n@create_constraint CREATE CONSTRAINT ... REQUIRE ... IS UNIQUE/NOT NULL\n@drop_constraint DROP CONSTRAINT name IF EXISTS","category":"section"},{"location":"guide/dsl/#Pattern-syntax","page":"DSL","title":"Pattern syntax","text":"# Labeled node\n@match (p:Person)\n\n# Anonymous labeled node\n@match (:Person)\n\n# Variable-only node\n@match (p)\n\n# Right arrow (simple directed)\n@match (a) --> (b)\n\n# Typed relationship (right arrow)\n@match (p:Person)-[r:KNOWS]->(q:Person)\n\n# Left arrow (simple)\n@match (a) <-- (b)\n\n# Typed relationship (left arrow)\n@match (a:Person)<-[r:KNOWS]-(b:Person)\n\n# Undirected relationship\n@match (a:Person)-[r:KNOWS]-(b:Person)\n\n# Variable-length relationship (range)\n@match (a:Person)-[r:KNOWS, 1, 3]->(b:Person)\n# Generates: (a:Person)-[r:KNOWS*1..3]->(b:Person)\n\n# Variable-length relationship (exact)\n@match (a:Person)-[r:KNOWS, 2]->(b:Person)\n# Generates: (a:Person)-[r:KNOWS*2]->(b:Person)\n\n# Chained path\n@match (a)-[r:R]->(b)-[s:S]->(c)\n\n# Multiple patterns (comma-separated)\n@match (p:Person), (c:Company)","category":"section"},{"location":"guide/dsl/#WHERE-operators","page":"DSL","title":"WHERE operators","text":"Julia operators are translated to Cypher:\n\nJulia Cypher\n== =\n!= <>\n&& AND\n|| OR\n! NOT\n>= >=\n<= <=\n>, < >, <\nstartswith STARTS WITH\nendswith ENDS WITH\ncontains CONTAINS\nin / ∈ IN\nisnothing IS NULL\nmatches =~ (regex match)\nexists((p)-[:R]->(q)) EXISTS { MATCH ... }\nif ... elseif ... else ... end CASE WHEN ... THEN ... ELSE ... END\n\nArithmetic operators (+, -, *, /, %, ^) are also supported within expressions:\n\n@where p.score * 2 + 10 > $threshold\n@where p.id % 2 == 0","category":"section"},{"location":"guide/dsl/#Parameter-capture","page":"DSL","title":"Parameter capture","text":"$var references in the DSL capture Julia variables as safe Cypher parameters:\n\nmin_age = 25\nresult = @query conn begin\n    @match (p:Person)\n    @where p.age > $min_age\n    @return p.name => :name\nend\n\nParameters work in @where, @set, @unwind, @skip, and @limit clauses.","category":"section"},{"location":"guide/dsl/#Complete-end-to-end-example","page":"DSL","title":"Complete end-to-end example","text":"This example shows a full workflow: defining schemas, creating data, establishing relationships, and querying with the DSL.","category":"section"},{"location":"guide/dsl/#Step-1:-Define-your-graph-model","page":"DSL","title":"Step 1: Define your graph model","text":"using Neo4jQuery\n\n# Define node schemas\n@node Person begin\n    name::String\n    age::Int\n    email::String = \"\"\nend\n\n@node Company begin\n    name::String\n    founded::Int\n    industry::String = \"Technology\"\nend\n\n# Define relationship schemas\n@rel KNOWS begin\n    since::Int\n    weight::Float64 = 1.0\nend\n\n@rel WORKS_AT begin\n    role::String\n    since::Int\nend","category":"section"},{"location":"guide/dsl/#Step-2:-Create-nodes-using-the-schemas","page":"DSL","title":"Step 2: Create nodes using the schemas","text":"# @create validates properties against the registered Person schema\nalice = @create conn Person(name=\"Alice\", age=30, email=\"alice@example.com\")\nbob   = @create conn Person(name=\"Bob\", age=25)\ncarol = @create conn Person(name=\"Carol\", age=35)\n\nacme  = @create conn Company(name=\"Acme Corp\", founded=2010)","category":"section"},{"location":"guide/dsl/#Step-3:-Create-relationships","page":"DSL","title":"Step 3: Create relationships","text":"# @relate uses elementId() to match existing nodes\nrel1 = @relate conn alice => KNOWS(since=2020) => bob\nrel2 = @relate conn alice => KNOWS(since=2022, weight=0.8) => carol\nrel3 = @relate conn bob => KNOWS(since=2023) => carol\n\n# Relationships to companies\n@relate conn alice => WORKS_AT(role=\"Engineer\", since=2021) => acme\n@relate conn bob => WORKS_AT(role=\"Designer\", since=2022) => acme","category":"section"},{"location":"guide/dsl/#Step-4:-Query-with-the-DSL","page":"DSL","title":"Step 4: Query with the DSL","text":"# Find Alice's friends\nmin_age = 20\nresult = @query conn begin\n    @match (p:Person)-[r:KNOWS]->(friend:Person)\n    @where p.name == \"Alice\" && friend.age > $min_age\n    @return friend.name => :name, r.since => :since\n    @orderby r.since :desc\nend\n\nfor row in result\n    println(row.name, \" — known since \", row.since)\nend\n# Bob — known since 2020\n# Carol — known since 2022","category":"section"},{"location":"guide/dsl/#Step-5:-Aggregation-with-WITH","page":"DSL","title":"Step 5: Aggregation with WITH","text":"# Find the most connected people\nmin_connections = 1\nresult = @query conn begin\n    @match (p:Person)-[r:KNOWS]->(q:Person)\n    @with p, count(r) => :degree\n    @where degree > $min_connections\n    @orderby degree :desc\n    @return p.name => :person, degree\nend\n\nfor row in result\n    println(row.person, \": \", row.degree, \" connections\")\nend","category":"section"},{"location":"guide/dsl/#Step-6:-Friend-of-friend-recommendations","page":"DSL","title":"Step 6: Friend-of-friend recommendations","text":"my_name = \"Bob\"\nresult = @query conn begin\n    @match (me:Person)-[:KNOWS]->(friend:Person)-[:KNOWS]->(fof:Person)\n    @where me.name == $my_name && fof.name != me.name\n    @return distinct fof.name => :suggestion\n    @limit 10\nend","category":"section"},{"location":"guide/dsl/#Step-7:-Updating-data","page":"DSL","title":"Step 7: Updating data","text":"# Update a single property\nname = \"Alice\"\nnew_email = \"alice@newdomain.com\"\n@query conn begin\n    @match (p:Person)\n    @where p.name == $name\n    @set p.email = $new_email\n    @return p\nend\n\n# Update multiple properties at once (SET clauses merge automatically)\nnew_age = 31\nnew_email2 = \"alice@latest.com\"\n@query conn begin\n    @match (p:Person)\n    @where p.name == $name\n    @set p.age = $new_age\n    @set p.email = $new_email2\n    @return p\nend\n# Generates: SET p.age = $new_age, p.email = $new_email2","category":"section"},{"location":"guide/dsl/#Step-8:-MERGE-with-conditional-SET","page":"DSL","title":"Step 8: MERGE with conditional SET","text":"# Upsert a node — set different properties on create vs match\nnode = @merge conn Person(name=\"Alice\") on_create(age=30) on_match(last_seen=\"2025-02-15\")\n\nOr using @query for more complex patterns:\n\nnow = \"2025-02-15\"\n@query conn begin\n    @merge (p:Person)\n    @on_create_set p.created_at = $now\n    @on_match_set p.last_seen = $now\n    @return p\nend","category":"section"},{"location":"guide/dsl/#Step-9:-Batch-operations-with-UNWIND","page":"DSL","title":"Step 9: Batch operations with UNWIND","text":"# Create multiple nodes from a list\npeople = [\n    Dict(\"name\" => \"Dave\", \"age\" => 28),\n    Dict(\"name\" => \"Eve\", \"age\" => 22),\n    Dict(\"name\" => \"Frank\", \"age\" => 40),\n]\n\n@query conn begin\n    @unwind $people => :person\n    @create (p:Person)\n    @set p.name = person.name\n    @set p.age = person.age\n    @return p\nend","category":"section"},{"location":"guide/dsl/#Step-10:-OPTIONAL-MATCH-for-optional-relationships","page":"DSL","title":"Step 10: OPTIONAL MATCH for optional relationships","text":"# Get all people and their employer (if any)\nresult = @query conn begin\n    @match (p:Person)\n    @optional_match (p)-[w:WORKS_AT]->(c:Company)\n    @return p.name => :person, c.name => :company, w.role => :role\n    @orderby p.name\nend\n\nfor row in result\n    if row.company !== nothing\n        println(row.person, \" works at \", row.company, \" as \", row.role)\n    else\n        println(row.person, \" — no employer\")\n    end\nend","category":"section"},{"location":"guide/dsl/#Step-11:-Pagination-with-SKIP-and-LIMIT","page":"DSL","title":"Step 11: Pagination with SKIP and LIMIT","text":"page = 2\npage_size = 10\noffset = (page - 1) * page_size\n\nresult = @query conn begin\n    @match (p:Person)\n    @return p.name => :name, p.age => :age\n    @orderby p.name\n    @skip $offset\n    @limit $page_size\nend","category":"section"},{"location":"guide/dsl/#Step-12:-Deleting-data","page":"DSL","title":"Step 12: Deleting data","text":"# Delete a specific node and its relationships\ntarget = \"Frank\"\n@query conn begin\n    @match (p:Person)\n    @where p.name == $target\n    @detach_delete p\nend\n\n# Remove a property\n@query conn begin\n    @match (p:Person)\n    @remove p.email\n    @return p\nend","category":"section"},{"location":"guide/dsl/#Step-13:-Complex-WHERE-conditions","page":"DSL","title":"Step 13: Complex WHERE conditions","text":"# Combine multiple conditions with string functions\nresult = @query conn begin\n    @match (p:Person)\n    @where startswith(p.name, \"A\") && !(isnothing(p.email)) && p.age >= 18\n    @return p.name => :name, p.email => :email\nend\n\n# IN operator with a parameter\nallowed_names = [\"Alice\", \"Bob\", \"Carol\"]\nresult = @query conn begin\n    @match (p:Person)\n    @where in(p.name, $allowed_names)\n    @return p\nend","category":"section"},{"location":"guide/dsl/#Step-14:-Aggregation-functions","page":"DSL","title":"Step 14: Aggregation functions","text":"result = @query conn begin\n    @match (p:Person)\n    @return count(p) => :total, avg(p.age) => :avg_age, collect(p.name) => :names\nend\n\nprintln(\"Total: \", result[1].total)\nprintln(\"Average age: \", result[1].avg_age)\nprintln(\"Names: \", result[1].names)","category":"section"},{"location":"guide/dsl/#Step-15:-Pattern-direction-variants","page":"DSL","title":"Step 15: Pattern direction variants","text":"# Left-arrow — match incoming relationships\nresult = @query conn begin\n    @match (a:Person)<-[r:KNOWS]-(b:Person)\n    @return a.name => :target, b.name => :source, r.since => :since\nend\n\n# Undirected — match regardless of direction\nresult = @query conn begin\n    @match (a:Person)-[r:KNOWS]-(b:Person)\n    @return a.name => :person1, b.name => :person2\nend\n\n# Variable-length — find paths of 1 to 3 hops\nresult = @query conn begin\n    @match (a:Person)-[r:KNOWS, 1, 3]->(b:Person)\n    @return a.name => :start, b.name => :reachable\nend","category":"section"},{"location":"guide/dsl/#Step-16:-Regex-matching","page":"DSL","title":"Step 16: Regex matching","text":"# Find names matching a pattern\nresult = @query conn begin\n    @match (p:Person)\n    @where matches(p.name, \"^A.*e\\$\")\n    @return p.name => :name\nend","category":"section"},{"location":"guide/dsl/#Step-17:-CASE/WHEN-expressions","page":"DSL","title":"Step 17: CASE/WHEN expressions","text":"Use Julia's if/elseif/else/end syntax to generate Cypher CASE expressions:\n\nresult = @query conn begin\n    @match (p:Person)\n    @return p.name => :name, if p.age > 65; \"senior\"; elseif p.age > 30; \"adult\"; else; \"young\"; end => :category\nend\n\nThis generates:\n\nRETURN p.name AS name, CASE WHEN p.age > 65 THEN 'senior' WHEN p.age > 30 THEN 'adult' ELSE 'young' END AS category","category":"section"},{"location":"guide/dsl/#Step-18:-EXISTS-subqueries","page":"DSL","title":"Step 18: EXISTS subqueries","text":"# Find people who have at least one friend\nresult = @query conn begin\n    @match (p:Person)\n    @where exists((p)-[:KNOWS]->(:Person))\n    @return p.name => :name\nend\n\n# Negated EXISTS\nresult = @query conn begin\n    @match (p:Person)\n    @where !(exists((p)-[:KNOWS]->(:Person)))\n    @return p.name => :loner\nend","category":"section"},{"location":"guide/dsl/#Step-19:-UNION-and-UNION-ALL","page":"DSL","title":"Step 19: UNION and UNION ALL","text":"Combine multiple query parts:\n\n# UNION (deduplicated results)\nresult = @query conn begin\n    @match (p:Person)\n    @where p.age > 30\n    @return p.name => :name\n    @union\n    @match (p:Person)\n    @where startswith(p.name, \"A\")\n    @return p.name => :name\nend\n\n# UNION ALL (preserves duplicates)\nresult = @query conn begin\n    @match (p:Person)\n    @return p.name => :name\n    @union_all\n    @match (c:Company)\n    @return c.name => :name\nend","category":"section"},{"location":"guide/dsl/#Step-20:-CALL-subqueries","page":"DSL","title":"Step 20: CALL subqueries","text":"Nest a full sub-query with @call:\n\nresult = @query conn begin\n    @match (p:Person)\n    @call begin\n        @with p\n        @match (p)-[r:KNOWS]->(friend:Person)\n        @return count(friend) => :friend_count\n    end\n    @return p.name => :name, friend_count\n    @orderby friend_count :desc\nend","category":"section"},{"location":"guide/dsl/#Step-21:-LOAD-CSV","page":"DSL","title":"Step 21: LOAD CSV","text":"Import data from CSV files:\n\n# Without headers (rows are arrays)\n@query conn begin\n    @load_csv \"file:///data/people.csv\" => :row\n    @create (p:Person)\n    @set p.name = row[0]\n    @set p.age = row[1]\nend\n\n# With headers (rows are maps)\n@query conn begin\n    @load_csv_headers \"file:///data/people.csv\" => :row\n    @create (p:Person)\n    @set p.name = row.name\n    @set p.age = row.age\nend","category":"section"},{"location":"guide/dsl/#Step-22:-FOREACH","page":"DSL","title":"Step 22: FOREACH","text":"Apply updates over a collection:\n\nnames = [\"Alice\", \"Bob\", \"Carol\"]\n@query conn begin\n    @match (p:Person)\n    @where in(p.name, $names)\n    @foreach n :in collect(p) begin\n        @set n.verified = true\n    end\nend\n\nFOREACH body supports @create, @merge, @set, @delete, @detach_delete, @remove, and nested @foreach.","category":"section"},{"location":"guide/dsl/#Step-23:-Index-and-constraint-management","page":"DSL","title":"Step 23: Index and constraint management","text":"# Create an index on Person.name\n@query conn begin\n    @create_index :Person :name\nend\n\n# Create a named index\n@query conn begin\n    @create_index :Person :email :person_email_idx\nend\n\n# Drop an index\n@query conn begin\n    @drop_index :person_email_idx\nend\n\n# Create a uniqueness constraint\n@query conn begin\n    @create_constraint :Person :email :unique\nend\n\n# Create a NOT NULL constraint (named)\n@query conn begin\n    @create_constraint :Person :name :not_null :person_name_required\nend\n\n# Drop a constraint\n@query conn begin\n    @drop_constraint :person_name_required\nend","category":"section"},{"location":"guide/dsl/#@graph-—-hyper-ergonomic-query-builder","page":"DSL","title":"@graph — hyper-ergonomic query builder","text":"@graph is a next-generation DSL that maximises ergonomics by leveraging Julia's metaprogramming. It compiles to the same parameterised Cypher as @query, but with a syntax designed for developer productivity over Cypher familiarity.","category":"section"},{"location":"guide/dsl/#Key-differences-from-@query","page":"DSL","title":"Key differences from @query","text":"Feature @query @graph\nNode syntax (p:Person) with @match prefix p::Person — bare Julia type annotation\nRelationship patterns (a)-[r:KNOWS]->(b) with @match prefix a::Person >> r::KNOWS >> b::Person — chain ops\nClause syntax @match, @where, @return (sub-macros) where(), ret(), order() (plain functions)\nProperty updates @set p.age = $val p.age = $val (bare assignment, auto-detected)\nMulti-condition WHERE @where cond1 && cond2 where(cond1, cond2) — auto-AND\nComprehension shorthand Not available [p.name for p in Person if p.age > 25]\nLIMIT @limit 10 take(10)\nRETURN @return expr ret(expr) or returning(expr)","category":"section"},{"location":"guide/dsl/#Pattern-syntax-2","page":"DSL","title":"Pattern syntax","text":"# Labeled node (Julia type annotation)\np::Person                    # → (p:Person)\n\n# Anonymous node\n::Person                     # → (:Person)\n\n# Right-directed chain (>> operator)\np::Person >> r::KNOWS >> q::Person\n# → (p:Person)-[r:KNOWS]->(q:Person)\n\n# Anonymous relationship in chain\np::Person >> KNOWS >> q::Person\n# → (p:Person)-[:KNOWS]->(q:Person)\n\n# Left-directed chain (<< operator)\np::Person << r::KNOWS << q::Person\n# → (p:Person)<-[r:KNOWS]-(q:Person)\n\n# Multi-hop chain\na::Person >> r::KNOWS >> b::Person >> s::WORKS_AT >> c::Company\n# → (a:Person)-[r:KNOWS]->(b:Person)-[s:WORKS_AT]->(c:Company)\n\n# Classic arrow syntax also works\n(p::Person)-[r::KNOWS]->(q::Person)\n# → (p:Person)-[r:KNOWS]->(q:Person)","category":"section"},{"location":"guide/dsl/#Clause-functions","page":"DSL","title":"Clause functions","text":"All clauses are plain function call syntax — no @ prefix needed:\n\nFunction Cypher\nwhere(cond1, cond2, ...) WHERE cond1 AND cond2 AND ...\nret(expr => :alias, ...) RETURN expr AS alias, ...\nreturning(expr => :alias) RETURN expr AS alias (alias)\nret(distinct, expr) RETURN DISTINCT expr\norder(expr, :desc) ORDER BY expr DESC\ntake(n) / skip(n) LIMIT n / SKIP n\ncreate(pattern) CREATE pattern\nmerge(pattern) MERGE pattern\noptional(pattern) OPTIONAL MATCH pattern\nmatch(p1, p2) MATCH p1, p2 (explicit multi)\nwith(expr => :alias, ...) WITH expr AS alias, ...\nunwind($list => :var) UNWIND $list AS var\ndelete(vars...) DELETE vars\ndetach_delete(vars...) DETACH DELETE vars\non_create(p.prop = val) ON CREATE SET p.prop = val\non_match(p.prop = val) ON MATCH SET p.prop = val\np.prop = $val (assignment) SET p.prop = $val (auto-detected)","category":"section"},{"location":"guide/dsl/#Basic-example","page":"DSL","title":"Basic example","text":"result = @graph conn begin\n    p::Person >> r::KNOWS >> q::Person\n    where(p.age > $min_age, q.name == $target)\n    ret(p.name => :name, r.since, q.name => :friend)\n    order(p.age, :desc)\n    take(10)\nend\n\nCompiles to:\n\nMATCH (p:Person)-[r:KNOWS]->(q:Person)\nWHERE p.age > $min_age AND q.name = $target\nRETURN p.name AS name, r.since, q.name AS friend\nORDER BY p.age DESC\nLIMIT 10","category":"section"},{"location":"guide/dsl/#Multi-hop-traversals","page":"DSL","title":"Multi-hop traversals","text":"# Three-node chain in a single line\nresult = @graph conn begin\n    a::Person >> r::KNOWS >> b::Person >> s::WORKS_AT >> c::Company\n    ret(a.name, b.name, c.name)\nend","category":"section"},{"location":"guide/dsl/#Auto-SET-from-property-assignments","page":"DSL","title":"Auto-SET from property assignments","text":"Bare assignments inside @graph automatically become SET clauses:\n\n@graph conn begin\n    p::Person\n    where(p.name == $name)\n    p.age = $new_age           # ← auto SET\n    p.email = $new_email       # ← merged into same SET clause\n    ret(p)\nend\n# → MATCH (p:Person) WHERE p.name = $name SET p.age = $new_age, p.email = $new_email RETURN p","category":"section"},{"location":"guide/dsl/#CREATE-with-chain-patterns","page":"DSL","title":"CREATE with chain patterns","text":"@graph conn begin\n    create(p::Person)\n    p.name = $name\n    p.age = $age\n    ret(p)\nend","category":"section"},{"location":"guide/dsl/#MERGE-with-on*create-/-on*match","page":"DSL","title":"MERGE with oncreate / onmatch","text":"@graph conn begin\n    merge(p::Person)\n    on_create(p.created = true)\n    on_match(p.updated = true)\n    ret(p)\nend","category":"section"},{"location":"guide/dsl/#OPTIONAL-MATCH","page":"DSL","title":"OPTIONAL MATCH","text":"@graph conn begin\n    p::Person\n    optional(p >> r::KNOWS >> q::Person)\n    ret(p.name, q.name)\nend","category":"section"},{"location":"guide/dsl/#Aggregation-with-WITH","page":"DSL","title":"Aggregation with WITH","text":"result = @graph conn begin\n    p::Person >> r::KNOWS >> q::Person\n    with(p, count(r) => :degree)\n    where(degree > $min_degree)\n    ret(p.name, degree)\nend","category":"section"},{"location":"guide/dsl/#RETURN-DISTINCT","page":"DSL","title":"RETURN DISTINCT","text":"result = @graph conn begin\n    p::Person\n    ret(distinct, p.name)\nend","category":"section"},{"location":"guide/dsl/#Comprehension-form","page":"DSL","title":"Comprehension form","text":"For simple match-filter-return queries, use Julia's comprehension syntax:\n\n# One-liner query\nresult = @graph conn [p.name for p in Person if p.age > 25]\n# → MATCH (p:Person) WHERE p.age > 25 RETURN p.name\n\n# Without filter\nresult = @graph conn [p for p in Person]\n# → MATCH (p:Person) RETURN p\n\n# Tuple return\nresult = @graph conn [(p.name, p.age) for p in Person]\n# → MATCH (p:Person) RETURN p.name, p.age\n\n# With alias\nresult = @graph conn [p.name => :n for p in Person]\n# → MATCH (p:Person) RETURN p.name AS n","category":"section"},{"location":"guide/dsl/#Keyword-arguments","page":"DSL","title":"Keyword arguments","text":"Pass query options after the block, just like @query:\n\nresult = @graph conn begin\n    p::Person\n    ret(p.name)\nend include_counters=true\n\nnote: Automatic `access_mode`\nBoth @graph and @query automatically set access_mode=:read for pure read queries (MATCH/WHERE/RETURN/ORDER BY/…) and access_mode=:write when any mutation clause is present (CREATE/MERGE/SET/DELETE/…).  You rarely need to specify it manually.  If you do, an explicit access_mode=:write (or :read) after end will override the inferred value.","category":"section"},{"location":"guide/dsl/#Known-limitations","page":"DSL","title":"Known limitations","text":"These Cypher features are not supported by the DSL macros (@query and @graph):\n\nInline property patterns in MATCH ({name: $v}) — Julia's parser cannot parse {…} as an expression; use where() / @where instead\nShortest path functions (shortestPath, allShortestPaths)\nMERGE on relationship patterns within @query (only node patterns)\nProcedure calls via CALL db.xxx() (distinct from CALL subqueries)\nMap projections and list comprehensions in Cypher sense\n@graph does not yet support @call subqueries, @load_csv, @foreach, or index/constraint management — use @query for those","category":"section"},{"location":"guide/dsl/#Standalone-mutations","page":"DSL","title":"Standalone mutations","text":"For common single-entity operations, use the dedicated macros:","category":"section"},{"location":"guide/dsl/#@create-—-create-a-node","page":"DSL","title":"@create — create a node","text":"node = @create conn Person(name=\"Alice\", age=30)\n# Returns: Node\n\nValidates against the registered Person schema (if present).","category":"section"},{"location":"guide/dsl/#@merge-—-upsert-a-node","page":"DSL","title":"@merge — upsert a node","text":"node = @merge conn Person(name=\"Alice\") on_create(age=30, email=\"a@b.com\") on_match(age=31)\n# MERGE (n:Person {name: $p_name})\n# ON CREATE SET n.age = $p_age, n.email = $p_email\n# ON MATCH SET n.age = $p_age_match\n# RETURN n\n\nSimple merge without on_create/on_match:\n\nnode = @merge conn Person(name=\"Alice\", age=30)","category":"section"},{"location":"guide/dsl/#@relate-—-create-a-relationship","page":"DSL","title":"@relate — create a relationship","text":"alice = @create conn Person(name=\"Alice\", age=30)\nbob   = @create conn Person(name=\"Bob\", age=25)\n\nrel = @relate conn alice => KNOWS(since=2024) => bob\n# Returns: Relationship\n\n# Access relationship properties\nprintln(rel.type)      # \"KNOWS\"\nprintln(rel[\"since\"])  # 2024\n\nMatches nodes by elementId() and validates against the KNOWS schema (if registered).","category":"section"},{"location":"guide/queries/#queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"guide/queries/#Implicit-(auto-commit)-queries","page":"Queries","title":"Implicit (auto-commit) queries","text":"The simplest way to execute Cypher:\n\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name\")\n\nEvery call creates an implicit (auto-commit) transaction that opens and closes with a single request.","category":"section"},{"location":"guide/queries/#Parameters","page":"Queries","title":"Parameters","text":"Always use parameters for user-supplied values — never interpolate into Cypher strings:\n\nresult = query(conn,\n    \"MATCH (p:Person {name: \\$name}) RETURN p\",\n    parameters=Dict{String,Any}(\"name\" => \"Alice\"))\n\nMultiple parameters:\n\nresult = query(conn,\n    \"MATCH (p:Person) WHERE p.age > \\$min_age AND p.age < \\$max_age RETURN p.name AS name, p.age AS age\",\n    parameters=Dict{String,Any}(\"min_age\" => 20, \"max_age\" => 40);\n    access_mode=:read)","category":"section"},{"location":"guide/queries/#The-@cypher_str-macro","page":"Queries","title":"The @cypher_str macro","text":"A safer, more ergonomic approach — local variables prefixed with $ are automatically captured:\n\nname = \"Alice\"\nage = 30\nq = cypher\"CREATE (p:Person {name: $name, age: $age}) RETURN p\"\nresult = query(conn, q)\n\nThe macro produces a CypherQuery that carries both the parameterised statement and the captured bindings. This prevents Cypher injection and enables server-side query plan caching.\n\nMulti-parameter example:\n\nmin_age = 25\ncity = \"Berlin\"\nq = cypher\"MATCH (p:Person) WHERE p.age > $min_age AND p.city = $city RETURN p\"\nresult = query(conn, q; access_mode=:read)","category":"section"},{"location":"guide/queries/#Options","page":"Queries","title":"Options","text":"Keyword Type Default Description\nparameters Dict{String,Any} Dict() Query parameters\naccess_mode Symbol :write :read or :write — server routing hint\ninclude_counters Bool false Include mutation statistics\nbookmarks Vector{String} String[] Causal consistency bookmarks\nimpersonated_user Union{String, Nothing} nothing Impersonate a different user","category":"section"},{"location":"guide/queries/#Working-with-results","page":"Queries","title":"Working with results","text":"QueryResult supports indexing, iteration, and standard Julia protocols:\n\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age ORDER BY p.name\")\n\n# Indexing\nfirst_row = result[1]          # NamedTuple\nlast_row  = result[end]\n\n# Range indexing\nsubset = result[1:3]           # Vector of NamedTuples\n\n# Fields\nprintln(result.fields)          # [\"name\", \"age\"]\n\n# Iteration\nfor row in result\n    println(row.name, \" — \", row.age)\nend\n\n# Comprehensions\nnames = [row.name for row in result]\n\n# Standard functions\nlength(result)\nisempty(result)\nfirst(result)\nlast(result)\nsize(result)                    # (n,) — number of rows","category":"section"},{"location":"guide/queries/#Counters","page":"Queries","title":"Counters","text":"When include_counters=true, the result includes a QueryCounters struct:\n\nresult = query(conn, \"CREATE (n:Test) RETURN n\"; include_counters=true)\nc = result.counters\nprintln(c.nodes_created)        # 1\nprintln(c.properties_set)       # 0\nprintln(c.labels_added)         # 1\n\nAvailable counter fields: nodes_created, nodes_deleted, relationships_created, relationships_deleted, properties_set, labels_added, labels_removed, indexes_added, indexes_removed, constraints_added, constraints_removed, contains_updates, contains_system_updates, system_updates.","category":"section"},{"location":"guide/queries/#Bookmarks","page":"Queries","title":"Bookmarks","text":"Every result carries bookmarks for causal consistency across queries:\n\nr1 = query(conn, \"CREATE (n:Test)\")\nr2 = query(conn, \"MATCH (n:Test) RETURN n\"; bookmarks=r1.bookmarks)","category":"section"},{"location":"guide/queries/#Notifications","page":"Queries","title":"Notifications","text":"The server may attach performance warnings or deprecation hints:\n\nresult = query(conn, \"MATCH (a), (b) RETURN a, b\")\nfor n in result.notifications\n    println(n.severity, \": \", n.title)\n    println(\"  \", n.description)\nend","category":"section"},{"location":"guide/queries/#Graph-types","page":"Queries","title":"Graph types","text":"Nodes, relationships, and paths are returned as rich Julia structs:\n\nresult = query(conn, \"MATCH (p:Person)-[r:KNOWS]->(q) RETURN p, r, q\")\nrow = result[1]\n\nnode = row.p           # Node\nnode.element_id        # \"4:xxx:0\"\nnode.labels            # [\"Person\"]\nnode[\"name\"]           # property access via getindex\nnode.name              # property access via getproperty\nnode[:name]            # property access via Symbol\n\nrel = row.r            # Relationship\nrel.type               # \"KNOWS\"\nrel[\"since\"]           # property access\nrel.since              # dot syntax\nrel[:since]            # Symbol indexing\nrel.element_id         # relationship element ID\nrel.start_node_element_id\nrel.end_node_element_id","category":"section"},{"location":"guide/queries/#Paths","page":"Queries","title":"Paths","text":"result = query(conn, \"\"\"\n    MATCH path = (a:Person)-[:KNOWS*1..3]->(b:Person)\n    WHERE a.name = 'Alice'\n    RETURN path\n\"\"\"; access_mode=:read)\n\np = result[1].path     # Path\np.elements             # Vector of alternating Node and Relationship objects","category":"section"},{"location":"guide/queries/#Spatial-values","page":"Queries","title":"Spatial values","text":"result = query(conn, \"RETURN point({latitude: 51.5, longitude: -0.1}) AS pt\")\npt = result[1].pt      # CypherPoint\npt.srid                # 4326\npt.coordinates         # [-0.1, 51.5]  (longitude, latitude)","category":"section"},{"location":"guide/queries/#Duration-values","page":"Queries","title":"Duration values","text":"result = query(conn, \"RETURN duration('P1Y2M3DT4H') AS d\")\nd = result[1].d        # CypherDuration\nd.value                # \"P1Y2M3DT4H\"","category":"section"},{"location":"#Neo4jQuery.jl","page":"Home","title":"Neo4jQuery.jl","text":"A modern Julia client for Neo4j using the Query API v2.\n\n(Image: Build Status) (Image: Documentation (stable)) (Image: Documentation (dev)) (Image: codecov)","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Query API v2 — uses Neo4j's modern HTTP endpoint with Typed JSON for lossless data exchange.\nParameterised Cypher — the @cypher_str macro captures local variables as safe query parameters, preventing injection and enabling server-side caching.\nExplicit & implicit transactions — both auto-commit queries and full begin/commit/rollback lifecycle with a convenient do-block API.\nStreaming results — row-by-row iteration over JSONL responses for memory-efficient processing of large result sets.\nRich type mapping — automatic round-trip conversion between Julia types (Int64, Float64, Date, DateTime, ZonedDateTime, …) and Neo4j's type system, including spatial (CypherPoint), temporal (CypherDuration), and vector (CypherVector) values.\nGraph DSL — macros @query, @graph, @create, @merge, and @relate let you write Julia-native graph operations that compile to parameterised Cypher at macro-expansion time. @graph offers a hyper-ergonomic syntax with >> chain operators, bare type annotations, and comprehension forms.\nFull Cypher coverage — directed, left-arrow, and undirected patterns; variable-length relationships; CASE/WHEN expressions; EXISTS subqueries; regex matching (matches()); UNION/UNION ALL; CALL subqueries; LOAD CSV; FOREACH; and index/constraint management.\nSchema declarations — @node and @rel register typed schemas with validation for safer graph mutations.\nFlexible authentication — BasicAuth (HTTP Basic) and BearerAuth (token) with an extension point for custom strategies.\nEnvironment configuration — connect_from_env loads credentials from .env files or environment variables with automatic URI scheme parsing.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Neo4jQuery\n\n# Connect\nconn = connect(\"localhost\", \"neo4j\"; port=7474, auth=BasicAuth(\"neo4j\", \"password\"))\n\n# Query\nresult = query(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\nfor row in result\n    println(\"\\$(row.name) is \\$(row.age) years old\")\nend\n\n# Parameterised query\nname = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p\"\nresult = query(conn, q)\n\nSee the Getting Started guide for installation instructions and a more complete walkthrough.","category":"section"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/connections.md\",\n    \"guide/queries.md\",\n    \"guide/transactions.md\",\n    \"guide/streaming.md\",\n    \"guide/dsl.md\",\n    \"guide/biomedical_case_study.md\",\n    \"api.md\",\n]\nDepth = 1","category":"section"},{"location":"guide/streaming/#streaming","page":"Streaming","title":"Streaming","text":"For large result sets, streaming avoids loading all rows into memory at once. Results arrive as JSONL (one JSON object per line) and are parsed lazily.","category":"section"},{"location":"guide/streaming/#Basic-usage","page":"Streaming","title":"Basic usage","text":"sr = stream(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\n\nfor row in sr\n    println(row.name, \" — \", row.age)\nend\n\nEach iterate call reads and parses the next row from the HTTP response body.","category":"section"},{"location":"guide/streaming/#Streaming-in-transactions","page":"Streaming","title":"Streaming in transactions","text":"# Implicit transaction\nsr = stream(conn, \"MATCH (p) RETURN p\"; access_mode=:read)\n\n# Explicit transaction\ntx = begin_transaction(conn)\nsr = stream(tx, \"MATCH (p) RETURN p\")\n# ... consume rows ...\ncommit!(tx)","category":"section"},{"location":"guide/streaming/#Options","page":"Streaming","title":"Options","text":"stream accepts the same keyword arguments as query:\n\nKeyword Description\nparameters Query parameters\naccess_mode :read or :write\ninclude_counters Include mutation counters in summary\nbookmarks Causal consistency bookmarks\nimpersonated_user User impersonation","category":"section"},{"location":"guide/streaming/#Summary","page":"Streaming","title":"Summary","text":"After fully consuming the stream, call summary to get metadata:\n\nimport Neo4jQuery: summary   # required — Base.summary shadows the export\n\nsr = stream(conn, \"MATCH (p:Person) RETURN p\")\nrows = collect(sr)   # consume all rows\n\ns = summary(sr)\n# s.bookmarks, s.counters, s.notifications, etc.\n\nnote: Note\nsummary must be explicitly imported with import Neo4jQuery: summary because Base.summary takes precedence over the re-exported name. Alternatively, use the qualified form Neo4jQuery.summary(sr).\n\nwarning: Warning\nsummary is only available after the stream has been fully consumed. Calling it mid-stream will block until all remaining rows are read.","category":"section"},{"location":"guide/streaming/#Collecting-rows","page":"Streaming","title":"Collecting rows","text":"You can materialize the entire stream with collect:\n\nsr = stream(conn, \"MATCH (p:Person) RETURN p.name AS name, p.age AS age\")\nrows = collect(sr)\n\n# rows is a Vector; use normal Julia operations\nnames = [r.name for r in rows]\nages  = [r.age  for r in rows]","category":"section"},{"location":"guide/streaming/#Streaming-with-parameters","page":"Streaming","title":"Streaming with parameters","text":"sr = stream(conn, \"MATCH (p:Person) WHERE p.age > \\$min_age RETURN p.name AS name\",\n    parameters=Dict{String,Any}(\"min_age\" => 25))\n\nfor row in sr\n    println(row.name)\nend","category":"section"},{"location":"guide/streaming/#Streaming-inside-a-transaction","page":"Streaming","title":"Streaming inside a transaction","text":"Streaming works within explicit transactions for multi-step workflows:\n\ntransaction(conn) do tx\n    # Step 1: create nodes\n    query(tx, \"CREATE (p:Person {name: 'Diana', age: 28})\")\n\n    # Step 2: stream results from the same transaction\n    sr = stream(tx, \"MATCH (p:Person) RETURN p.name AS name\")\n    for row in sr\n        println(\"Found: \", row.name)\n    end\nend","category":"section"},{"location":"guide/streaming/#CypherQuery-support","page":"Streaming","title":"CypherQuery support","text":"name = \"Alice\"\nq = cypher\"MATCH (p:Person {name: $name}) RETURN p\"\nsr = stream(conn, q)\n\nfor row in sr\n    println(row.p)\nend","category":"section"},{"location":"guide/streaming/#StreamingResult-details","page":"Streaming","title":"StreamingResult details","text":"A StreamingResult tracks its consumption state:\n\nField Type Description\nfields Vector Column names\nconsumed Bool true after all rows have been read\n_summary internal Populated after consumption; access via summary\n\nThe iterator protocol (Base.iterate) is implemented, so streaming results work with for loops, collect, comprehensions, and any iterator combinator.","category":"section"},{"location":"guide/connections/#connections","page":"Connections","title":"Connections","text":"Neo4jQuery connects to Neo4j over HTTP using the Query API v2.","category":"section"},{"location":"guide/connections/#connect","page":"Connections","title":"connect","text":"conn = connect(host, database;\n    port=7474,\n    auth=BasicAuth(\"neo4j\", \"password\"),\n    scheme=\"http\")\n\nOn construction the client hits the discovery endpoint (GET /) to verify the server is reachable.\n\nArguments:\n\nParameter Type Default Description\nhost String required Hostname or IP\ndatabase String required Database name (e.g. \"neo4j\")\nport Int 7474 HTTP port\nauth AbstractAuth required Authentication strategy\nscheme String \"http\" \"http\" or \"https\"","category":"section"},{"location":"guide/connections/#connect_from_env","page":"Connections","title":"connect_from_env","text":"Loads connection details from environment variables, optionally reading them from a .env file first:\n\nconn = connect_from_env(; path=\".env\", prefix=\"NEO4J_\")\n\nExpected variables (with default prefix NEO4J_):\n\nVariable Description\nNEO4J_URI Full URI, e.g. neo4j+s://xxx.databases.neo4j.io\nNEO4J_USERNAME Username\nNEO4J_PASSWORD Password\nNEO4J_DATABASE Database name\n\nThe URI scheme is parsed to determine HTTP vs HTTPS:\n\nneo4j+s://, bolt+s://, https:// → HTTPS\nneo4j://, bolt://, http:// → HTTP","category":"section"},{"location":"guide/connections/#Authentication","page":"Connections","title":"Authentication","text":"Two strategies are available:\n\n# HTTP Basic Auth (RFC 7617)\nauth = BasicAuth(\"neo4j\", \"password\")\n\n# Bearer token auth\nauth = BearerAuth(\"eyJhbGciOi...\")\n\nBoth produce an Authorization header used on every request. Implement auth_header(::YourAuth) for custom strategies.","category":"section"},{"location":"guide/connections/#The-dotenv-helper","page":"Connections","title":"The dotenv helper","text":"You can load .env files independently:\n\nvars = dotenv(\".env\"; overwrite=false)\n\nSupports comments (#), quoted values, and export prefix. Existing ENV keys are preserved unless overwrite=true.","category":"section"},{"location":"guide/connections/#.env-file-format","page":"Connections","title":".env file format","text":"# Comment lines are ignored\nNEO4J_URI=neo4j+s://xxx.databases.neo4j.io\nNEO4J_USERNAME=neo4j\nNEO4J_PASSWORD=secret\nNEO4J_DATABASE=neo4j\n\n# Quoted values (quotes are stripped)\nNEO4J_PASSWORD=\"my secret password\"\nNEO4J_PASSWORD='my secret password'\n\n# \"export\" prefix is supported\nexport NEO4J_URI=neo4j://localhost","category":"section"},{"location":"guide/connections/#URI-scheme-mapping","page":"Connections","title":"URI scheme mapping","text":"The scheme in NEO4J_URI is mapped to HTTP or HTTPS:\n\nURI Scheme Protocol Default Port\nneo4j:// HTTP 7474\nbolt:// HTTP 7474\nhttp:// HTTP 7474\nneo4j+s:// HTTPS 443\nneo4j+ssc:// HTTPS 443\nbolt+s:// HTTPS 443\nbolt+ssc:// HTTPS 443\nhttps:// HTTPS 443","category":"section"},{"location":"guide/connections/#Custom-authentication","page":"Connections","title":"Custom authentication","text":"To implement a custom auth strategy, define a struct that subtypes AbstractAuth and implement auth_header:\n\nstruct ApiKeyAuth <: Neo4jQuery.AbstractAuth\n    key::String\nend\n\nNeo4jQuery.auth_header(a::ApiKeyAuth) = \"ApiKey $(a.key)\"\n\nconn = connect(\"localhost\", \"neo4j\"; auth=ApiKeyAuth(\"my-api-key\"))","category":"section"},{"location":"guide/connections/#Verifying-a-connection","page":"Connections","title":"Verifying a connection","text":"connect hits the discovery endpoint on construction. If the server is unreachable, it will throw an error immediately:\n\ntry\n    conn = connect(\"localhost\", \"neo4j\"; auth=BasicAuth(\"neo4j\", \"pw\"))\n    println(\"Connected to: \", conn.host)\ncatch e\n    println(\"Connection failed: \", e)\nend","category":"section"},{"location":"guide/connections/#Displaying-a-connection","page":"Connections","title":"Displaying a connection","text":"conn = connect(\"localhost\", \"neo4j\"; auth=BasicAuth(\"neo4j\", \"pw\"))\nprintln(conn)  # Neo4jConnection(http://localhost:7474, db=neo4j)","category":"section"}]
}
