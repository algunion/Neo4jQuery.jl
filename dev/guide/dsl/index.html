<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DSL · Neo4jQuery.jl</title><meta name="title" content="DSL · Neo4jQuery.jl"/><meta property="og:title" content="DSL · Neo4jQuery.jl"/><meta property="twitter:title" content="DSL · Neo4jQuery.jl"/><meta name="description" content="Documentation for Neo4jQuery.jl."/><meta property="og:description" content="Documentation for Neo4jQuery.jl."/><meta property="twitter:description" content="Documentation for Neo4jQuery.jl."/><meta property="og:url" content="https://algunion.github.io/Neo4jQuery.jl/guide/dsl/"/><meta property="twitter:url" content="https://algunion.github.io/Neo4jQuery.jl/guide/dsl/"/><link rel="canonical" href="https://algunion.github.io/Neo4jQuery.jl/guide/dsl/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Neo4jQuery.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../connections/">Connections</a></li><li><a class="tocitem" href="../queries/">Queries</a></li><li><a class="tocitem" href="../transactions/">Transactions</a></li><li><a class="tocitem" href="../streaming/">Streaming</a></li><li class="is-active"><a class="tocitem" href>DSL</a><ul class="internal"><li><a class="tocitem" href="#Schema-declarations"><span>Schema declarations</span></a></li><li><a class="tocitem" href="#@cypher-—-the-unified-query-builder"><span><code>@cypher</code> — the unified query builder</span></a></li><li><a class="tocitem" href="#Complete-end-to-end-example"><span>Complete end-to-end example</span></a></li><li><a class="tocitem" href="#Known-limitations"><span>Known limitations</span></a></li><li><a class="tocitem" href="#Standalone-mutations"><span>Standalone mutations</span></a></li></ul></li><li><a class="tocitem" href="../biomedical_case_study/">Biomedical Case Study</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guide</a></li><li class="is-active"><a href>DSL</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DSL</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/algunion/Neo4jQuery.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/algunion/Neo4jQuery.jl/blob/main/docs/src/guide/dsl.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="dsl"><a class="docs-heading-anchor" href="#dsl">DSL</a><a id="dsl-1"></a><a class="docs-heading-anchor-permalink" href="#dsl" title="Permalink"></a></h1><p>Neo4jQuery includes a compile-time DSL that translates Julia expressions into parameterised Cypher. The unified <code>@cypher</code> macro gives you type-safe, injection-proof graph operations with Julia-native syntax.</p><h2 id="Schema-declarations"><a class="docs-heading-anchor" href="#Schema-declarations">Schema declarations</a><a id="Schema-declarations-1"></a><a class="docs-heading-anchor-permalink" href="#Schema-declarations" title="Permalink"></a></h2><p>Register node and relationship schemas for validation:</p><pre><code class="language-julia hljs">@node Person begin
    name::String
    age::Int
    email::String = &quot;&quot;    # optional, with default
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSchema(:Person, 3 properties)</code></pre><pre><code class="language-julia hljs">@rel KNOWS begin
    since::Int
    weight::Float64 = 1.0
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RelSchema(:KNOWS, 2 properties)</code></pre><p>Schemas are stored in a global registry and used by mutation macros to validate properties at runtime.</p><pre><code class="language-julia hljs">get_node_schema(:Person)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSchema(:Person, 3 properties)</code></pre><pre><code class="language-julia hljs">get_rel_schema(:KNOWS)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RelSchema(:KNOWS, 2 properties)</code></pre><p>Label-only schemas (no properties):</p><pre><code class="language-julia hljs">@node Marker</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSchema(:Marker, 0 properties)</code></pre><pre><code class="language-julia hljs">@rel LINKS</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RelSchema(:LINKS, 0 properties)</code></pre><h3 id="Property-validation"><a class="docs-heading-anchor" href="#Property-validation">Property validation</a><a id="Property-validation-1"></a><a class="docs-heading-anchor-permalink" href="#Property-validation" title="Permalink"></a></h3><p>Validation throws if required properties are missing and warns on unknown properties:</p><pre><code class="language-julia hljs">schema = get_node_schema(:Person)
validate_node_properties(schema, Dict{String,Any}(&quot;name&quot; =&gt; &quot;Alice&quot;, &quot;age&quot; =&gt; 30))
println(&quot;Node validation passed&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node validation passed</code></pre><pre><code class="language-julia hljs">rel_schema = get_rel_schema(:KNOWS)
validate_rel_properties(rel_schema, Dict{String,Any}(&quot;since&quot; =&gt; 2024))
println(&quot;Relationship validation passed&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Relationship validation passed</code></pre><h2 id="@cypher-—-the-unified-query-builder"><a class="docs-heading-anchor" href="#@cypher-—-the-unified-query-builder"><code>@cypher</code> — the unified query builder</a><a id="@cypher-—-the-unified-query-builder-1"></a><a class="docs-heading-anchor-permalink" href="#@cypher-—-the-unified-query-builder" title="Permalink"></a></h2><p><code>@cypher</code> compiles a Julia block into a single parameterised Cypher query. It combines full Cypher coverage with ergonomic Julia-native syntax:</p><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person &gt;&gt; r::KNOWS &gt;&gt; q::Person
    where(p.age &gt; $min_age, q.name == $target)
    ret(p.name =&gt; :name, r.since, q.name =&gt; :friend)
    order(p.age, :desc)
    take(10)
end</code></pre><p>This expands at compile time into:</p><pre><code class="language-cypher hljs">MATCH (p:Person)-[r:KNOWS]-&gt;(q:Person)
WHERE p.age &gt; $min_age AND q.name = $target
RETURN p.name AS name, r.since, q.name AS friend
ORDER BY p.age DESC
LIMIT 10</code></pre><h3 id="Pattern-syntax"><a class="docs-heading-anchor" href="#Pattern-syntax">Pattern syntax</a><a id="Pattern-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Pattern-syntax" title="Permalink"></a></h3><p><code>@cypher</code> supports two pattern styles. Use whichever feels natural — they both compile to the same Cypher.</p><h4 id="chain-syntax-(recommended)"><a class="docs-heading-anchor" href="#chain-syntax-(recommended)"><code>&gt;&gt;</code> chain syntax (recommended)</a><a id="chain-syntax-(recommended)-1"></a><a class="docs-heading-anchor-permalink" href="#chain-syntax-(recommended)" title="Permalink"></a></h4><p>The <code>&gt;&gt;</code> operator is the universal pattern connector. It works the same way in MATCH, CREATE, MERGE, and OPTIONAL MATCH.</p><pre><code class="language-julia hljs"># Labeled node (Julia type annotation)
p::Person                    # → (p:Person)

# Anonymous node
::Person                     # → (:Person)

# Right-directed chain
p::Person &gt;&gt; r::KNOWS &gt;&gt; q::Person
# → (p:Person)-[r:KNOWS]-&gt;(q:Person)

# Anonymous relationship in chain
p::Person &gt;&gt; KNOWS &gt;&gt; q::Person
# → (p:Person)-[:KNOWS]-&gt;(q:Person)

# Left-directed chain (&lt;&lt; operator)
p::Person &lt;&lt; r::KNOWS &lt;&lt; q::Person
# → (p:Person)&lt;-[r:KNOWS]-(q:Person)

# Multi-hop chain
a::Person &gt;&gt; r::KNOWS &gt;&gt; b::Person &gt;&gt; s::WORKS_AT &gt;&gt; c::Company
# → (a:Person)-[r:KNOWS]-&gt;(b:Person)-[s:WORKS_AT]-&gt;(c:Company)</code></pre><h4 id="Arrow-syntax"><a class="docs-heading-anchor" href="#Arrow-syntax">Arrow syntax</a><a id="Arrow-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Arrow-syntax" title="Permalink"></a></h4><p>The classic Cypher-like arrow syntax also works:</p><pre><code class="language-julia hljs"># Right arrow (typed)
(p:Person)-[r:KNOWS]-&gt;(q:Person)

# Simple directed arrow
(a) --&gt; (b)

# Left arrow (typed)
(a:Person)&lt;-[r:KNOWS]-(b:Person)

# Undirected
(a:Person)-[r:KNOWS]-(b:Person)

# Variable-length
(a:Person)-[r:KNOWS, 1, 3]-&gt;(b:Person)
# → (a:Person)-[r:KNOWS*1..3]-&gt;(b:Person)

# Chained path
(a)-[r:R]-&gt;(b)-[s:S]-&gt;(c)

# Multiple patterns (comma-separated)
match((p:Person), (c:Company))</code></pre><h3 id="Clause-functions"><a class="docs-heading-anchor" href="#Clause-functions">Clause functions</a><a id="Clause-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Clause-functions" title="Permalink"></a></h3><p>All clauses use plain function-call syntax — no <code>@</code> prefixes:</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Cypher</th></tr><tr><td style="text-align: left"><code>where(cond1, cond2, ...)</code></td><td style="text-align: left"><code>WHERE cond1 AND cond2 AND ...</code></td></tr><tr><td style="text-align: left"><code>ret(expr =&gt; :alias, ...)</code></td><td style="text-align: left"><code>RETURN expr AS alias, ...</code></td></tr><tr><td style="text-align: left"><code>returning(expr =&gt; :alias)</code></td><td style="text-align: left"><code>RETURN expr AS alias</code> (synonym for <code>ret</code>)</td></tr><tr><td style="text-align: left"><code>ret(distinct, expr)</code></td><td style="text-align: left"><code>RETURN DISTINCT expr</code></td></tr><tr><td style="text-align: left"><code>order(expr, :desc)</code></td><td style="text-align: left"><code>ORDER BY expr DESC</code></td></tr><tr><td style="text-align: left"><code>take(n)</code> / <code>skip(n)</code></td><td style="text-align: left"><code>LIMIT n</code> / <code>SKIP n</code></td></tr><tr><td style="text-align: left"><code>match(p1, p2)</code></td><td style="text-align: left"><code>MATCH p1, p2</code> (explicit multi-pattern)</td></tr><tr><td style="text-align: left"><code>optional(pattern)</code></td><td style="text-align: left"><code>OPTIONAL MATCH pattern</code></td></tr><tr><td style="text-align: left"><code>create(pattern)</code></td><td style="text-align: left"><code>CREATE pattern</code></td></tr><tr><td style="text-align: left"><code>merge(pattern)</code></td><td style="text-align: left"><code>MERGE pattern</code></td></tr><tr><td style="text-align: left"><code>with(expr =&gt; :alias, ...)</code></td><td style="text-align: left"><code>WITH expr AS alias, ...</code></td></tr><tr><td style="text-align: left"><code>unwind($list =&gt; :var)</code></td><td style="text-align: left"><code>UNWIND $list AS var</code></td></tr><tr><td style="text-align: left"><code>delete(vars...)</code></td><td style="text-align: left"><code>DELETE vars</code></td></tr><tr><td style="text-align: left"><code>detach_delete(vars...)</code></td><td style="text-align: left"><code>DETACH DELETE vars</code></td></tr><tr><td style="text-align: left"><code>on_create(p.prop = val)</code></td><td style="text-align: left"><code>ON CREATE SET p.prop = val</code></td></tr><tr><td style="text-align: left"><code>on_match(p.prop = val)</code></td><td style="text-align: left"><code>ON MATCH SET p.prop = val</code></td></tr><tr><td style="text-align: left"><code>remove(p.prop)</code></td><td style="text-align: left"><code>REMOVE p.prop</code></td></tr><tr><td style="text-align: left"><code>p.prop = $val</code> (assignment)</td><td style="text-align: left"><code>SET p.prop = $val</code> (auto-detected)</td></tr><tr><td style="text-align: left"><code>union()</code></td><td style="text-align: left"><code>UNION</code></td></tr><tr><td style="text-align: left"><code>union_all()</code></td><td style="text-align: left"><code>UNION ALL</code></td></tr><tr><td style="text-align: left"><code>call(begin ... end)</code></td><td style="text-align: left"><code>CALL { ... }</code> subquery</td></tr><tr><td style="text-align: left"><code>load_csv(url =&gt; :row)</code></td><td style="text-align: left"><code>LOAD CSV FROM url AS row</code></td></tr><tr><td style="text-align: left"><code>load_csv_headers(url =&gt; :row)</code></td><td style="text-align: left"><code>LOAD CSV WITH HEADERS FROM url AS row</code></td></tr><tr><td style="text-align: left"><code>foreach(var, :in, expr, begin ... end)</code></td><td style="text-align: left"><code>FOREACH (var IN expr | ...)</code></td></tr><tr><td style="text-align: left"><code>create_index(:Label, :prop)</code></td><td style="text-align: left"><code>CREATE INDEX FOR (n:Label) ON (n.prop)</code></td></tr><tr><td style="text-align: left"><code>drop_index(:name)</code></td><td style="text-align: left"><code>DROP INDEX name IF EXISTS</code></td></tr><tr><td style="text-align: left"><code>create_constraint(:Label, :prop, :unique)</code></td><td style="text-align: left"><code>CREATE CONSTRAINT ... IS UNIQUE</code></td></tr><tr><td style="text-align: left"><code>drop_constraint(:name)</code></td><td style="text-align: left"><code>DROP CONSTRAINT name IF EXISTS</code></td></tr></table><h3 id="Implicit-MATCH"><a class="docs-heading-anchor" href="#Implicit-MATCH">Implicit MATCH</a><a id="Implicit-MATCH-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-MATCH" title="Permalink"></a></h3><p>Bare graph patterns in a <code>@cypher</code> block are automatically treated as MATCH clauses:</p><pre><code class="language-julia hljs">@cypher conn begin
    p::Person &gt;&gt; r::KNOWS &gt;&gt; q::Person    # implicit MATCH
    where(p.age &gt; 25)
    ret(p.name, q.name)
end</code></pre><h3 id="WHERE-operators"><a class="docs-heading-anchor" href="#WHERE-operators">WHERE operators</a><a id="WHERE-operators-1"></a><a class="docs-heading-anchor-permalink" href="#WHERE-operators" title="Permalink"></a></h3><p>Julia operators are translated to Cypher:</p><table><tr><th style="text-align: left">Julia</th><th style="text-align: left">Cypher</th></tr><tr><td style="text-align: left"><code>==</code></td><td style="text-align: left"><code>=</code></td></tr><tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left"><code>&lt;&gt;</code></td></tr><tr><td style="text-align: left"><code>&amp;&amp;</code></td><td style="text-align: left"><code>AND</code></td></tr><tr><td style="text-align: left"><code>||</code></td><td style="text-align: left"><code>OR</code></td></tr><tr><td style="text-align: left"><code>!</code></td><td style="text-align: left"><code>NOT</code></td></tr><tr><td style="text-align: left"><code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code></td><td style="text-align: left"><code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code></td></tr><tr><td style="text-align: left"><code>startswith</code></td><td style="text-align: left"><code>STARTS WITH</code></td></tr><tr><td style="text-align: left"><code>endswith</code></td><td style="text-align: left"><code>ENDS WITH</code></td></tr><tr><td style="text-align: left"><code>contains</code></td><td style="text-align: left"><code>CONTAINS</code></td></tr><tr><td style="text-align: left"><code>in</code> / <code>∈</code></td><td style="text-align: left"><code>IN</code></td></tr><tr><td style="text-align: left"><code>isnothing</code></td><td style="text-align: left"><code>IS NULL</code></td></tr><tr><td style="text-align: left"><code>matches</code></td><td style="text-align: left"><code>=~</code> (regex match)</td></tr><tr><td style="text-align: left"><code>exists((p)-[:R]-&gt;(q))</code></td><td style="text-align: left"><code>EXISTS { MATCH ... }</code></td></tr><tr><td style="text-align: left"><code>if ... elseif ... else ... end</code></td><td style="text-align: left"><code>CASE WHEN ... THEN ... ELSE ... END</code></td></tr></table><p>Arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code>) are also supported:</p><pre><code class="language-julia hljs">where(p.score * 2 + 10 &gt; $threshold)
where(p.id % 2 == 0)</code></pre><p>Multi-condition WHERE auto-ANDs:</p><pre><code class="language-julia hljs">where(p.age &gt; 25, p.active == true, startswith(p.name, &quot;A&quot;))
# → WHERE p.age &gt; 25 AND p.active = true AND p.name STARTS WITH &#39;A&#39;</code></pre><h3 id="Parameter-capture"><a class="docs-heading-anchor" href="#Parameter-capture">Parameter capture</a><a id="Parameter-capture-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-capture" title="Permalink"></a></h3><p><code>$var</code> references capture Julia variables as safe Cypher parameters:</p><pre><code class="language-julia hljs">min_age = 25
result = @cypher conn begin
    p::Person
    where(p.age &gt; $min_age)
    ret(p.name =&gt; :name)
end</code></pre><p>Parameters work in <code>where()</code>, property assignments, <code>unwind()</code>, <code>skip()</code>, <code>take()</code>, and any expression position.</p><h3 id="Keyword-arguments"><a class="docs-heading-anchor" href="#Keyword-arguments">Keyword arguments</a><a id="Keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-arguments" title="Permalink"></a></h3><p>Pass query options after the block:</p><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    ret(p.name)
end include_counters=true</code></pre><div class="admonition is-info" id="Automatic-access_mode-4d49736dc8fa5743"><header class="admonition-header">Automatic access_mode<a class="admonition-anchor" href="#Automatic-access_mode-4d49736dc8fa5743" title="Permalink"></a></header><div class="admonition-body"><p><code>@cypher</code> automatically sets <code>access_mode=:read</code> for pure read queries and <code>access_mode=:write</code> when any mutation clause is present (CREATE/MERGE/SET/DELETE/…). You rarely need to specify it manually. An explicit <code>access_mode=:write</code> (or <code>:read</code>) after <code>end</code> overrides the inferred value.</p></div></div><h2 id="Complete-end-to-end-example"><a class="docs-heading-anchor" href="#Complete-end-to-end-example">Complete end-to-end example</a><a id="Complete-end-to-end-example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-end-to-end-example" title="Permalink"></a></h2><h3 id="Step-1:-Define-your-graph-model"><a class="docs-heading-anchor" href="#Step-1:-Define-your-graph-model">Step 1: Define your graph model</a><a id="Step-1:-Define-your-graph-model-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Define-your-graph-model" title="Permalink"></a></h3><pre><code class="language-julia hljs">@node Person begin
    name::String
    age::Int
    email::String = &quot;&quot;
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSchema(:Person, 3 properties)</code></pre><pre><code class="language-julia hljs">@node Company begin
    name::String
    founded::Int
    industry::String = &quot;Technology&quot;
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSchema(:Company, 3 properties)</code></pre><pre><code class="language-julia hljs">@rel KNOWS begin
    since::Int
    weight::Float64 = 1.0
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RelSchema(:KNOWS, 2 properties)</code></pre><pre><code class="language-julia hljs">@rel WORKS_AT begin
    role::String
    since::Int
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RelSchema(:WORKS_AT, 2 properties)</code></pre><h3 id="Step-2:-Create-nodes-using-schemas"><a class="docs-heading-anchor" href="#Step-2:-Create-nodes-using-schemas">Step 2: Create nodes using schemas</a><a id="Step-2:-Create-nodes-using-schemas-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Create-nodes-using-schemas" title="Permalink"></a></h3><pre><code class="language-julia hljs">alice = @create conn Person(name=&quot;Alice&quot;, age=30, email=&quot;alice@example.com&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node(:Person {name: &quot;Alice&quot;, email: &quot;alice@example.com&quot;, age: 30})</code></pre><pre><code class="language-julia hljs">bob = @create conn Person(name=&quot;Bob&quot;, age=25)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node(:Person {name: &quot;Bob&quot;, age: 25})</code></pre><pre><code class="language-julia hljs">carol = @create conn Person(name=&quot;Carol&quot;, age=35)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node(:Person {name: &quot;Carol&quot;, age: 35})</code></pre><pre><code class="language-julia hljs">acme = @create conn Company(name=&quot;Acme Corp&quot;, founded=2010)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node(:Company {name: &quot;Acme Corp&quot;, founded: 2010})</code></pre><h3 id="Step-3:-Create-relationships"><a class="docs-heading-anchor" href="#Step-3:-Create-relationships">Step 3: Create relationships</a><a id="Step-3:-Create-relationships-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Create-relationships" title="Permalink"></a></h3><pre><code class="language-julia hljs">rel1 = @relate conn alice =&gt; KNOWS(since=2020) =&gt; bob</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Relationship(:KNOWS {since: 2020})</code></pre><pre><code class="language-julia hljs">rel2 = @relate conn alice =&gt; KNOWS(since=2022, weight=0.8) =&gt; carol</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Relationship(:KNOWS {weight: 0.8, since: 2022})</code></pre><pre><code class="language-julia hljs">rel3 = @relate conn bob =&gt; KNOWS(since=2023) =&gt; carol</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Relationship(:KNOWS {since: 2023})</code></pre><pre><code class="language-julia hljs">@relate conn alice =&gt; WORKS_AT(role=&quot;Engineer&quot;, since=2021) =&gt; acme</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Relationship(:WORKS_AT {role: &quot;Engineer&quot;, since: 2021})</code></pre><pre><code class="language-julia hljs">@relate conn bob =&gt; WORKS_AT(role=&quot;Designer&quot;, since=2022) =&gt; acme</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Relationship(:WORKS_AT {role: &quot;Designer&quot;, since: 2022})</code></pre><h3 id="Step-4:-Query-with-@cypher"><a class="docs-heading-anchor" href="#Step-4:-Query-with-@cypher">Step 4: Query with @cypher</a><a id="Step-4:-Query-with-@cypher-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Query-with-@cypher" title="Permalink"></a></h3><pre><code class="language-julia hljs">min_age = 20
result = @cypher conn begin
    p::Person &gt;&gt; r::KNOWS &gt;&gt; friend::Person
    where(p.name == &quot;Alice&quot;, friend.age &gt; $min_age)
    ret(friend.name =&gt; :name, r.since =&gt; :since)
    order(r.since, :desc)
end

for row in result
    println(row.name, &quot; — known since &quot;, row.since)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Carol — known since 2022
Bob — known since 2020</code></pre><h3 id="Step-5:-Aggregation-with-WITH"><a class="docs-heading-anchor" href="#Step-5:-Aggregation-with-WITH">Step 5: Aggregation with WITH</a><a id="Step-5:-Aggregation-with-WITH-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Aggregation-with-WITH" title="Permalink"></a></h3><pre><code class="language-julia hljs">min_connections = 1
result = @cypher conn begin
    p::Person &gt;&gt; r::KNOWS &gt;&gt; q::Person
    with(p, count(r) =&gt; :degree)
    where(degree &gt; $min_connections)
    order(degree, :desc)
    ret(p.name =&gt; :person, degree)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 2 fields, 1 row
 Fields: person, degree
  [1] (person = &quot;Alice&quot;, degree = 2)
</code></pre><h3 id="Step-6:-Friend-of-friend-recommendations"><a class="docs-heading-anchor" href="#Step-6:-Friend-of-friend-recommendations">Step 6: Friend-of-friend recommendations</a><a id="Step-6:-Friend-of-friend-recommendations-1"></a><a class="docs-heading-anchor-permalink" href="#Step-6:-Friend-of-friend-recommendations" title="Permalink"></a></h3><pre><code class="language-julia hljs">my_name = &quot;Bob&quot;
result = @cypher conn begin
    (me:Person)-[:KNOWS]-&gt;(friend:Person)-[:KNOWS]-&gt;(fof:Person)
    where(me.name == $my_name, fof.name != me.name)
    ret(distinct, fof.name =&gt; :suggestion)
    take(10)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 0 rows
 Fields: suggestion
</code></pre><h3 id="Step-7:-Updating-data"><a class="docs-heading-anchor" href="#Step-7:-Updating-data">Step 7: Updating data</a><a id="Step-7:-Updating-data-1"></a><a class="docs-heading-anchor-permalink" href="#Step-7:-Updating-data" title="Permalink"></a></h3><pre><code class="language-julia hljs">name = &quot;Alice&quot;
new_age = 31
new_email = &quot;alice@latest.com&quot;

result = @cypher conn begin
    p::Person
    where(p.name == $name)
    p.age = $new_age           # auto-SET
    p.email = $new_email       # merged into same SET clause
    ret(p)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 1 row
 Fields: p
  [1] (p = Node(:Person {name: &quot;Alice&quot;, email: &quot;alice@latest.com&quot;, age: 31}),)
</code></pre><p>This generates: <code>MATCH (p:Person) WHERE p.name = $name SET p.age = $new_age, p.email = $new_email RETURN p</code></p><h3 id="Step-8:-MERGE-with-conditional-SET"><a class="docs-heading-anchor" href="#Step-8:-MERGE-with-conditional-SET">Step 8: MERGE with conditional SET</a><a id="Step-8:-MERGE-with-conditional-SET-1"></a><a class="docs-heading-anchor-permalink" href="#Step-8:-MERGE-with-conditional-SET" title="Permalink"></a></h3><pre><code class="language-julia hljs">node = @merge conn Person(name=&quot;Alice&quot;) on_create(age=30) on_match(last_seen=&quot;2025-02-15&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node(:Person {name: &quot;Alice&quot;, last_seen: &quot;2025-02-15&quot;, age: 31, email: &quot;alice@latest.com&quot;})</code></pre><p>Or using <code>@cypher</code> for more complex patterns:</p><pre><code class="language-julia hljs">now = &quot;2025-02-15&quot;
result = @cypher conn begin
    merge((p:Person))
    on_create(p.created_at = $now)
    on_match(p.last_seen = $now)
    ret(p)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 3 rows
 Fields: p
  [1] (p = Node(:Person {name: &quot;Alice&quot;, last_seen: &quot;2025-02-15&quot;, age: 31, email: &quot;alice@latest.com&quot;}),)
  [2] (p = Node(:Person {last_seen: &quot;2025-02-15&quot;, name: &quot;Bob&quot;, age: 25}),)
  [3] (p = Node(:Person {last_seen: &quot;2025-02-15&quot;, name: &quot;Carol&quot;, age: 35}),)
</code></pre><h3 id="Step-9:-Batch-operations-with-UNWIND"><a class="docs-heading-anchor" href="#Step-9:-Batch-operations-with-UNWIND">Step 9: Batch operations with UNWIND</a><a id="Step-9:-Batch-operations-with-UNWIND-1"></a><a class="docs-heading-anchor-permalink" href="#Step-9:-Batch-operations-with-UNWIND" title="Permalink"></a></h3><pre><code class="language-julia hljs">people = [
    Dict(&quot;name&quot; =&gt; &quot;Dave&quot;, &quot;age&quot; =&gt; 28),
    Dict(&quot;name&quot; =&gt; &quot;Eve&quot;, &quot;age&quot; =&gt; 22),
    Dict(&quot;name&quot; =&gt; &quot;Frank&quot;, &quot;age&quot; =&gt; 40),
]

result = @cypher conn begin
    unwind($people =&gt; :person)
    create((p:Person))
    p.name = person.name
    p.age = person.age
    ret(p)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 3 rows
 Fields: p
  [1] (p = Node(:Person {name: &quot;Dave&quot;, age: 28}),)
  [2] (p = Node(:Person {name: &quot;Eve&quot;, age: 22}),)
  [3] (p = Node(:Person {name: &quot;Frank&quot;, age: 40}),)
</code></pre><h3 id="Step-10:-OPTIONAL-MATCH"><a class="docs-heading-anchor" href="#Step-10:-OPTIONAL-MATCH">Step 10: OPTIONAL MATCH</a><a id="Step-10:-OPTIONAL-MATCH-1"></a><a class="docs-heading-anchor-permalink" href="#Step-10:-OPTIONAL-MATCH" title="Permalink"></a></h3><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    optional(p &gt;&gt; w::WORKS_AT &gt;&gt; c::Company)
    ret(p.name =&gt; :person, c.name =&gt; :company, w.role =&gt; :role)
    order(p.name)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 3 fields, 6 rows
 Fields: person, company, role
  [1] (person = &quot;Alice&quot;, company = &quot;Acme Corp&quot;, role = &quot;Engineer&quot;)
  [2] (person = &quot;Bob&quot;, company = &quot;Acme Corp&quot;, role = &quot;Designer&quot;)
  [3] (person = &quot;Carol&quot;, company = nothing, role = nothing)
  [4] (person = &quot;Dave&quot;, company = nothing, role = nothing)
  [5] (person = &quot;Eve&quot;, company = nothing, role = nothing)
  [6] (person = &quot;Frank&quot;, company = nothing, role = nothing)
</code></pre><h3 id="Step-11:-Pagination"><a class="docs-heading-anchor" href="#Step-11:-Pagination">Step 11: Pagination</a><a id="Step-11:-Pagination-1"></a><a class="docs-heading-anchor-permalink" href="#Step-11:-Pagination" title="Permalink"></a></h3><pre><code class="language-julia hljs">page = 2
page_size = 10
offset = (page - 1) * page_size

result = @cypher conn begin
    p::Person
    ret(p.name =&gt; :name, p.age =&gt; :age)
    order(p.name)
    skip($offset)
    take($page_size)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 2 fields, 0 rows
 Fields: name, age
</code></pre><h3 id="Step-12:-Deleting-data"><a class="docs-heading-anchor" href="#Step-12:-Deleting-data">Step 12: Deleting data</a><a id="Step-12:-Deleting-data-1"></a><a class="docs-heading-anchor-permalink" href="#Step-12:-Deleting-data" title="Permalink"></a></h3><pre><code class="language-julia hljs">target = &quot;Frank&quot;
@cypher conn begin
    (p:Person)
    where(p.name == $target)
    detach_delete(p)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 0 fields, 0 rows
</code></pre><pre><code class="language-julia hljs"># Remove a property
result = @cypher conn begin
    p::Person
    remove(p.email)
    ret(p)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 5 rows
 Fields: p
  [1] (p = Node(:Person {name: &quot;Eve&quot;, age: 22}),)
  [2] (p = Node(:Person {last_seen: &quot;2025-02-15&quot;, name: &quot;Alice&quot;, age: 31}),)
  [3] (p = Node(:Person {last_seen: &quot;2025-02-15&quot;, name: &quot;Bob&quot;, age: 25}),)
  [4] (p = Node(:Person {last_seen: &quot;2025-02-15&quot;, name: &quot;Carol&quot;, age: 35}),)
  [5] (p = Node(:Person {name: &quot;Dave&quot;, age: 28}),)
</code></pre><h3 id="Step-13:-Complex-WHERE-conditions"><a class="docs-heading-anchor" href="#Step-13:-Complex-WHERE-conditions">Step 13: Complex WHERE conditions</a><a id="Step-13:-Complex-WHERE-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Step-13:-Complex-WHERE-conditions" title="Permalink"></a></h3><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    where(startswith(p.name, &quot;A&quot;), !(isnothing(p.email)), p.age &gt;= 18)
    ret(p.name =&gt; :name, p.email =&gt; :email)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 2 fields, 0 rows
 Fields: name, email
</code></pre><pre><code class="language-julia hljs"># IN operator with a parameter
allowed_names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;]
result = @cypher conn begin
    p::Person
    where(in(p.name, $allowed_names))
    ret(p)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 3 rows
 Fields: p
  [1] (p = Node(:Person {last_seen: &quot;2025-02-15&quot;, name: &quot;Alice&quot;, age: 31}),)
  [2] (p = Node(:Person {last_seen: &quot;2025-02-15&quot;, name: &quot;Bob&quot;, age: 25}),)
  [3] (p = Node(:Person {last_seen: &quot;2025-02-15&quot;, name: &quot;Carol&quot;, age: 35}),)
</code></pre><h3 id="Step-14:-Aggregation-functions"><a class="docs-heading-anchor" href="#Step-14:-Aggregation-functions">Step 14: Aggregation functions</a><a id="Step-14:-Aggregation-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Step-14:-Aggregation-functions" title="Permalink"></a></h3><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    ret(count(p) =&gt; :total, avg(p.age) =&gt; :avg_age, collect(p.name) =&gt; :names)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 3 fields, 1 row
 Fields: total, avg_age, names
  [1] (total = 5, avg_age = 28.2, names = [&quot;Eve&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;Dave&quot;])
</code></pre><h3 id="Step-15:-Pattern-direction-variants"><a class="docs-heading-anchor" href="#Step-15:-Pattern-direction-variants">Step 15: Pattern direction variants</a><a id="Step-15:-Pattern-direction-variants-1"></a><a class="docs-heading-anchor-permalink" href="#Step-15:-Pattern-direction-variants" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Left-directed chain
result = @cypher conn begin
    a::Person &lt;&lt; r::KNOWS &lt;&lt; b::Person
    ret(a.name =&gt; :target, b.name =&gt; :source, r.since =&gt; :since)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 3 fields, 3 rows
 Fields: target, source, since
  [1] (target = &quot;Bob&quot;, source = &quot;Alice&quot;, since = 2020)
  [2] (target = &quot;Carol&quot;, source = &quot;Alice&quot;, since = 2022)
  [3] (target = &quot;Carol&quot;, source = &quot;Bob&quot;, since = 2023)
</code></pre><pre><code class="language-julia hljs"># Arrow syntax (left arrow)
result = @cypher conn begin
    (a:Person)&lt;-[r:KNOWS]-(b:Person)
    ret(a.name =&gt; :target, b.name =&gt; :source)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 2 fields, 3 rows
 Fields: target, source
  [1] (target = &quot;Bob&quot;, source = &quot;Alice&quot;)
  [2] (target = &quot;Carol&quot;, source = &quot;Alice&quot;)
  [3] (target = &quot;Carol&quot;, source = &quot;Bob&quot;)
</code></pre><pre><code class="language-julia hljs"># Variable-length — find paths of 1 to 3 hops
result = @cypher conn begin
    (a:Person)-[r:KNOWS, 1, 3]-&gt;(b:Person)
    ret(a.name =&gt; :start, b.name =&gt; :reachable)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 2 fields, 4 rows
 Fields: start, reachable
  [1] (start = &quot;Alice&quot;, reachable = &quot;Carol&quot;)
  [2] (start = &quot;Alice&quot;, reachable = &quot;Bob&quot;)
  [3] (start = &quot;Alice&quot;, reachable = &quot;Carol&quot;)
  [4] (start = &quot;Bob&quot;, reachable = &quot;Carol&quot;)
</code></pre><h3 id="Step-16:-Regex-matching"><a class="docs-heading-anchor" href="#Step-16:-Regex-matching">Step 16: Regex matching</a><a id="Step-16:-Regex-matching-1"></a><a class="docs-heading-anchor-permalink" href="#Step-16:-Regex-matching" title="Permalink"></a></h3><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    where(matches(p.name, &quot;^A.*e\$&quot;))
    ret(p.name =&gt; :name)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 1 row
 Fields: name
  [1] (name = &quot;Alice&quot;,)
</code></pre><h3 id="Step-17:-CASE/WHEN-expressions"><a class="docs-heading-anchor" href="#Step-17:-CASE/WHEN-expressions">Step 17: CASE/WHEN expressions</a><a id="Step-17:-CASE/WHEN-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Step-17:-CASE/WHEN-expressions" title="Permalink"></a></h3><p>Use Julia&#39;s <code>if</code>/<code>elseif</code>/<code>else</code>/<code>end</code> syntax to generate Cypher CASE expressions:</p><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    ret(p.name =&gt; :name, if p.age &gt; 65; &quot;senior&quot;; elseif p.age &gt; 30; &quot;adult&quot;; else; &quot;young&quot;; end =&gt; :category)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 2 fields, 5 rows
 Fields: name, category
  [1] (name = &quot;Eve&quot;, category = &quot;young&quot;)
  [2] (name = &quot;Alice&quot;, category = &quot;adult&quot;)
  [3] (name = &quot;Bob&quot;, category = &quot;young&quot;)
  [4] (name = &quot;Carol&quot;, category = &quot;adult&quot;)
  [5] (name = &quot;Dave&quot;, category = &quot;young&quot;)
</code></pre><p>Generates:</p><pre><code class="language-cypher hljs">RETURN p.name AS name, CASE WHEN p.age &gt; 65 THEN &#39;senior&#39; WHEN p.age &gt; 30 THEN &#39;adult&#39; ELSE &#39;young&#39; END AS category</code></pre><h3 id="Step-18:-EXISTS-subqueries"><a class="docs-heading-anchor" href="#Step-18:-EXISTS-subqueries">Step 18: EXISTS subqueries</a><a id="Step-18:-EXISTS-subqueries-1"></a><a class="docs-heading-anchor-permalink" href="#Step-18:-EXISTS-subqueries" title="Permalink"></a></h3><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    where(exists((p)-[:KNOWS]-&gt;(:Person)))
    ret(p.name =&gt; :name)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 2 rows
 Fields: name
  [1] (name = &quot;Alice&quot;,)
  [2] (name = &quot;Bob&quot;,)
</code></pre><pre><code class="language-julia hljs"># Negated EXISTS
result = @cypher conn begin
    p::Person
    where(!(exists((p)-[:KNOWS]-&gt;(:Person))))
    ret(p.name =&gt; :loner)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 3 rows
 Fields: loner
  [1] (loner = &quot;Eve&quot;,)
  [2] (loner = &quot;Carol&quot;,)
  [3] (loner = &quot;Dave&quot;,)
</code></pre><h3 id="Step-19:-UNION-and-UNION-ALL"><a class="docs-heading-anchor" href="#Step-19:-UNION-and-UNION-ALL">Step 19: UNION and UNION ALL</a><a id="Step-19:-UNION-and-UNION-ALL-1"></a><a class="docs-heading-anchor-permalink" href="#Step-19:-UNION-and-UNION-ALL" title="Permalink"></a></h3><p>Combine multiple query parts:</p><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    where(p.age &gt; 30)
    ret(p.name =&gt; :name)
    union()
    p::Person
    where(startswith(p.name, &quot;A&quot;))
    ret(p.name =&gt; :name)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 2 rows
 Fields: name
  [1] (name = &quot;Alice&quot;,)
  [2] (name = &quot;Carol&quot;,)
</code></pre><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    ret(p.name =&gt; :name)
    union_all()
    c::Company
    ret(c.name =&gt; :name)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 6 rows
 Fields: name
  [1] (name = &quot;Eve&quot;,)
  [2] (name = &quot;Alice&quot;,)
  [3] (name = &quot;Bob&quot;,)
  [4] (name = &quot;Carol&quot;,)
  [5] (name = &quot;Dave&quot;,)
  [6] (name = &quot;Acme Corp&quot;,)
</code></pre><h3 id="Step-20:-CALL-subqueries"><a class="docs-heading-anchor" href="#Step-20:-CALL-subqueries">Step 20: CALL subqueries</a><a id="Step-20:-CALL-subqueries-1"></a><a class="docs-heading-anchor-permalink" href="#Step-20:-CALL-subqueries" title="Permalink"></a></h3><p>Nest a full sub-query with <code>call()</code>:</p><pre><code class="language-julia hljs">result = @cypher conn begin
    p::Person
    call(begin
        with(p)
        p &gt;&gt; r::KNOWS &gt;&gt; friend::Person
        ret(count(friend) =&gt; :friend_count)
    end)
    ret(p.name =&gt; :name, friend_count)
    order(friend_count, :desc)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 2 fields, 5 rows
 Fields: name, friend_count
  [1] (name = &quot;Alice&quot;, friend_count = 2)
  [2] (name = &quot;Bob&quot;, friend_count = 1)
  [3] (name = &quot;Eve&quot;, friend_count = 0)
  [4] (name = &quot;Carol&quot;, friend_count = 0)
  [5] (name = &quot;Dave&quot;, friend_count = 0)
 Notifications: 1
</code></pre><h3 id="Step-21:-LOAD-CSV"><a class="docs-heading-anchor" href="#Step-21:-LOAD-CSV">Step 21: LOAD CSV</a><a id="Step-21:-LOAD-CSV-1"></a><a class="docs-heading-anchor-permalink" href="#Step-21:-LOAD-CSV" title="Permalink"></a></h3><p>Import data from CSV files. The <code>WITH HEADERS</code> variant is recommended as it maps columns by name:</p><pre><code class="language-julia hljs"># With headers (recommended)
@cypher conn begin
    load_csv_headers(&quot;file:///data/people.csv&quot; =&gt; :row)
    create(p::Person)
    p.name = row.name
    p.age = row.age
end

# Without headers (row is a raw list)
@cypher conn begin
    load_csv(&quot;file:///data/people.csv&quot; =&gt; :row)
    create(p::Person)
    p.name = row
    ret(p)
end</code></pre><div class="admonition is-info" id="Note-fb6bbdf2d2d8da13"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fb6bbdf2d2d8da13" title="Permalink"></a></header><div class="admonition-body"><p>LOAD CSV requires the CSV file to be accessible from the Neo4j server. For <code>file://</code> URLs, the server must be configured with <code>server.directories.import</code>.</p></div></div><h3 id="Step-22:-FOREACH"><a class="docs-heading-anchor" href="#Step-22:-FOREACH">Step 22: FOREACH</a><a id="Step-22:-FOREACH-1"></a><a class="docs-heading-anchor-permalink" href="#Step-22:-FOREACH" title="Permalink"></a></h3><p>Apply updates over a collection:</p><pre><code class="language-julia hljs">names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;]
@cypher conn begin
    p::Person
    where(in(p.name, $names))
    with(collect(p) =&gt; :people)
    foreach(people =&gt; :n, begin
        n.verified = true
    end)
end
println(&quot;FOREACH applied&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FOREACH applied</code></pre><p>FOREACH body supports property assignments (auto-SET), <code>create()</code>, <code>merge()</code>, <code>delete()</code>, <code>detach_delete()</code>, <code>remove()</code>, and nested <code>foreach()</code>.</p><h3 id="Step-23:-Index-and-constraint-management"><a class="docs-heading-anchor" href="#Step-23:-Index-and-constraint-management">Step 23: Index and constraint management</a><a id="Step-23:-Index-and-constraint-management-1"></a><a class="docs-heading-anchor-permalink" href="#Step-23:-Index-and-constraint-management" title="Permalink"></a></h3><pre><code class="language-julia hljs">@cypher conn begin
    create_index(:Person, :name)
end
println(&quot;Index created&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Index created</code></pre><pre><code class="language-julia hljs"># Named index
@cypher conn begin
    create_index(:Person, :email, :person_email_idx)
end
println(&quot;Named index created&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Named index created</code></pre><pre><code class="language-julia hljs"># Drop an index
@cypher conn begin
    drop_index(:person_email_idx)
end
println(&quot;Index dropped&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Index dropped</code></pre><pre><code class="language-julia hljs"># Uniqueness constraint
@cypher conn begin
    create_constraint(:Person, :email, :unique)
end
println(&quot;Constraint created&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraint created</code></pre><pre><code class="language-julia hljs"># NOT NULL constraint (named)
@cypher conn begin
    create_constraint(:Person, :name, :not_null, :person_name_required)
end
println(&quot;NOT NULL constraint created&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NOT NULL constraint created</code></pre><pre><code class="language-julia hljs"># Drop a constraint
@cypher conn begin
    drop_constraint(:person_name_required)
end
println(&quot;Constraint dropped&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constraint dropped</code></pre><h3 id="Comprehension-form"><a class="docs-heading-anchor" href="#Comprehension-form">Comprehension form</a><a id="Comprehension-form-1"></a><a class="docs-heading-anchor-permalink" href="#Comprehension-form" title="Permalink"></a></h3><p>For simple match-filter-return queries, use Julia&#39;s comprehension syntax:</p><pre><code class="language-julia hljs">result = @cypher conn [p.name for p in Person if p.age &gt; 25]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 3 rows
 Fields: p.name
  [1] (var&quot;p.name&quot; = &quot;Alice&quot;,)
  [2] (var&quot;p.name&quot; = &quot;Carol&quot;,)
  [3] (var&quot;p.name&quot; = &quot;Dave&quot;,)
</code></pre><pre><code class="language-julia hljs">result = @cypher conn [p for p in Person]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 5 rows
 Fields: p
  [1] (p = Node(:Person {name: &quot;Eve&quot;, age: 22}),)
  [2] (p = Node(:Person {name: &quot;Alice&quot;, verified: true, last_seen: &quot;2025-02-15&quot;, age: 31}),)
  [3] (p = Node(:Person {name: &quot;Bob&quot;, verified: true, last_seen: &quot;2025-02-15&quot;, age: 25}),)
  [4] (p = Node(:Person {name: &quot;Carol&quot;, verified: true, last_seen: &quot;2025-02-15&quot;, age: 35}),)
  [5] (p = Node(:Person {name: &quot;Dave&quot;, age: 28}),)
</code></pre><pre><code class="language-julia hljs">result = @cypher conn [(p.name, p.age) for p in Person]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 2 fields, 5 rows
 Fields: p.name, p.age
  [1] (var&quot;p.name&quot; = &quot;Eve&quot;, var&quot;p.age&quot; = 22)
  [2] (var&quot;p.name&quot; = &quot;Alice&quot;, var&quot;p.age&quot; = 31)
  [3] (var&quot;p.name&quot; = &quot;Bob&quot;, var&quot;p.age&quot; = 25)
  [4] (var&quot;p.name&quot; = &quot;Carol&quot;, var&quot;p.age&quot; = 35)
  [5] (var&quot;p.name&quot; = &quot;Dave&quot;, var&quot;p.age&quot; = 28)
</code></pre><pre><code class="language-julia hljs">result = @cypher conn [p.name =&gt; :n for p in Person]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QueryResult: 1 field, 5 rows
 Fields: n
  [1] (n = &quot;Eve&quot;,)
  [2] (n = &quot;Alice&quot;,)
  [3] (n = &quot;Bob&quot;,)
  [4] (n = &quot;Carol&quot;,)
  [5] (n = &quot;Dave&quot;,)
</code></pre><h2 id="Known-limitations"><a class="docs-heading-anchor" href="#Known-limitations">Known limitations</a><a id="Known-limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Known-limitations" title="Permalink"></a></h2><p>These Cypher features are <strong>not supported</strong> by the DSL:</p><ul><li>Inline property patterns in MATCH (<code>{name: $v}</code>) — Julia&#39;s parser cannot parse <code>{…}</code> as an expression; use <code>where()</code> instead</li><li>Shortest path functions (<code>shortestPath</code>, <code>allShortestPaths</code>)</li><li>Procedure calls via <code>CALL db.xxx()</code> (distinct from CALL subqueries)</li><li>Map projections and list comprehensions in the Cypher sense</li></ul><h2 id="Standalone-mutations"><a class="docs-heading-anchor" href="#Standalone-mutations">Standalone mutations</a><a id="Standalone-mutations-1"></a><a class="docs-heading-anchor-permalink" href="#Standalone-mutations" title="Permalink"></a></h2><p>For common single-entity operations, use the dedicated macros:</p><h3 id="@create-—-create-a-node"><a class="docs-heading-anchor" href="#@create-—-create-a-node"><code>@create</code> — create a node</a><a id="@create-—-create-a-node-1"></a><a class="docs-heading-anchor-permalink" href="#@create-—-create-a-node" title="Permalink"></a></h3><pre><code class="language-julia hljs">node = @create conn Person(name=&quot;Diana&quot;, age=28)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node(:Person {name: &quot;Diana&quot;, age: 28})</code></pre><p>Validates against the registered <code>Person</code> schema (if present).</p><h3 id="@merge-—-upsert-a-node"><a class="docs-heading-anchor" href="#@merge-—-upsert-a-node"><code>@merge</code> — upsert a node</a><a id="@merge-—-upsert-a-node-1"></a><a class="docs-heading-anchor-permalink" href="#@merge-—-upsert-a-node" title="Permalink"></a></h3><pre><code class="language-julia hljs">node = @merge conn Person(name=&quot;Diana&quot;) on_create(age=28, email=&quot;d@b.com&quot;) on_match(age=29)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node(:Person {name: &quot;Diana&quot;, age: 29})</code></pre><p>Simple merge without <code>on_create</code>/<code>on_match</code>:</p><pre><code class="language-julia hljs">node = @merge conn Person(name=&quot;Diana&quot;, age=29)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Node(:Person {name: &quot;Diana&quot;, age: 29})</code></pre><h3 id="@relate-—-create-a-relationship"><a class="docs-heading-anchor" href="#@relate-—-create-a-relationship"><code>@relate</code> — create a relationship</a><a id="@relate-—-create-a-relationship-1"></a><a class="docs-heading-anchor-permalink" href="#@relate-—-create-a-relationship" title="Permalink"></a></h3><pre><code class="language-julia hljs">diana = @create conn Person(name=&quot;Diana2&quot;, age=28)
edgar = @create conn Person(name=&quot;Edgar&quot;, age=32)

rel = @relate conn diana =&gt; KNOWS(since=2024) =&gt; edgar</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Relationship(:KNOWS {since: 2024})</code></pre><pre><code class="language-julia hljs">println(rel.type)
println(rel[&quot;since&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">KNOWS
2024</code></pre><p>Matches nodes by <code>elementId()</code> and validates against the <code>KNOWS</code> schema (if registered).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../streaming/">« Streaming</a><a class="docs-footer-nextpage" href="../biomedical_case_study/">Biomedical Case Study »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 16 February 2026 12:10">Monday 16 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
